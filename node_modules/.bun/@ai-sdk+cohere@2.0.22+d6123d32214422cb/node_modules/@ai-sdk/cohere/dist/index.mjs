// src/cohere-provider.ts
import {
  NoSuchModelError
} from "@ai-sdk/provider";
import {
  generateId as generateId2,
  loadApiKey,
  withoutTrailingSlash,
  withUserAgentSuffix
} from "@ai-sdk/provider-utils";

// src/cohere-chat-language-model.ts
import {
  combineHeaders,
  createEventSourceResponseHandler,
  createJsonResponseHandler,
  parseProviderOptions,
  postJsonToApi
} from "@ai-sdk/provider-utils";
import { z as z3 } from "zod/v4";

// src/cohere-chat-options.ts
import { z } from "zod/v4";
var cohereChatModelOptions = z.object({
  /**
   * Configuration for reasoning features (optional)
   *
   * Can be set to an object with the two properties `type` and `tokenBudget`. `type` can be set to `'enabled'` or `'disabled'` (defaults to `'enabled'`).
   * `tokenBudget` is the maximum number of tokens the model can use for thinking, which must be set to a positive integer. The model will stop thinking if it reaches the thinking token budget and will proceed with the response
   *
   * @see https://docs.cohere.com/reference/chat#request.body.thinking
   */
  thinking: z.object({
    type: z.enum(["enabled", "disabled"]).optional(),
    tokenBudget: z.number().optional()
  }).optional()
});

// src/cohere-error.ts
import { createJsonErrorResponseHandler } from "@ai-sdk/provider-utils";
import { z as z2 } from "zod/v4";
var cohereErrorDataSchema = z2.object({
  message: z2.string()
});
var cohereFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: cohereErrorDataSchema,
  errorToMessage: (data) => data.message
});

// src/convert-to-cohere-chat-prompt.ts
import {
  UnsupportedFunctionalityError
} from "@ai-sdk/provider";
function convertToCohereChatPrompt(prompt) {
  const messages = [];
  const documents = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        messages.push({
          role: "user",
          content: content.map((part) => {
            var _a;
            switch (part.type) {
              case "text": {
                return part.text;
              }
              case "file": {
                let textContent;
                if (typeof part.data === "string") {
                  textContent = part.data;
                } else if (part.data instanceof Uint8Array) {
                  if (!(((_a = part.mediaType) == null ? void 0 : _a.startsWith("text/")) || part.mediaType === "application/json")) {
                    throw new UnsupportedFunctionalityError({
                      functionality: `document media type: ${part.mediaType}`,
                      message: `Media type '${part.mediaType}' is not supported. Supported media types are: text/* and application/json.`
                    });
                  }
                  textContent = new TextDecoder().decode(part.data);
                } else {
                  throw new UnsupportedFunctionalityError({
                    functionality: "File URL data",
                    message: "URLs should be downloaded by the AI SDK and not reach this point. This indicates a configuration issue."
                  });
                }
                documents.push({
                  data: {
                    text: textContent,
                    title: part.filename
                  }
                });
                return "";
              }
            }
          }).join("")
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: toolCalls.length > 0 ? void 0 : text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          tool_plan: void 0
        });
        break;
      }
      case "tool": {
        messages.push(
          ...content.map((toolResult) => {
            const output = toolResult.output;
            let contentValue;
            switch (output.type) {
              case "text":
              case "error-text":
                contentValue = output.value;
                break;
              case "content":
              case "json":
              case "error-json":
                contentValue = JSON.stringify(output.value);
                break;
            }
            return {
              role: "tool",
              content: contentValue,
              tool_call_id: toolResult.toolCallId
            };
          })
        );
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, documents, warnings };
}

// src/map-cohere-finish-reason.ts
function mapCohereFinishReason(finishReason) {
  switch (finishReason) {
    case "COMPLETE":
    case "STOP_SEQUENCE":
      return "stop";
    case "MAX_TOKENS":
      return "length";
    case "ERROR":
      return "error";
    case "TOOL_CALL":
      return "tool-calls";
    default:
      return "unknown";
  }
}

// src/cohere-prepare-tools.ts
import {
  UnsupportedFunctionalityError as UnsupportedFunctionalityError2
} from "@ai-sdk/provider";
function prepareTools({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const cohereTools = [];
  for (const tool of tools) {
    if (tool.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool });
    } else {
      cohereTools.push({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: cohereTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return { tools: cohereTools, toolChoice: void 0, toolWarnings };
    case "none":
      return { tools: cohereTools, toolChoice: "NONE", toolWarnings };
    case "required":
      return { tools: cohereTools, toolChoice: "REQUIRED", toolWarnings };
    case "tool":
      return {
        tools: cohereTools.filter(
          (tool) => tool.function.name === toolChoice.toolName
        ),
        toolChoice: "REQUIRED",
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError2({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}

// src/cohere-chat-language-model.ts
var CohereChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      // No URLs are supported.
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    tools,
    toolChoice,
    providerOptions
  }) {
    var _a, _b;
    const cohereOptions = (_a = await parseProviderOptions({
      provider: "cohere",
      providerOptions,
      schema: cohereChatModelOptions
    })) != null ? _a : {};
    const {
      messages: chatPrompt,
      documents: cohereDocuments,
      warnings: promptWarnings
    } = convertToCohereChatPrompt(prompt);
    const {
      tools: cohereTools,
      toolChoice: cohereToolChoice,
      toolWarnings
    } = prepareTools({ tools, toolChoice });
    return {
      args: {
        // model id:
        model: this.modelId,
        // standardized settings:
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        max_tokens: maxOutputTokens,
        temperature,
        p: topP,
        k: topK,
        seed,
        stop_sequences: stopSequences,
        // response format:
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? { type: "json_object", json_schema: responseFormat.schema } : void 0,
        // messages:
        messages: chatPrompt,
        // tools:
        tools: cohereTools,
        tool_choice: cohereToolChoice,
        // documents for RAG:
        ...cohereDocuments.length > 0 && { documents: cohereDocuments },
        // reasoning
        ...cohereOptions.thinking && {
          thinking: {
            type: (_b = cohereOptions.thinking.type) != null ? _b : "enabled",
            token_budget: cohereOptions.thinking.tokenBudget
          }
        }
      },
      warnings: [...toolWarnings, ...promptWarnings]
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f;
    const { args, warnings } = await this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: `${this.config.baseURL}/chat`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: cohereFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        cohereChatResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const content = [];
    for (const item of (_a = response.message.content) != null ? _a : []) {
      if (item.type === "text" && item.text.length > 0) {
        content.push({ type: "text", text: item.text });
        continue;
      }
      if (item.type === "thinking" && item.thinking.length > 0) {
        content.push({ type: "reasoning", text: item.thinking });
        continue;
      }
    }
    for (const citation of (_b = response.message.citations) != null ? _b : []) {
      content.push({
        type: "source",
        sourceType: "document",
        id: this.config.generateId(),
        mediaType: "text/plain",
        title: ((_d = (_c = citation.sources[0]) == null ? void 0 : _c.document) == null ? void 0 : _d.title) || "Document",
        providerMetadata: {
          cohere: {
            start: citation.start,
            end: citation.end,
            text: citation.text,
            sources: citation.sources,
            ...citation.type && { citationType: citation.type }
          }
        }
      });
    }
    for (const toolCall of (_e = response.message.tool_calls) != null ? _e : []) {
      content.push({
        type: "tool-call",
        toolCallId: toolCall.id,
        toolName: toolCall.function.name,
        // Cohere sometimes returns `null` for tool call arguments for tools
        // defined as having no arguments.
        input: toolCall.function.arguments.replace(/^null$/, "{}")
      });
    }
    return {
      content,
      finishReason: mapCohereFinishReason(response.finish_reason),
      usage: {
        inputTokens: response.usage.tokens.input_tokens,
        outputTokens: response.usage.tokens.output_tokens,
        totalTokens: response.usage.tokens.input_tokens + response.usage.tokens.output_tokens
      },
      request: { body: args },
      response: {
        // TODO timestamp, model id
        id: (_f = response.generation_id) != null ? _f : void 0,
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const { responseHeaders, value: response } = await postJsonToApi({
      url: `${this.config.baseURL}/chat`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body: { ...args, stream: true },
      failedResponseHandler: cohereFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(
        cohereChatChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    let pendingToolCall = null;
    let isActiveReasoning = false;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a, _b;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            const type = value.type;
            switch (type) {
              case "content-start": {
                if (value.delta.message.content.type === "thinking") {
                  controller.enqueue({
                    type: "reasoning-start",
                    id: String(value.index)
                  });
                  isActiveReasoning = true;
                  return;
                }
                controller.enqueue({
                  type: "text-start",
                  id: String(value.index)
                });
                return;
              }
              case "content-delta": {
                if ("thinking" in value.delta.message.content) {
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: String(value.index),
                    delta: value.delta.message.content.thinking
                  });
                  return;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: String(value.index),
                  delta: value.delta.message.content.text
                });
                return;
              }
              case "content-end": {
                if (isActiveReasoning) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: String(value.index)
                  });
                  isActiveReasoning = false;
                  return;
                }
                controller.enqueue({
                  type: "text-end",
                  id: String(value.index)
                });
                return;
              }
              case "tool-call-start": {
                const toolId = value.delta.message.tool_calls.id;
                const toolName = value.delta.message.tool_calls.function.name;
                const initialArgs = value.delta.message.tool_calls.function.arguments;
                pendingToolCall = {
                  id: toolId,
                  name: toolName,
                  arguments: initialArgs,
                  hasFinished: false
                };
                controller.enqueue({
                  type: "tool-input-start",
                  id: toolId,
                  toolName
                });
                if (initialArgs.length > 0) {
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolId,
                    delta: initialArgs
                  });
                }
                return;
              }
              case "tool-call-delta": {
                if (pendingToolCall && !pendingToolCall.hasFinished) {
                  const argsDelta = value.delta.message.tool_calls.function.arguments;
                  pendingToolCall.arguments += argsDelta;
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: pendingToolCall.id,
                    delta: argsDelta
                  });
                }
                return;
              }
              case "tool-call-end": {
                if (pendingToolCall && !pendingToolCall.hasFinished) {
                  controller.enqueue({
                    type: "tool-input-end",
                    id: pendingToolCall.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: pendingToolCall.id,
                    toolName: pendingToolCall.name,
                    input: JSON.stringify(
                      JSON.parse(((_a = pendingToolCall.arguments) == null ? void 0 : _a.trim()) || "{}")
                    )
                  });
                  pendingToolCall.hasFinished = true;
                  pendingToolCall = null;
                }
                return;
              }
              case "message-start": {
                controller.enqueue({
                  type: "response-metadata",
                  id: (_b = value.id) != null ? _b : void 0
                });
                return;
              }
              case "message-end": {
                finishReason = mapCohereFinishReason(value.delta.finish_reason);
                const tokens = value.delta.usage.tokens;
                usage.inputTokens = tokens.input_tokens;
                usage.outputTokens = tokens.output_tokens;
                usage.totalTokens = tokens.input_tokens + tokens.output_tokens;
                return;
              }
              default: {
                return;
              }
            }
          },
          flush(controller) {
            controller.enqueue({
              type: "finish",
              finishReason,
              usage
            });
          }
        })
      ),
      request: { body: { ...args, stream: true } },
      response: { headers: responseHeaders }
    };
  }
};
var cohereChatResponseSchema = z3.object({
  generation_id: z3.string().nullish(),
  message: z3.object({
    role: z3.string(),
    content: z3.array(
      z3.union([
        z3.object({
          type: z3.literal("text"),
          text: z3.string()
        }),
        z3.object({
          type: z3.literal("thinking"),
          thinking: z3.string()
        })
      ])
    ).nullish(),
    tool_plan: z3.string().nullish(),
    tool_calls: z3.array(
      z3.object({
        id: z3.string(),
        type: z3.literal("function"),
        function: z3.object({
          name: z3.string(),
          arguments: z3.string()
        })
      })
    ).nullish(),
    citations: z3.array(
      z3.object({
        start: z3.number(),
        end: z3.number(),
        text: z3.string(),
        sources: z3.array(
          z3.object({
            type: z3.string().optional(),
            id: z3.string().optional(),
            document: z3.object({
              id: z3.string().optional(),
              text: z3.string(),
              title: z3.string()
            })
          })
        ),
        type: z3.string().optional()
      })
    ).nullish()
  }),
  finish_reason: z3.string(),
  usage: z3.object({
    billed_units: z3.object({
      input_tokens: z3.number(),
      output_tokens: z3.number()
    }),
    tokens: z3.object({
      input_tokens: z3.number(),
      output_tokens: z3.number()
    })
  })
});
var cohereChatChunkSchema = z3.discriminatedUnion("type", [
  z3.object({
    type: z3.literal("citation-start")
  }),
  z3.object({
    type: z3.literal("citation-end")
  }),
  z3.object({
    type: z3.literal("content-start"),
    index: z3.number(),
    delta: z3.object({
      message: z3.object({
        content: z3.union([
          z3.object({
            type: z3.literal("text"),
            text: z3.string()
          }),
          z3.object({
            type: z3.literal("thinking"),
            thinking: z3.string()
          })
        ])
      })
    })
  }),
  z3.object({
    type: z3.literal("content-delta"),
    index: z3.number(),
    delta: z3.object({
      message: z3.object({
        content: z3.union([
          z3.object({
            text: z3.string()
          }),
          z3.object({
            thinking: z3.string()
          })
        ])
      })
    })
  }),
  z3.object({
    type: z3.literal("content-end"),
    index: z3.number()
  }),
  z3.object({
    type: z3.literal("message-start"),
    id: z3.string().nullish()
  }),
  z3.object({
    type: z3.literal("message-end"),
    delta: z3.object({
      finish_reason: z3.string(),
      usage: z3.object({
        tokens: z3.object({
          input_tokens: z3.number(),
          output_tokens: z3.number()
        })
      })
    })
  }),
  // https://docs.cohere.com/v2/docs/streaming#tool-use-stream-events-for-tool-calling
  z3.object({
    type: z3.literal("tool-plan-delta"),
    delta: z3.object({
      message: z3.object({
        tool_plan: z3.string()
      })
    })
  }),
  z3.object({
    type: z3.literal("tool-call-start"),
    delta: z3.object({
      message: z3.object({
        tool_calls: z3.object({
          id: z3.string(),
          type: z3.literal("function"),
          function: z3.object({
            name: z3.string(),
            arguments: z3.string()
          })
        })
      })
    })
  }),
  // A single tool call's `arguments` stream in chunks and must be accumulated
  // in a string and so the full tool object info can only be parsed once we see
  // `tool-call-end`.
  z3.object({
    type: z3.literal("tool-call-delta"),
    delta: z3.object({
      message: z3.object({
        tool_calls: z3.object({
          function: z3.object({
            arguments: z3.string()
          })
        })
      })
    })
  }),
  z3.object({
    type: z3.literal("tool-call-end")
  })
]);

// src/cohere-embedding-model.ts
import {
  TooManyEmbeddingValuesForCallError
} from "@ai-sdk/provider";
import {
  combineHeaders as combineHeaders2,
  createJsonResponseHandler as createJsonResponseHandler2,
  parseProviderOptions as parseProviderOptions2,
  postJsonToApi as postJsonToApi2
} from "@ai-sdk/provider-utils";
import { z as z5 } from "zod/v4";

// src/cohere-embedding-options.ts
import { z as z4 } from "zod/v4";
var cohereEmbeddingOptions = z4.object({
  /**
   * Specifies the type of input passed to the model. Default is `search_query`.
   *
   * - "search_document": Used for embeddings stored in a vector database for search use-cases.
   * - "search_query": Used for embeddings of search queries run against a vector DB to find relevant documents.
   * - "classification": Used for embeddings passed through a text classifier.
   * - "clustering": Used for embeddings run through a clustering algorithm.
   */
  inputType: z4.enum(["search_document", "search_query", "classification", "clustering"]).optional(),
  /**
   * Specifies how the API will handle inputs longer than the maximum token length.
   * Default is `END`.
   *
   * - "NONE": If selected, when the input exceeds the maximum input token length will return an error.
   * - "START": Will discard the start of the input until the remaining input is exactly the maximum input token length for the model.
   * - "END": Will discard the end of the input until the remaining input is exactly the maximum input token length for the model.
   */
  truncate: z4.enum(["NONE", "START", "END"]).optional()
});

// src/cohere-embedding-model.ts
var CohereEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 96;
    this.supportsParallelCalls = true;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a;
    const embeddingOptions = await parseProviderOptions2({
      provider: "cohere",
      providerOptions,
      schema: cohereEmbeddingOptions
    });
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    }
    const {
      responseHeaders,
      value: response,
      rawValue
    } = await postJsonToApi2({
      url: `${this.config.baseURL}/embed`,
      headers: combineHeaders2(this.config.headers(), headers),
      body: {
        model: this.modelId,
        // The AI SDK only supports 'float' embeddings which are also the only ones
        // the Cohere API docs state are supported for all models.
        // https://docs.cohere.com/v2/reference/embed#request.body.embedding_types
        embedding_types: ["float"],
        texts: values,
        input_type: (_a = embeddingOptions == null ? void 0 : embeddingOptions.inputType) != null ? _a : "search_query",
        truncate: embeddingOptions == null ? void 0 : embeddingOptions.truncate
      },
      failedResponseHandler: cohereFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler2(
        cohereTextEmbeddingResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      embeddings: response.embeddings.float,
      usage: { tokens: response.meta.billed_units.input_tokens },
      response: { headers: responseHeaders, body: rawValue }
    };
  }
};
var cohereTextEmbeddingResponseSchema = z5.object({
  embeddings: z5.object({
    float: z5.array(z5.array(z5.number()))
  }),
  meta: z5.object({
    billed_units: z5.object({
      input_tokens: z5.number()
    })
  })
});

// src/version.ts
var VERSION = true ? "2.0.22" : "0.0.0-test";

// src/cohere-provider.ts
function createCohere(options = {}) {
  var _a;
  const baseURL = (_a = withoutTrailingSlash(options.baseURL)) != null ? _a : "https://api.cohere.com/v2";
  const getHeaders = () => withUserAgentSuffix(
    {
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "COHERE_API_KEY",
        description: "Cohere"
      })}`,
      ...options.headers
    },
    `ai-sdk/cohere/${VERSION}`
  );
  const createChatModel = (modelId) => {
    var _a2;
    return new CohereChatLanguageModel(modelId, {
      provider: "cohere.chat",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: (_a2 = options.generateId) != null ? _a2 : generateId2
    });
  };
  const createTextEmbeddingModel = (modelId) => new CohereEmbeddingModel(modelId, {
    provider: "cohere.textEmbedding",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Cohere model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.embedding = createTextEmbeddingModel;
  provider.textEmbeddingModel = createTextEmbeddingModel;
  provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
var cohere = createCohere();
export {
  VERSION,
  cohere,
  createCohere
};
//# sourceMappingURL=index.mjs.map