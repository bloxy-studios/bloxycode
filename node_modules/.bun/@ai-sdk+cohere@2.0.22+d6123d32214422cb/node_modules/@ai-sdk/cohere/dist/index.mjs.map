{"version":3,"sources":["../src/cohere-provider.ts","../src/cohere-chat-language-model.ts","../src/cohere-chat-options.ts","../src/cohere-error.ts","../src/convert-to-cohere-chat-prompt.ts","../src/map-cohere-finish-reason.ts","../src/cohere-prepare-tools.ts","../src/cohere-embedding-model.ts","../src/cohere-embedding-options.ts","../src/version.ts"],"sourcesContent":["import {\n  EmbeddingModelV2,\n  LanguageModelV2,\n  NoSuchModelError,\n  ProviderV2,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  generateId,\n  loadApiKey,\n  withoutTrailingSlash,\n  withUserAgentSuffix,\n} from '@ai-sdk/provider-utils';\nimport { CohereChatLanguageModel } from './cohere-chat-language-model';\nimport { CohereChatModelId } from './cohere-chat-options';\nimport { CohereEmbeddingModel } from './cohere-embedding-model';\nimport { CohereEmbeddingModelId } from './cohere-embedding-options';\nimport { VERSION } from './version';\n\nexport interface CohereProvider extends ProviderV2 {\n  (modelId: CohereChatModelId): LanguageModelV2;\n\n  /**\nCreates a model for text generation.\n*/\n  languageModel(modelId: CohereChatModelId): LanguageModelV2;\n\n  embedding(modelId: CohereEmbeddingModelId): EmbeddingModelV2<string>;\n\n  textEmbeddingModel(modelId: CohereEmbeddingModelId): EmbeddingModelV2<string>;\n}\n\nexport interface CohereProviderSettings {\n  /**\nUse a different URL prefix for API calls, e.g. to use proxy servers.\nThe default prefix is `https://api.cohere.com/v2`.\n   */\n  baseURL?: string;\n\n  /**\nAPI key that is being send using the `Authorization` header.\nIt defaults to the `COHERE_API_KEY` environment variable.\n   */\n  apiKey?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n\n  /**\nOptional function to generate a unique ID for each request.\n     */\n  generateId?: () => string;\n}\n\n/**\nCreate a Cohere AI provider instance.\n */\nexport function createCohere(\n  options: CohereProviderSettings = {},\n): CohereProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ?? 'https://api.cohere.com/v2';\n\n  const getHeaders = () =>\n    withUserAgentSuffix(\n      {\n        Authorization: `Bearer ${loadApiKey({\n          apiKey: options.apiKey,\n          environmentVariableName: 'COHERE_API_KEY',\n          description: 'Cohere',\n        })}`,\n        ...options.headers,\n      },\n      `ai-sdk/cohere/${VERSION}`,\n    );\n\n  const createChatModel = (modelId: CohereChatModelId) =>\n    new CohereChatLanguageModel(modelId, {\n      provider: 'cohere.chat',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      generateId: options.generateId ?? generateId,\n    });\n\n  const createTextEmbeddingModel = (modelId: CohereEmbeddingModelId) =>\n    new CohereEmbeddingModel(modelId, {\n      provider: 'cohere.textEmbedding',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const provider = function (modelId: CohereChatModelId) {\n    if (new.target) {\n      throw new Error(\n        'The Cohere model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createChatModel(modelId);\n  };\n\n  provider.languageModel = createChatModel;\n  provider.embedding = createTextEmbeddingModel;\n  provider.textEmbeddingModel = createTextEmbeddingModel;\n\n  provider.imageModel = (modelId: string) => {\n    throw new NoSuchModelError({ modelId, modelType: 'imageModel' });\n  };\n\n  return provider;\n}\n\n/**\nDefault Cohere provider instance.\n */\nexport const cohere = createCohere();\n","import {\n  LanguageModelV2,\n  LanguageModelV2CallWarning,\n  LanguageModelV2Content,\n  LanguageModelV2FinishReason,\n  LanguageModelV2Prompt,\n  LanguageModelV2StreamPart,\n  LanguageModelV2Usage,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  parseProviderOptions,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport {\n  CohereChatModelId,\n  cohereChatModelOptions,\n} from './cohere-chat-options';\nimport { cohereFailedResponseHandler } from './cohere-error';\nimport { convertToCohereChatPrompt } from './convert-to-cohere-chat-prompt';\nimport { mapCohereFinishReason } from './map-cohere-finish-reason';\nimport { prepareTools } from './cohere-prepare-tools';\n\ntype CohereChatConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  fetch?: FetchFunction;\n  generateId: () => string;\n};\n\nexport class CohereChatLanguageModel implements LanguageModelV2 {\n  readonly specificationVersion = 'v2';\n\n  readonly modelId: CohereChatModelId;\n\n  readonly supportedUrls = {\n    // No URLs are supported.\n  };\n\n  private readonly config: CohereChatConfig;\n\n  constructor(modelId: CohereChatModelId, config: CohereChatConfig) {\n    this.modelId = modelId;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private async getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    tools,\n    toolChoice,\n    providerOptions,\n  }: Parameters<LanguageModelV2['doGenerate']>[0]) {\n    // Parse provider options\n    const cohereOptions =\n      (await parseProviderOptions({\n        provider: 'cohere',\n        providerOptions,\n        schema: cohereChatModelOptions,\n      })) ?? {};\n\n    const {\n      messages: chatPrompt,\n      documents: cohereDocuments,\n      warnings: promptWarnings,\n    } = convertToCohereChatPrompt(prompt);\n\n    const {\n      tools: cohereTools,\n      toolChoice: cohereToolChoice,\n      toolWarnings,\n    } = prepareTools({ tools, toolChoice });\n\n    return {\n      args: {\n        // model id:\n        model: this.modelId,\n\n        // standardized settings:\n        frequency_penalty: frequencyPenalty,\n        presence_penalty: presencePenalty,\n        max_tokens: maxOutputTokens,\n        temperature,\n        p: topP,\n        k: topK,\n        seed,\n        stop_sequences: stopSequences,\n\n        // response format:\n        response_format:\n          responseFormat?.type === 'json'\n            ? { type: 'json_object', json_schema: responseFormat.schema }\n            : undefined,\n\n        // messages:\n        messages: chatPrompt,\n\n        // tools:\n        tools: cohereTools,\n        tool_choice: cohereToolChoice,\n\n        // documents for RAG:\n        ...(cohereDocuments.length > 0 && { documents: cohereDocuments }),\n\n        // reasoning\n        ...(cohereOptions.thinking && {\n          thinking: {\n            type: cohereOptions.thinking.type ?? 'enabled',\n            token_budget: cohereOptions.thinking.tokenBudget,\n          },\n        }),\n      },\n      warnings: [...toolWarnings, ...promptWarnings],\n    };\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV2['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doGenerate']>>> {\n    const { args, warnings } = await this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: `${this.config.baseURL}/chat`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: cohereFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        cohereChatResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const content: Array<LanguageModelV2Content> = [];\n\n    for (const item of response.message.content ?? []) {\n      if (item.type === 'text' && item.text.length > 0) {\n        content.push({ type: 'text', text: item.text });\n        continue;\n      }\n\n      if (item.type === 'thinking' && item.thinking.length > 0) {\n        content.push({ type: 'reasoning', text: item.thinking });\n        continue;\n      }\n    }\n\n    // citations:\n    for (const citation of response.message.citations ?? []) {\n      content.push({\n        type: 'source',\n        sourceType: 'document',\n        id: this.config.generateId(),\n        mediaType: 'text/plain',\n        title: citation.sources[0]?.document?.title || 'Document',\n        providerMetadata: {\n          cohere: {\n            start: citation.start,\n            end: citation.end,\n            text: citation.text,\n            sources: citation.sources,\n            ...(citation.type && { citationType: citation.type }),\n          },\n        },\n      });\n    }\n\n    // tool calls:\n    for (const toolCall of response.message.tool_calls ?? []) {\n      content.push({\n        type: 'tool-call' as const,\n        toolCallId: toolCall.id,\n        toolName: toolCall.function.name,\n        // Cohere sometimes returns `null` for tool call arguments for tools\n        // defined as having no arguments.\n        input: toolCall.function.arguments.replace(/^null$/, '{}'),\n      });\n    }\n\n    return {\n      content,\n      finishReason: mapCohereFinishReason(response.finish_reason),\n      usage: {\n        inputTokens: response.usage.tokens.input_tokens,\n        outputTokens: response.usage.tokens.output_tokens,\n        totalTokens:\n          response.usage.tokens.input_tokens +\n          response.usage.tokens.output_tokens,\n      },\n      request: { body: args },\n      response: {\n        // TODO timestamp, model id\n        id: response.generation_id ?? undefined,\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n      warnings,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV2['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doStream']>>> {\n    const { args, warnings } = await this.getArgs(options);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/chat`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: { ...args, stream: true },\n      failedResponseHandler: cohereFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        cohereChatChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    let finishReason: LanguageModelV2FinishReason = 'unknown';\n    const usage: LanguageModelV2Usage = {\n      inputTokens: undefined,\n      outputTokens: undefined,\n      totalTokens: undefined,\n    };\n\n    let pendingToolCall: {\n      id: string;\n      name: string;\n      arguments: string;\n      hasFinished: boolean;\n    } | null = null;\n\n    let isActiveReasoning = false;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof cohereChatChunkSchema>>,\n          LanguageModelV2StreamPart\n        >({\n          start(controller) {\n            controller.enqueue({ type: 'stream-start', warnings });\n          },\n\n          transform(chunk, controller) {\n            if (options.includeRawChunks) {\n              controller.enqueue({ type: 'raw', rawValue: chunk.rawValue });\n            }\n\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n            const type = value.type;\n\n            switch (type) {\n              case 'content-start': {\n                if (value.delta.message.content.type === 'thinking') {\n                  controller.enqueue({\n                    type: 'reasoning-start',\n                    id: String(value.index),\n                  });\n                  isActiveReasoning = true;\n                  return;\n                }\n\n                controller.enqueue({\n                  type: 'text-start',\n                  id: String(value.index),\n                });\n                return;\n              }\n\n              case 'content-delta': {\n                if ('thinking' in value.delta.message.content) {\n                  controller.enqueue({\n                    type: 'reasoning-delta',\n                    id: String(value.index),\n                    delta: value.delta.message.content.thinking,\n                  });\n                  return;\n                }\n\n                controller.enqueue({\n                  type: 'text-delta',\n                  id: String(value.index),\n                  delta: value.delta.message.content.text,\n                });\n                return;\n              }\n\n              case 'content-end': {\n                if (isActiveReasoning) {\n                  controller.enqueue({\n                    type: 'reasoning-end',\n                    id: String(value.index),\n                  });\n                  isActiveReasoning = false;\n                  return;\n                }\n\n                controller.enqueue({\n                  type: 'text-end',\n                  id: String(value.index),\n                });\n\n                return;\n              }\n\n              case 'tool-call-start': {\n                const toolId = value.delta.message.tool_calls.id;\n                const toolName = value.delta.message.tool_calls.function.name;\n                const initialArgs =\n                  value.delta.message.tool_calls.function.arguments;\n\n                pendingToolCall = {\n                  id: toolId,\n                  name: toolName,\n                  arguments: initialArgs,\n                  hasFinished: false,\n                };\n\n                controller.enqueue({\n                  type: 'tool-input-start',\n                  id: toolId,\n                  toolName,\n                });\n\n                if (initialArgs.length > 0) {\n                  controller.enqueue({\n                    type: 'tool-input-delta',\n                    id: toolId,\n                    delta: initialArgs,\n                  });\n                }\n                return;\n              }\n\n              case 'tool-call-delta': {\n                if (pendingToolCall && !pendingToolCall.hasFinished) {\n                  const argsDelta =\n                    value.delta.message.tool_calls.function.arguments;\n                  pendingToolCall.arguments += argsDelta;\n\n                  controller.enqueue({\n                    type: 'tool-input-delta',\n                    id: pendingToolCall.id,\n                    delta: argsDelta,\n                  });\n                }\n                return;\n              }\n\n              case 'tool-call-end': {\n                if (pendingToolCall && !pendingToolCall.hasFinished) {\n                  controller.enqueue({\n                    type: 'tool-input-end',\n                    id: pendingToolCall.id,\n                  });\n\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallId: pendingToolCall.id,\n                    toolName: pendingToolCall.name,\n                    input: JSON.stringify(\n                      JSON.parse(pendingToolCall.arguments?.trim() || '{}'),\n                    ),\n                  });\n\n                  pendingToolCall.hasFinished = true;\n                  pendingToolCall = null;\n                }\n                return;\n              }\n\n              case 'message-start': {\n                controller.enqueue({\n                  type: 'response-metadata',\n                  id: value.id ?? undefined,\n                });\n                return;\n              }\n\n              case 'message-end': {\n                finishReason = mapCohereFinishReason(value.delta.finish_reason);\n                const tokens = value.delta.usage.tokens;\n\n                usage.inputTokens = tokens.input_tokens;\n                usage.outputTokens = tokens.output_tokens;\n                usage.totalTokens = tokens.input_tokens + tokens.output_tokens;\n                return;\n              }\n\n              default: {\n                return;\n              }\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage,\n            });\n          },\n        }),\n      ),\n      request: { body: { ...args, stream: true } },\n      response: { headers: responseHeaders },\n    };\n  }\n}\n\nconst cohereChatResponseSchema = z.object({\n  generation_id: z.string().nullish(),\n  message: z.object({\n    role: z.string(),\n    content: z\n      .array(\n        z.union([\n          z.object({\n            type: z.literal('text'),\n            text: z.string(),\n          }),\n          z.object({\n            type: z.literal('thinking'),\n            thinking: z.string(),\n          }),\n        ]),\n      )\n      .nullish(),\n    tool_plan: z.string().nullish(),\n    tool_calls: z\n      .array(\n        z.object({\n          id: z.string(),\n          type: z.literal('function'),\n          function: z.object({\n            name: z.string(),\n            arguments: z.string(),\n          }),\n        }),\n      )\n      .nullish(),\n    citations: z\n      .array(\n        z.object({\n          start: z.number(),\n          end: z.number(),\n          text: z.string(),\n          sources: z.array(\n            z.object({\n              type: z.string().optional(),\n              id: z.string().optional(),\n              document: z.object({\n                id: z.string().optional(),\n                text: z.string(),\n                title: z.string(),\n              }),\n            }),\n          ),\n          type: z.string().optional(),\n        }),\n      )\n      .nullish(),\n  }),\n  finish_reason: z.string(),\n  usage: z.object({\n    billed_units: z.object({\n      input_tokens: z.number(),\n      output_tokens: z.number(),\n    }),\n    tokens: z.object({\n      input_tokens: z.number(),\n      output_tokens: z.number(),\n    }),\n  }),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst cohereChatChunkSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('citation-start'),\n  }),\n  z.object({\n    type: z.literal('citation-end'),\n  }),\n  z.object({\n    type: z.literal('content-start'),\n    index: z.number(),\n    delta: z.object({\n      message: z.object({\n        content: z.union([\n          z.object({\n            type: z.literal('text'),\n            text: z.string(),\n          }),\n          z.object({\n            type: z.literal('thinking'),\n            thinking: z.string(),\n          }),\n        ]),\n      }),\n    }),\n  }),\n  z.object({\n    type: z.literal('content-delta'),\n    index: z.number(),\n    delta: z.object({\n      message: z.object({\n        content: z.union([\n          z.object({\n            text: z.string(),\n          }),\n          z.object({\n            thinking: z.string(),\n          }),\n        ]),\n      }),\n    }),\n  }),\n  z.object({\n    type: z.literal('content-end'),\n    index: z.number(),\n  }),\n  z.object({\n    type: z.literal('message-start'),\n    id: z.string().nullish(),\n  }),\n  z.object({\n    type: z.literal('message-end'),\n    delta: z.object({\n      finish_reason: z.string(),\n      usage: z.object({\n        tokens: z.object({\n          input_tokens: z.number(),\n          output_tokens: z.number(),\n        }),\n      }),\n    }),\n  }),\n  // https://docs.cohere.com/v2/docs/streaming#tool-use-stream-events-for-tool-calling\n  z.object({\n    type: z.literal('tool-plan-delta'),\n    delta: z.object({\n      message: z.object({\n        tool_plan: z.string(),\n      }),\n    }),\n  }),\n  z.object({\n    type: z.literal('tool-call-start'),\n    delta: z.object({\n      message: z.object({\n        tool_calls: z.object({\n          id: z.string(),\n          type: z.literal('function'),\n          function: z.object({\n            name: z.string(),\n            arguments: z.string(),\n          }),\n        }),\n      }),\n    }),\n  }),\n  // A single tool call's `arguments` stream in chunks and must be accumulated\n  // in a string and so the full tool object info can only be parsed once we see\n  // `tool-call-end`.\n  z.object({\n    type: z.literal('tool-call-delta'),\n    delta: z.object({\n      message: z.object({\n        tool_calls: z.object({\n          function: z.object({\n            arguments: z.string(),\n          }),\n        }),\n      }),\n    }),\n  }),\n  z.object({\n    type: z.literal('tool-call-end'),\n  }),\n]);\n","import { z } from 'zod/v4';\n\n// https://docs.cohere.com/docs/models\nexport type CohereChatModelId =\n  | 'command-a-03-2025'\n  | 'command-a-reasoning-08-2025'\n  | 'command-r7b-12-2024'\n  | 'command-r-plus-04-2024'\n  | 'command-r-plus'\n  | 'command-r-08-2024'\n  | 'command-r-03-2024'\n  | 'command-r'\n  | 'command'\n  | 'command-nightly'\n  | 'command-light'\n  | 'command-light-nightly'\n  | (string & {});\n\nexport const cohereChatModelOptions = z.object({\n  /**\n   * Configuration for reasoning features (optional)\n   *\n   * Can be set to an object with the two properties `type` and `tokenBudget`. `type` can be set to `'enabled'` or `'disabled'` (defaults to `'enabled'`).\n   * `tokenBudget` is the maximum number of tokens the model can use for thinking, which must be set to a positive integer. The model will stop thinking if it reaches the thinking token budget and will proceed with the response\n   *\n   * @see https://docs.cohere.com/reference/chat#request.body.thinking\n   */\n  thinking: z\n    .object({\n      type: z.enum(['enabled', 'disabled']).optional(),\n      tokenBudget: z.number().optional(),\n    })\n    .optional(),\n});\n\nexport type CohereChatModelOptions = z.infer<typeof cohereChatModelOptions>;\n","import { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\n\nconst cohereErrorDataSchema = z.object({\n  message: z.string(),\n});\n\nexport type CohereErrorData = z.infer<typeof cohereErrorDataSchema>;\n\nexport const cohereFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: cohereErrorDataSchema,\n  errorToMessage: data => data.message,\n});\n","import {\n  LanguageModelV2CallWarning,\n  LanguageModelV2Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { CohereAssistantMessage, CohereChatPrompt } from './cohere-chat-prompt';\n\nexport function convertToCohereChatPrompt(prompt: LanguageModelV2Prompt): {\n  messages: CohereChatPrompt;\n  documents: Array<{\n    data: { text: string; title?: string };\n  }>;\n  warnings: LanguageModelV2CallWarning[];\n} {\n  const messages: CohereChatPrompt = [];\n  const documents: Array<{ data: { text: string; title?: string } }> = [];\n  const warnings: LanguageModelV2CallWarning[] = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        messages.push({ role: 'system', content });\n        break;\n      }\n\n      case 'user': {\n        messages.push({\n          role: 'user',\n          content: content\n            .map(part => {\n              switch (part.type) {\n                case 'text': {\n                  return part.text;\n                }\n                case 'file': {\n                  // Extract documents for RAG\n                  let textContent: string;\n\n                  if (typeof part.data === 'string') {\n                    // Base64 or text data\n                    textContent = part.data;\n                  } else if (part.data instanceof Uint8Array) {\n                    // Check if the media type is supported for text extraction\n                    if (\n                      !(\n                        part.mediaType?.startsWith('text/') ||\n                        part.mediaType === 'application/json'\n                      )\n                    ) {\n                      throw new UnsupportedFunctionalityError({\n                        functionality: `document media type: ${part.mediaType}`,\n                        message: `Media type '${part.mediaType}' is not supported. Supported media types are: text/* and application/json.`,\n                      });\n                    }\n                    textContent = new TextDecoder().decode(part.data);\n                  } else {\n                    throw new UnsupportedFunctionalityError({\n                      functionality: 'File URL data',\n                      message:\n                        'URLs should be downloaded by the AI SDK and not reach this point. This indicates a configuration issue.',\n                    });\n                  }\n\n                  documents.push({\n                    data: {\n                      text: textContent,\n                      title: part.filename,\n                    },\n                  });\n\n                  // Files are handled separately via the documents parameter\n                  // Return empty string to not include file content in message text\n                  return '';\n                }\n              }\n            })\n            .join(''),\n        });\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        const toolCalls: CohereAssistantMessage['tool_calls'] = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function' as const,\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.input),\n                },\n              });\n              break;\n            }\n          }\n        }\n\n        messages.push({\n          role: 'assistant',\n          content: toolCalls.length > 0 ? undefined : text,\n          tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n          tool_plan: undefined,\n        });\n\n        break;\n      }\n      case 'tool': {\n        messages.push(\n          ...content.map(toolResult => {\n            const output = toolResult.output;\n\n            let contentValue: string;\n            switch (output.type) {\n              case 'text':\n              case 'error-text':\n                contentValue = output.value;\n                break;\n              case 'content':\n              case 'json':\n              case 'error-json':\n                contentValue = JSON.stringify(output.value);\n                break;\n            }\n\n            return {\n              role: 'tool' as const,\n              content: contentValue,\n              tool_call_id: toolResult.toolCallId,\n            };\n          }),\n        );\n\n        break;\n      }\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { messages, documents, warnings };\n}\n","import { LanguageModelV2FinishReason } from '@ai-sdk/provider';\n\nexport function mapCohereFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV2FinishReason {\n  switch (finishReason) {\n    case 'COMPLETE':\n    case 'STOP_SEQUENCE':\n      return 'stop';\n\n    case 'MAX_TOKENS':\n      return 'length';\n\n    case 'ERROR':\n      return 'error';\n\n    case 'TOOL_CALL':\n      return 'tool-calls';\n\n    default:\n      return 'unknown';\n  }\n}\n","import {\n  LanguageModelV2CallOptions,\n  LanguageModelV2CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { CohereToolChoice } from './cohere-chat-prompt';\n\nexport function prepareTools({\n  tools,\n  toolChoice,\n}: {\n  tools: LanguageModelV2CallOptions['tools'];\n  toolChoice?: LanguageModelV2CallOptions['toolChoice'];\n}): {\n  tools:\n    | Array<{\n        type: 'function';\n        function: {\n          name: string | undefined;\n          description: string | undefined;\n          parameters: unknown;\n        };\n      }>\n    | undefined;\n  toolChoice: CohereToolChoice;\n  toolWarnings: LanguageModelV2CallWarning[];\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  tools = tools?.length ? tools : undefined;\n\n  const toolWarnings: LanguageModelV2CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, toolChoice: undefined, toolWarnings };\n  }\n\n  const cohereTools: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: unknown;\n    };\n  }> = [];\n\n  for (const tool of tools) {\n    if (tool.type === 'provider-defined') {\n      toolWarnings.push({ type: 'unsupported-tool', tool });\n    } else {\n      cohereTools.push({\n        type: 'function',\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.inputSchema,\n        },\n      });\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: cohereTools, toolChoice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n      return { tools: cohereTools, toolChoice: undefined, toolWarnings };\n\n    case 'none':\n      return { tools: cohereTools, toolChoice: 'NONE', toolWarnings };\n\n    case 'required':\n      return { tools: cohereTools, toolChoice: 'REQUIRED', toolWarnings };\n\n    case 'tool':\n      return {\n        tools: cohereTools.filter(\n          tool => tool.function.name === toolChoice.toolName,\n        ),\n        toolChoice: 'REQUIRED',\n        toolWarnings,\n      };\n\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import {\n  EmbeddingModelV2,\n  TooManyEmbeddingValuesForCallError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  FetchFunction,\n  parseProviderOptions,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport {\n  CohereEmbeddingModelId,\n  cohereEmbeddingOptions,\n} from './cohere-embedding-options';\nimport { cohereFailedResponseHandler } from './cohere-error';\n\ntype CohereEmbeddingConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  fetch?: FetchFunction;\n};\n\nexport class CohereEmbeddingModel implements EmbeddingModelV2<string> {\n  readonly specificationVersion = 'v2';\n  readonly modelId: CohereEmbeddingModelId;\n\n  readonly maxEmbeddingsPerCall = 96;\n  readonly supportsParallelCalls = true;\n\n  private readonly config: CohereEmbeddingConfig;\n\n  constructor(modelId: CohereEmbeddingModelId, config: CohereEmbeddingConfig) {\n    this.modelId = modelId;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n    providerOptions,\n  }: Parameters<EmbeddingModelV2<string>['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV2<string>['doEmbed']>>\n  > {\n    const embeddingOptions = await parseProviderOptions({\n      provider: 'cohere',\n      providerOptions,\n      schema: cohereEmbeddingOptions,\n    });\n\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values,\n      });\n    }\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue,\n    } = await postJsonToApi({\n      url: `${this.config.baseURL}/embed`,\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        // The AI SDK only supports 'float' embeddings which are also the only ones\n        // the Cohere API docs state are supported for all models.\n        // https://docs.cohere.com/v2/reference/embed#request.body.embedding_types\n        embedding_types: ['float'],\n        texts: values,\n        input_type: embeddingOptions?.inputType ?? 'search_query',\n        truncate: embeddingOptions?.truncate,\n      },\n      failedResponseHandler: cohereFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        cohereTextEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      embeddings: response.embeddings.float,\n      usage: { tokens: response.meta.billed_units.input_tokens },\n      response: { headers: responseHeaders, body: rawValue },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst cohereTextEmbeddingResponseSchema = z.object({\n  embeddings: z.object({\n    float: z.array(z.array(z.number())),\n  }),\n  meta: z.object({\n    billed_units: z.object({\n      input_tokens: z.number(),\n    }),\n  }),\n});\n","import { z } from 'zod/v4';\n\nexport type CohereEmbeddingModelId =\n  | 'embed-english-v3.0'\n  | 'embed-multilingual-v3.0'\n  | 'embed-english-light-v3.0'\n  | 'embed-multilingual-light-v3.0'\n  | 'embed-english-v2.0'\n  | 'embed-english-light-v2.0'\n  | 'embed-multilingual-v2.0'\n  | (string & {});\n\nexport const cohereEmbeddingOptions = z.object({\n  /**\n   * Specifies the type of input passed to the model. Default is `search_query`.\n   *\n   * - \"search_document\": Used for embeddings stored in a vector database for search use-cases.\n   * - \"search_query\": Used for embeddings of search queries run against a vector DB to find relevant documents.\n   * - \"classification\": Used for embeddings passed through a text classifier.\n   * - \"clustering\": Used for embeddings run through a clustering algorithm.\n   */\n  inputType: z\n    .enum(['search_document', 'search_query', 'classification', 'clustering'])\n    .optional(),\n\n  /**\n   * Specifies how the API will handle inputs longer than the maximum token length.\n   * Default is `END`.\n   *\n   * - \"NONE\": If selected, when the input exceeds the maximum input token length will return an error.\n   * - \"START\": Will discard the start of the input until the remaining input is exactly the maximum input token length for the model.\n   * - \"END\": Will discard the end of the input until the remaining input is exactly the maximum input token length for the model.\n   */\n  truncate: z.enum(['NONE', 'START', 'END']).optional(),\n});\n\nexport type CohereEmbeddingOptions = z.infer<typeof cohereEmbeddingOptions>;\n","// Version string of this package injected at build time.\ndeclare const __PACKAGE_VERSION__: string | undefined;\nexport const VERSION: string =\n  typeof __PACKAGE_VERSION__ !== 'undefined'\n    ? __PACKAGE_VERSION__\n    : '0.0.0-test';\n"],"mappings":"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","names":["generateId","z","z","UnsupportedFunctionalityError","z","combineHeaders","createJsonResponseHandler","parseProviderOptions","postJsonToApi","z","z","parseProviderOptions","postJsonToApi","combineHeaders","createJsonResponseHandler","z","_a","generateId"]}