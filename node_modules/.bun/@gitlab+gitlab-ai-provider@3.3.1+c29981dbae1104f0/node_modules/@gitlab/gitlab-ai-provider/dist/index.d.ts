import { LanguageModelV2, LanguageModelV2CallOptions, LanguageModelV2Content, LanguageModelV2FinishReason, LanguageModelV2Usage, LanguageModelV2CallWarning, LanguageModelV2StreamPart } from '@ai-sdk/provider';
import { z } from 'zod';

interface GitLabAnthropicConfig {
    provider: string;
    instanceUrl: string;
    getHeaders: () => Record<string, string>;
    fetch?: typeof fetch;
    /**
     * Optional callback to refresh the API key when a 401 error occurs.
     * Should clear cached credentials and re-fetch from auth provider.
     */
    refreshApiKey?: () => Promise<void>;
    /**
     * The Anthropic model to use (e.g., 'claude-sonnet-4-5-20250929')
     * @default 'claude-sonnet-4-5-20250929'
     */
    anthropicModel?: string;
    /**
     * Maximum tokens to generate
     * @default 8192
     */
    maxTokens?: number;
    /**
     * Feature flags to pass to the GitLab API
     * @default { DuoAgentPlatformNext: true }
     */
    featureFlags?: {
        DuoAgentPlatformNext: true;
    } & Record<string, boolean>;
    /**
     * AI Gateway URL for the Anthropic proxy.
     * Can also be set via GITLAB_AI_GATEWAY_URL environment variable.
     * @default 'https://cloud.gitlab.com'
     */
    aiGatewayUrl?: string;
}
/**
 * GitLab Anthropic Language Model
 *
 * This model uses GitLab's Anthropic proxy to provide native tool calling support
 * for the duo-chat model. It connects to Claude through GitLab's cloud proxy
 * at https://cloud.gitlab.com/ai/v1/proxy/anthropic/
 */
declare class GitLabAnthropicLanguageModel implements LanguageModelV2 {
    readonly specificationVersion: "v2";
    readonly modelId: string;
    readonly supportedUrls: Record<string, RegExp[]>;
    private readonly config;
    private readonly directAccessClient;
    private anthropicClient;
    constructor(modelId: string, config: GitLabAnthropicConfig);
    get provider(): string;
    /**
     * Get or create an Anthropic client with valid credentials
     * @param forceRefresh - If true, forces a token refresh before creating the client
     */
    private getAnthropicClient;
    /**
     * Check if an error is a token-related authentication error that can be retried
     */
    private isTokenError;
    /**
     * Convert AI SDK tools to Anthropic tool format
     */
    private convertTools;
    /**
     * Convert AI SDK tool choice to Anthropic format
     */
    private convertToolChoice;
    /**
     * Convert AI SDK prompt to Anthropic messages format
     */
    private convertPrompt;
    /**
     * Convert Anthropic finish reason to AI SDK format
     */
    private convertFinishReason;
    doGenerate(options: LanguageModelV2CallOptions): Promise<{
        content: LanguageModelV2Content[];
        finishReason: LanguageModelV2FinishReason;
        usage: LanguageModelV2Usage;
        warnings: LanguageModelV2CallWarning[];
    }>;
    private doGenerateWithRetry;
    doStream(options: LanguageModelV2CallOptions): Promise<{
        stream: ReadableStream<LanguageModelV2StreamPart>;
        request?: {
            body?: unknown;
        };
        response?: {
            headers?: Record<string, string>;
        };
    }>;
    private doStreamWithRetry;
}

interface GitLabProvider {
    (modelId: string): LanguageModelV2;
    readonly specificationVersion: 'v2';
    languageModel(modelId: string): LanguageModelV2;
    chat(modelId: string): LanguageModelV2;
    /**
     * Create an agentic chat model with tool calling support
     *
     * @param modelId - GitLab model identifier. Some IDs automatically map to specific Anthropic models.
     * @param options - Configuration options for the agentic model
     * @returns A language model with native tool calling support via Anthropic
     *
     * @example
     * // Automatic model mapping
     * const model = gitlab.agenticChat('duo-chat-opus-4-5');
     * // Uses claude-opus-4-5-20251101
     *
     * @example
     * // Explicit model override
     * const model = gitlab.agenticChat('duo-chat', {
     *   anthropicModel: 'claude-sonnet-4-5-20250929'
     * });
     */
    agenticChat(modelId: string, options?: GitLabAgenticOptions): GitLabAnthropicLanguageModel;
    textEmbeddingModel(modelId: string): never;
    imageModel(modelId: string): never;
}
interface GitLabAgenticOptions {
    /**
     * Override the provider-specific model (optional).
     * Must be a valid model for the detected provider.
     *
     * For Anthropic models:
     * - 'claude-opus-4-5-20251101'
     * - 'claude-sonnet-4-5-20250929'
     * - 'claude-haiku-4-5-20251001'
     *
     * For OpenAI models:
     * - 'gpt-5.1-2025-11-13'
     * - 'gpt-5-mini-2025-08-07'
     * - 'gpt-5-codex'
     * - 'gpt-5.2-codex'
     *
     * @example
     * // Override with explicit model
     * const model = gitlab.agenticChat('duo-chat-opus-4-5', {
     *   providerModel: 'claude-sonnet-4-5-20250929'
     * });
     */
    providerModel?: string;
    /**
     * Maximum tokens to generate
     * @default 8192
     */
    maxTokens?: number;
    /**
     * Feature flags to pass to the GitLab API
     */
    featureFlags?: Record<string, boolean>;
}
interface GitLabProviderSettings {
    /**
     * GitLab instance URL (e.g., 'https://gitlab.com')
     * @default 'https://gitlab.com'
     */
    instanceUrl?: string;
    /**
     * API token (Personal Access Token or OAuth access token)
     * Can also be set via GITLAB_TOKEN environment variable
     */
    apiKey?: string;
    /**
     * OAuth refresh token (optional, for OAuth flow)
     */
    refreshToken?: string;
    /**
     * OAuth client ID (required for OAuth flow)
     */
    clientId?: string;
    /**
     * OAuth redirect URI (required for OAuth flow)
     */
    redirectUri?: string;
    /**
     * Custom headers to include in requests
     */
    headers?: Record<string, string>;
    /**
     * Custom fetch implementation
     */
    fetch?: typeof fetch;
    /**
     * Provider name override
     */
    name?: string;
    /**
     * Default feature flags to pass to the GitLab API for all agentic chat models
     */
    featureFlags?: Record<string, boolean>;
    /**
     * AI Gateway URL for the Anthropic proxy.
     * Can also be set via GITLAB_AI_GATEWAY_URL environment variable.
     * @default 'https://cloud.gitlab.com'
     */
    aiGatewayUrl?: string;
}
declare function createGitLab(options?: GitLabProviderSettings): GitLabProvider;
/**
 * Default GitLab Duo provider instance
 *
 * @example
 * ```typescript
 * import { gitlab } from '@ai-sdk/gitlab';
 *
 * const model = gitlab('duo-chat');
 * ```
 */
declare const gitlab: GitLabProvider;

interface GitLabOpenAIConfig {
    provider: string;
    instanceUrl: string;
    getHeaders: () => Record<string, string>;
    fetch?: typeof fetch;
    refreshApiKey?: () => Promise<void>;
    openaiModel?: string;
    maxTokens?: number;
    featureFlags?: {
        DuoAgentPlatformNext: true;
    } & Record<string, boolean>;
    aiGatewayUrl?: string;
    /** Whether to use the Responses API instead of Chat Completions API */
    useResponsesApi?: boolean;
}
declare class GitLabOpenAILanguageModel implements LanguageModelV2 {
    readonly specificationVersion: "v2";
    readonly modelId: string;
    readonly supportedUrls: Record<string, RegExp[]>;
    private readonly config;
    private readonly directAccessClient;
    private readonly useResponsesApi;
    private openaiClient;
    constructor(modelId: string, config: GitLabOpenAIConfig);
    get provider(): string;
    private getOpenAIClient;
    private isTokenError;
    private convertTools;
    private convertToolChoice;
    private convertPrompt;
    private convertFinishReason;
    /**
     * Convert tools to Responses API format
     */
    private convertToolsForResponses;
    /**
     * Convert prompt to Responses API input format
     */
    private convertPromptForResponses;
    /**
     * Extract system instructions from prompt
     */
    private extractSystemInstructions;
    /**
     * Convert Responses API status to finish reason
     * Note: Responses API returns 'completed' even when making tool calls,
     * so we need to check the content for tool calls separately.
     */
    private convertResponsesStatus;
    doGenerate(options: LanguageModelV2CallOptions): Promise<{
        content: LanguageModelV2Content[];
        finishReason: LanguageModelV2FinishReason;
        usage: LanguageModelV2Usage;
        warnings: LanguageModelV2CallWarning[];
    }>;
    private doGenerateWithChatApi;
    private doGenerateWithResponsesApi;
    doStream(options: LanguageModelV2CallOptions): Promise<{
        stream: ReadableStream<LanguageModelV2StreamPart>;
        request?: {
            body?: unknown;
        };
        response?: {
            headers?: Record<string, string>;
        };
    }>;
    private doStreamWithChatApi;
    private doStreamWithResponsesApi;
}

type ModelProvider = 'anthropic' | 'openai';
type OpenAIApiType = 'chat' | 'responses';
interface ModelMapping {
    provider: ModelProvider;
    model: string;
    /** For OpenAI models, which API to use: 'chat' for /v1/chat/completions, 'responses' for /v1/responses */
    openaiApiType?: OpenAIApiType;
}
declare const MODEL_MAPPINGS: Record<string, ModelMapping>;
declare function getModelMapping(modelId: string): ModelMapping | undefined;
declare function getProviderForModelId(modelId: string): ModelProvider | undefined;
declare function getValidModelsForProvider(provider: ModelProvider): string[];
declare function getAnthropicModelForModelId(modelId: string): string | undefined;
declare function getOpenAIModelForModelId(modelId: string): string | undefined;
declare function getOpenAIApiType(modelId: string): OpenAIApiType;
declare function isResponsesApiModel(modelId: string): boolean;
declare const MODEL_ID_TO_ANTHROPIC_MODEL: Record<string, string>;

interface GitLabErrorOptions {
    message: string;
    statusCode?: number;
    responseBody?: string;
    cause?: unknown;
}
declare class GitLabError extends Error {
    readonly statusCode?: number;
    readonly responseBody?: string;
    readonly cause?: unknown;
    constructor(options: GitLabErrorOptions);
    static fromResponse(response: Response, body: string): GitLabError;
    isAuthError(): boolean;
    isRateLimitError(): boolean;
    isForbiddenError(): boolean;
    isServerError(): boolean;
}

declare const gitlabOAuthTokenResponseSchema: z.ZodObject<{
    access_token: z.ZodString;
    refresh_token: z.ZodOptional<z.ZodString>;
    expires_in: z.ZodNumber;
    created_at: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    created_at?: number;
    access_token?: string;
    refresh_token?: string;
    expires_in?: number;
}, {
    created_at?: number;
    access_token?: string;
    refresh_token?: string;
    expires_in?: number;
}>;
type GitLabOAuthTokenResponse = z.infer<typeof gitlabOAuthTokenResponseSchema>;

/**
 * OAuth types and constants for GitLab authentication
 * Based on gitlab-vscode-extension and gitlab-lsp patterns
 */
interface GitLabOAuthTokens {
    accessToken: string;
    refreshToken: string;
    expiresAt: number;
    instanceUrl: string;
}
interface OpenCodeAuthOAuth {
    type: 'oauth';
    refresh: string;
    access: string;
    expires: number;
    instanceUrl?: string;
}
interface OpenCodeAuthApi {
    type: 'api';
    key: string;
}
type OpenCodeAuth = OpenCodeAuthOAuth | OpenCodeAuthApi;
/**
 * Bundled OAuth client ID for GitLab.com
 * Same as used in gitlab-vscode-extension
 */
declare const BUNDLED_CLIENT_ID = "36f2a70cddeb5a0889d4fd8295c241b7e9848e89cf9e599d0eed2d8e5350fbf5";
/**
 * GitLab.com URL constant
 */
declare const GITLAB_COM_URL = "https://gitlab.com";
/**
 * Token expiry skew in milliseconds (5 minutes)
 * Refresh tokens this many milliseconds before they expire
 */
declare const TOKEN_EXPIRY_SKEW_MS: number;
/**
 * OAuth scopes to request
 */
declare const OAUTH_SCOPES: string[];

/**
 * GitLab OAuth Manager
 * Handles OAuth token management, refresh, and exchange
 * Based on gitlab-vscode-extension TokenExchangeService and gitlab-lsp OAuthClientProvider
 */

interface TokenExchangeParams {
    instanceUrl: string;
    clientId?: string;
    redirectUri?: string;
}
interface AuthorizationCodeParams extends TokenExchangeParams {
    code: string;
    codeVerifier: string;
}
interface RefreshTokenParams extends TokenExchangeParams {
    refreshToken: string;
}
declare class GitLabOAuthManager {
    private fetch;
    constructor(fetchImpl?: typeof fetch);
    /**
     * Check if a token is expired
     */
    isTokenExpired(expiresAt: number): boolean;
    /**
     * Check if a token needs refresh (within skew window)
     */
    needsRefresh(expiresAt: number): boolean;
    /**
     * Refresh tokens if needed
     * Returns the same tokens if refresh is not needed, or new tokens if refreshed
     */
    refreshIfNeeded(tokens: GitLabOAuthTokens, clientId?: string): Promise<GitLabOAuthTokens>;
    /**
     * Exchange authorization code for tokens
     * Based on gitlab-vscode-extension createOAuthAccountFromCode
     */
    exchangeAuthorizationCode(params: AuthorizationCodeParams): Promise<GitLabOAuthTokens>;
    /**
     * Exchange refresh token for new tokens
     * Based on gitlab-vscode-extension TokenExchangeService
     */
    exchangeRefreshToken(params: RefreshTokenParams): Promise<GitLabOAuthTokens>;
    /**
     * Get the OAuth client ID for an instance
     */
    private getClientId;
    /**
     * Exchange token with GitLab OAuth endpoint
     * Based on gitlab-vscode-extension GitLabService.exchangeToken
     */
    private exchangeToken;
    /**
     * Create GitLabOAuthTokens from token response
     */
    private createTokensFromResponse;
    /**
     * Create expiry timestamp from token response
     * Based on gitlab-vscode-extension createExpiresTimestamp
     */
    private createExpiresTimestamp;
}

/**
 * Simple in-memory cache for GitLab project information
 * Used to avoid repeated API calls when detecting projects from git remotes
 */
interface GitLabProject {
    id: number;
    path: string;
    pathWithNamespace: string;
    name: string;
    namespaceId?: number;
}
/**
 * In-memory cache for GitLab project information with TTL support
 */
declare class GitLabProjectCache {
    private cache;
    private defaultTTL;
    /**
     * Create a new project cache
     * @param defaultTTL - Default time-to-live in milliseconds (default: 5 minutes)
     */
    constructor(defaultTTL?: number);
    /**
     * Get a cached project by key
     * @param key - Cache key (typically the working directory path)
     * @returns The cached project or null if not found or expired
     */
    get(key: string): GitLabProject | null;
    /**
     * Store a project in the cache
     * @param key - Cache key (typically the working directory path)
     * @param project - The project to cache
     * @param ttl - Optional custom TTL in milliseconds
     */
    set(key: string, project: GitLabProject, ttl?: number): void;
    /**
     * Check if a key exists in the cache (and is not expired)
     * @param key - Cache key to check
     * @returns true if the key exists and is not expired
     */
    has(key: string): boolean;
    /**
     * Remove a specific entry from the cache
     * @param key - Cache key to remove
     */
    delete(key: string): void;
    /**
     * Clear all entries from the cache
     */
    clear(): void;
    /**
     * Get the number of entries in the cache (including expired ones)
     */
    get size(): number;
    /**
     * Clean up expired entries from the cache
     * This is useful for long-running processes to prevent memory leaks
     */
    cleanup(): void;
}

interface GitLabProjectDetectorConfig {
    instanceUrl: string;
    getHeaders: () => Record<string, string>;
    fetch?: typeof fetch;
    cache?: GitLabProjectCache;
    gitTimeout?: number;
}
/**
 * Detects GitLab project information from git remote URLs
 *
 * This class provides functionality to:
 * - Parse git remote URLs (SSH, HTTPS, custom domains)
 * - Execute git commands to get remote URLs
 * - Fetch project details from GitLab API
 * - Cache project information to avoid repeated API calls
 */
declare class GitLabProjectDetector {
    private readonly config;
    private readonly fetchFn;
    private readonly cache;
    constructor(config: GitLabProjectDetectorConfig);
    /**
     * Auto-detect GitLab project from git remote in the working directory
     *
     * @param workingDirectory - The directory to check for git remote
     * @param remoteName - The git remote name to use (default: 'origin')
     * @returns The detected project or null if detection fails
     */
    detectProject(workingDirectory: string, remoteName?: string): Promise<GitLabProject | null>;
    /**
     * Parse a git remote URL to extract the project path
     *
     * Supports:
     * - SSH: git@gitlab.com:namespace/project.git
     * - HTTPS: https://gitlab.com/namespace/project.git
     * - HTTP: http://gitlab.local/namespace/project.git
     * - Custom domains and ports
     *
     * @param remoteUrl - The git remote URL
     * @param instanceUrl - The GitLab instance URL to match against
     * @returns The project path (e.g., "namespace/project") or null if parsing fails
     */
    parseGitRemoteUrl(remoteUrl: string, instanceUrl: string): string | null;
    /**
     * Get the git remote URL from a working directory
     *
     * @param workingDirectory - The directory to check
     * @param remoteName - The git remote name (default: 'origin')
     * @returns The remote URL or null if not found
     */
    getGitRemoteUrl(workingDirectory: string, remoteName?: string): Promise<string | null>;
    /**
     * Fetch project details from GitLab API by project path
     *
     * @param projectPath - The project path (e.g., "namespace/project")
     * @returns The project details
     * @throws GitLabError if the API call fails
     */
    getProjectByPath(projectPath: string): Promise<GitLabProject>;
    /**
     * Clear the project cache
     */
    clearCache(): void;
    /**
     * Get the cache instance (useful for testing)
     */
    getCache(): GitLabProjectCache;
}

/**
 * Response from /api/v4/ai/third_party_agents/direct_access
 */
declare const directAccessTokenSchema: z.ZodObject<{
    headers: z.ZodRecord<z.ZodString, z.ZodString>;
    token: z.ZodString;
}, "strip", z.ZodTypeAny, {
    headers?: Record<string, string>;
    token?: string;
}, {
    headers?: Record<string, string>;
    token?: string;
}>;
type DirectAccessToken = z.infer<typeof directAccessTokenSchema>;
declare const DEFAULT_AI_GATEWAY_URL = "https://cloud.gitlab.com";
interface GitLabDirectAccessConfig {
    instanceUrl: string;
    getHeaders: () => Record<string, string>;
    fetch?: typeof fetch;
    /**
     * Optional callback to refresh the API key when a 401 error occurs.
     * Should clear cached credentials and re-fetch from auth provider.
     */
    refreshApiKey?: () => Promise<void>;
    /**
     * Feature flags to pass to the GitLab API
     */
    featureFlags?: Record<string, boolean>;
    /**
     * AI Gateway URL for the Anthropic proxy.
     * Can also be set via GITLAB_AI_GATEWAY_URL environment variable.
     * @default 'https://cloud.gitlab.com'
     */
    aiGatewayUrl?: string;
}
/**
 * Client for GitLab's third-party agents direct access API.
 * This allows routing requests through GitLab's proxy to Anthropic.
 */
declare class GitLabDirectAccessClient {
    private readonly config;
    private readonly fetchFn;
    private readonly aiGatewayUrl;
    private cachedToken;
    private tokenExpiresAt;
    constructor(config: GitLabDirectAccessConfig);
    /**
     * Get a direct access token for the Anthropic proxy.
     * Tokens are cached for 25 minutes (they expire after 30 minutes).
     * @param forceRefresh - If true, ignores the cache and fetches a new token
     */
    getDirectAccessToken(forceRefresh?: boolean): Promise<DirectAccessToken>;
    /**
     * Get the Anthropic proxy base URL
     */
    getAnthropicProxyUrl(): string;
    /**
     * Get the OpenAI proxy base URL
     * Note: The OpenAI SDK expects a base URL like https://api.openai.com/v1
     * and appends paths like /chat/completions. So we need /v1 at the end.
     */
    getOpenAIProxyUrl(): string;
    /**
     * Invalidate the cached token
     */
    invalidateToken(): void;
}

export { BUNDLED_CLIENT_ID, DEFAULT_AI_GATEWAY_URL, type DirectAccessToken, GITLAB_COM_URL, type GitLabAgenticOptions, type GitLabAnthropicConfig, GitLabAnthropicLanguageModel, GitLabDirectAccessClient, type GitLabDirectAccessConfig, GitLabError, type GitLabErrorOptions, GitLabOAuthManager, type GitLabOAuthTokenResponse, type GitLabOAuthTokens, type GitLabOpenAIConfig, GitLabOpenAILanguageModel, type GitLabProject, GitLabProjectCache, GitLabProjectDetector, type GitLabProjectDetectorConfig, type GitLabProvider, type GitLabProviderSettings, MODEL_ID_TO_ANTHROPIC_MODEL, MODEL_MAPPINGS, type ModelMapping, type ModelProvider, OAUTH_SCOPES, type OpenAIApiType, type OpenCodeAuth, type OpenCodeAuthApi, type OpenCodeAuthOAuth, TOKEN_EXPIRY_SKEW_MS, createGitLab, getAnthropicModelForModelId, getModelMapping, getOpenAIApiType, getOpenAIModelForModelId, getProviderForModelId, getValidModelsForProvider, gitlab, isResponsesApiModel };
