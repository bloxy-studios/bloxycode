
import { n as UserConfig, p as Context, r as Input, t as Config } from "./types-BcLsQaJ_.cjs";
import { Logger } from "@hey-api/codegen-core";
import { getResolvedInput } from "@hey-api/json-schema-ref-parser";

//#region src/config/resolve.d.ts
type ResolvedJob = {
  config: Config;
  errors: Array<Error>;
  index: number;
};
//#endregion
//#region src/config/init.d.ts
type Configs = {
  dependencies: Record<string, string>;
  jobs: ReadonlyArray<ResolvedJob>;
  /**
   * @deprecated Use `jobs` instead.
   */
  results: ReadonlyArray<ResolvedJob>;
};
/**
 * @internal
 */
declare function resolveJobs({
  logger,
  userConfigs
}: {
  logger: Logger;
  userConfigs: ReadonlyArray<UserConfig>;
}): Promise<Configs>;
//#endregion
//#region src/types/types.d.ts
interface WatchValues {
  /**
   * Headers to be sent with each HEAD and/or GET request. This effectively
   * serves as a mechanism resolver because setting certain headers will opt
   * into comparing the specifications using that method.
   */
  headers: Headers;
  /**
   * Can we send a HEAD request instead of fetching the whole specification?
   * This value will be set after the first successful fetch.
   */
  isHeadMethodSupported?: boolean;
  /**
   * String content of the last successfully fetched specification.
   */
  lastValue?: string;
}
//#endregion
//#region src/getSpec.d.ts
type SpecResponse = {
  arrayBuffer: ArrayBuffer | undefined;
  error?: never;
  resolvedInput: ReturnType<typeof getResolvedInput>;
  response?: never;
};
type SpecError = {
  arrayBuffer?: never;
  error: 'not-modified' | 'not-ok';
  resolvedInput?: never;
  response: Response;
};
/**
 * @internal
 */
declare const getSpec: ({
  fetchOptions,
  inputPath,
  timeout,
  watch
}: {
  fetchOptions?: RequestInit;
  inputPath: Input["path"];
  timeout: number | undefined;
  watch: WatchValues;
}) => Promise<SpecResponse | SpecError>;
//#endregion
//#region src/openApi/index.d.ts
/**
 * @internal
 * Parse the resolved OpenAPI specification. This will populate and return
 * `context` with intermediate representation obtained from the parsed spec.
 */
declare const parseOpenApiSpec: ({
  config,
  dependencies,
  logger,
  spec
}: {
  config: Config;
  dependencies: Record<string, string>;
  logger: Logger;
  spec: unknown;
}) => Context;
//#endregion
export { getSpec, resolveJobs as initConfigs, parseOpenApiSpec };
//# sourceMappingURL=internal.d.cts.map