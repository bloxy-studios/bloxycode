
//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let _hey_api_codegen_core = require("@hey-api/codegen-core");
let ansi_colors = require("ansi-colors");
ansi_colors = __toESM(ansi_colors);
let node_fs = require("node:fs");
node_fs = __toESM(node_fs);
let node_path = require("node:path");
node_path = __toESM(node_path);
let node_url = require("node:url");
let typescript = require("typescript");
typescript = __toESM(typescript);
let node_os = require("node:os");
let semver = require("semver");
semver = __toESM(semver);
let _hey_api_json_schema_ref_parser = require("@hey-api/json-schema-ref-parser");

//#region src/generate/tsConfig.ts
const __filename$2 = (0, node_url.fileURLToPath)(require("url").pathToFileURL(__filename).href);
const __dirname$2 = node_path.default.dirname(__filename$2);
const findPackageJson = () => {
	let dir = __dirname$2;
	while (dir !== node_path.default.dirname(dir)) {
		const candidates = node_fs.default.readdirSync(dir).filter((file) => file === "package.json");
		if (candidates[0]) {
			const packageJsonPath = node_path.default.join(dir, candidates[0]);
			return JSON.parse(node_fs.default.readFileSync(packageJsonPath, { encoding: "utf8" }));
		}
		dir = node_path.default.dirname(dir);
	}
};
const loadPackageJson = () => {
	const packageJson = findPackageJson();
	const safePackage = {
		bugs: { url: "" },
		name: "",
		version: ""
	};
	if (packageJson && typeof packageJson === "object") {
		if ("name" in packageJson && typeof packageJson.name === "string") safePackage.name = packageJson.name;
		if ("version" in packageJson && typeof packageJson.version === "string") safePackage.version = packageJson.version;
		if ("bugs" in packageJson && packageJson.bugs && typeof packageJson.bugs === "object") {
			if ("url" in packageJson.bugs && typeof packageJson.bugs.url === "string") {
				safePackage.bugs.url = packageJson.bugs.url;
				if (safePackage.bugs.url && !safePackage.bugs.url.endsWith("/")) safePackage.bugs.url += "/";
			}
		}
	}
	return safePackage;
};
const findTsConfigPath = (tsConfigPath) => {
	if (tsConfigPath === null) return null;
	if (tsConfigPath) {
		const resolved = node_path.default.isAbsolute(tsConfigPath) ? tsConfigPath : node_path.default.resolve(__dirname$2, tsConfigPath);
		return node_fs.default.existsSync(resolved) ? resolved : null;
	}
	let dir = __dirname$2;
	while (dir !== node_path.default.dirname(dir)) {
		const candidates = node_fs.default.readdirSync(dir).filter((file) => file.startsWith("tsconfig") && file.endsWith(".json")).sort((file) => file === "tsconfig.json" ? -1 : 1);
		if (candidates[0]) return node_path.default.join(dir, candidates[0]);
		dir = node_path.default.dirname(dir);
	}
	return null;
};
const loadTsConfig = (configPath) => {
	if (!configPath) return null;
	const raw = typescript.default.readConfigFile(configPath, typescript.default.sys.readFile);
	if (raw.error) throw new Error(`Couldn't read tsconfig from path: ${configPath}`);
	return typescript.default.parseJsonConfigFileContent(raw.config, typescript.default.sys, node_path.default.dirname(configPath));
};

//#endregion
//#region src/generate/utils.ts
const ensureDirSync = (path$10) => {
	if (!node_fs.default.existsSync(path$10)) node_fs.default.mkdirSync(path$10, { recursive: true });
};

//#endregion
//#region src/error.ts
/**
* Represents a single configuration error.
*
* Used for reporting issues with a specific config instance.
*/
var ConfigError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "ConfigError";
	}
};
/**
* Aggregates multiple config errors with their job indices for reporting.
*/
var ConfigValidationError = class extends Error {
	errors;
	constructor(errors) {
		super(`Found ${errors.length} configuration ${errors.length === 1 ? "error" : "errors"}.`);
		this.name = "ConfigValidationError";
		this.errors = errors;
	}
};
/**
* Represents a runtime error originating from a specific job.
*
* Used for reporting job-level failures that are not config validation errors.
*/
var JobError = class extends Error {
	originalError;
	constructor(message, error) {
		super(message);
		this.name = "JobError";
		this.originalError = error;
	}
};
var HeyApiError = class extends Error {
	args;
	event;
	pluginName;
	constructor({ args, error, event, name, pluginName }) {
		const message = error instanceof Error ? error.message : "Unknown error";
		super(message);
		this.args = args;
		this.cause = error.cause;
		this.event = event;
		this.name = name || error.name;
		this.pluginName = pluginName;
		this.stack = error.stack;
	}
};
const logCrashReport = (error, logsDir) => {
	if (error instanceof ConfigError || error instanceof ConfigValidationError) return;
	if (error instanceof JobError) error = error.originalError.error;
	const logName = `openapi-ts-error-${Date.now()}.log`;
	const fullDir = node_path.default.resolve(process.cwd(), logsDir);
	ensureDirSync(fullDir);
	const logPath = node_path.default.resolve(fullDir, logName);
	let logContent = `[${(/* @__PURE__ */ new Date()).toISOString()}] `;
	if (error instanceof HeyApiError) {
		logContent += `${error.name} during event "${error.event}"\n`;
		if (error.pluginName) logContent += `Plugin: ${error.pluginName}\n`;
		logContent += `Arguments: ${JSON.stringify(error.args, null, 2)}\n\n`;
	}
	const message = error instanceof Error ? error.message : String(error);
	const stack = error instanceof Error ? error.stack : void 0;
	logContent += `Error: ${message}\n`;
	if (stack) logContent += `Stack:\n${stack}\n`;
	node_fs.default.writeFileSync(logPath, logContent);
	return logPath;
};
const openGitHubIssueWithCrashReport = async (error) => {
	const packageJson = loadPackageJson();
	if (!packageJson.bugs.url) return;
	if (error instanceof JobError) error = error.originalError.error;
	let body = "";
	if (error instanceof HeyApiError) {
		if (error.pluginName) body += `**Plugin**: \`${error.pluginName}\`\n`;
		body += `**Event**: \`${error.event}\`\n`;
		body += `**Arguments**:\n\`\`\`ts\n${JSON.stringify(error.args, null, 2)}\n\`\`\`\n\n`;
	}
	const message = error instanceof Error ? error.message : String(error);
	const stack = error instanceof Error ? error.stack : void 0;
	body += `**Error**: \`${message}\`\n`;
	if (stack) body += `\n**Stack Trace**:\n\`\`\`\n${stack}\n\`\`\``;
	const search = new URLSearchParams({
		body,
		labels: "bug ðŸ”¥",
		title: "Crash Report"
	});
	const url = `${packageJson.bugs.url}new?${search.toString()}`;
	const open = (await import("open")).default;
	await open(url);
};
const printCrashReport = ({ error, logPath }) => {
	if (error instanceof ConfigValidationError && error.errors.length) {
		const groupByJob = /* @__PURE__ */ new Map();
		for (const { error: err, jobIndex } of error.errors) {
			if (!groupByJob.has(jobIndex)) groupByJob.set(jobIndex, []);
			groupByJob.get(jobIndex).push(err);
		}
		for (const [jobIndex, errors] of groupByJob.entries()) {
			const jobPrefix = ansi_colors.default.gray(`[Job ${jobIndex + 1}] `);
			const count = errors.length;
			const baseString = ansi_colors.default.red(`Found ${count} configuration ${count === 1 ? "error" : "errors"}:`);
			console.error(`${jobPrefix}â—ï¸ ${baseString}`);
			errors.forEach((err, index) => {
				const itemPrefixStr = `  [${index + 1}] `;
				const itemPrefix = ansi_colors.default.red(itemPrefixStr);
				console.error(`${jobPrefix}${itemPrefix}${ansi_colors.default.white(err.message)}`);
			});
		}
	} else {
		let jobPrefix = ansi_colors.default.gray("[root] ");
		if (error instanceof JobError) {
			jobPrefix = ansi_colors.default.gray(`[Job ${error.originalError.jobIndex + 1}] `);
			error = error.originalError.error;
		}
		const baseString = ansi_colors.default.red("Failed with the message:");
		console.error(`${jobPrefix}âŒ ${baseString}`);
		const itemPrefix = ansi_colors.default.red(`  `);
		console.error(`${jobPrefix}${itemPrefix}${typeof error === "string" ? error : error instanceof Error ? error.message : "Unknown error"}`);
	}
	if (logPath) {
		const jobPrefix = ansi_colors.default.gray("[root] ");
		console.error(`${jobPrefix}${ansi_colors.default.cyan("ðŸ“„ Crash log saved to:")} ${ansi_colors.default.gray(logPath)}`);
	}
};
const shouldReportCrash = async ({ error, isInteractive }) => {
	if (!isInteractive || error instanceof ConfigError || error instanceof ConfigValidationError) return false;
	return new Promise((resolve) => {
		const jobPrefix = ansi_colors.default.gray("[root] ");
		console.log(`${jobPrefix}${ansi_colors.default.yellow("ðŸ“¢ Open a GitHub issue with crash details? (y/N):")}`);
		process.stdin.setEncoding("utf8");
		process.stdin.once("data", (data) => {
			resolve(data.trim().toLowerCase() === "y");
		});
	});
};

//#endregion
//#region src/utils/input/heyApi.ts
const registryRegExp$2 = /^([\w-]+)\/([\w-]+)(?:\?([\w=&.-]*))?$/;
const heyApiRegistryBaseUrl = "https://get.heyapi.dev";
/**
* Creates a full Hey API Registry URL.
*
* @param organization - Hey API organization slug
* @param project - Hey API project slug
* @param queryParams - Optional query parameters
* @returns The full Hey API registry URL.
*/
const getRegistryUrl$2 = (organization, project, queryParams) => `${heyApiRegistryBaseUrl}/${organization}/${project}${queryParams ? `?${queryParams}` : ""}`;
/**
* Parses a Hey API input string and extracts components.
*
* @param input - Hey API configuration input
* @returns Parsed Hey API input components
* @throws Error if the input format is invalid
*/
const parseShorthand$2 = (input) => {
	let organization = input.organization;
	let project = input.project;
	let queryParams;
	if (input.path) {
		const match = input.path.match(registryRegExp$2);
		if (!match) throw new Error(`Invalid Hey API shorthand format. Expected "organization/project?queryParams" or "organization/project", received: ${input.path}`);
		organization = match[1];
		project = match[2];
		queryParams = match[3];
	}
	if (!organization) throw new Error("The Hey API organization cannot be empty.");
	if (!project) throw new Error("The Hey API project cannot be empty.");
	return {
		organization,
		project,
		queryParams
	};
};
/**
* Transforms a Hey API shorthand string to the corresponding API URL.
*
* @param input - Hey API configuration input
* @returns The Hey API Registry URL
*/
const inputToHeyApiPath = (input) => {
	const parsed = parseShorthand$2(input);
	return {
		path: getRegistryUrl$2(parsed.organization, parsed.project, parsed.queryParams),
		registry: "hey-api"
	};
};

//#endregion
//#region src/utils/input/readme.ts
const registryRegExp$1 = /^(@([\w-]+)\/([\w\-.]+)#)?([\w-]+)$/;
/**
* Creates a full ReadMe API Registry URL.
*
* @param uuid - ReadMe UUID
* @returns The full ReadMe API registry URL.
*/
const getRegistryUrl$1 = (uuid) => `https://dash.readme.com/api/v1/api-registry/${uuid}`;
const namespace$1 = "readme";
/**
* Parses a ReadMe input string and extracts components.
*
* @param shorthand - ReadMe format string (@org/project#uuid or uuid)
* @returns Parsed ReadMe input components
* @throws Error if the input format is invalid
*/
const parseShorthand$1 = (shorthand) => {
	const match = shorthand.match(registryRegExp$1);
	if (!match) throw new Error(`Invalid ReadMe shorthand format. Expected "${namespace$1}:@organization/project#uuid" or "${namespace$1}:uuid", received: ${namespace$1}:${shorthand}`);
	const [, , organization, project, uuid] = match;
	if (!uuid) throw new Error("The ReadMe UUID cannot be empty.");
	return {
		organization,
		project,
		uuid
	};
};
/**
* Transforms a ReadMe shorthand string to the corresponding API URL.
*
* @param input - ReadMe format string
* @returns The ReadMe API Registry URL
*/
const inputToReadmePath = (input) => {
	const parsed = parseShorthand$1(input.slice(`${namespace$1}:`.length));
	return {
		...parsed,
		path: getRegistryUrl$1(parsed.uuid),
		registry: "readme"
	};
};

//#endregion
//#region src/utils/input/scalar.ts
const registryRegExp = /^(@[\w-]+)\/([\w.-]+)$/;
/**
* Creates a full Scalar API Registry URL.
*
* @param organization - Scalar organization slug
* @param project - Scalar project slug
* @returns The full Scalar API registry URL.
*/
const getRegistryUrl = (organization, project) => `https://registry.scalar.com/${organization}/apis/${project}/latest?format=json`;
const namespace = "scalar";
/**
* Parses a Scalar input string and extracts components.
*
* @param shorthand - Scalar format string (@org/project)
* @returns Parsed Scalar input components
* @throws Error if the input format is invalid
*/
const parseShorthand = (shorthand) => {
	const match = shorthand.match(registryRegExp);
	if (!match) throw new Error(`Invalid Scalar shorthand format. Expected "${namespace}:@organization/project", received: ${namespace}:${shorthand}`);
	const [, organization, project] = match;
	if (!organization) throw new Error("The Scalar organization cannot be empty.");
	if (!project) throw new Error("The Scalar project cannot be empty.");
	return {
		organization,
		project
	};
};
/**
* Transforms a Scalar shorthand string to the corresponding API URL.
*
* @param input - Scalar format string
* @returns The Scalar API Registry URL
*/
const inputToScalarPath = (input) => {
	const parsed = parseShorthand(input.slice(`${namespace}:`.length));
	return {
		...parsed,
		path: getRegistryUrl(parsed.organization, parsed.project),
		registry: "scalar"
	};
};

//#endregion
//#region src/utils/input/index.ts
const inputToApiRegistry = (input) => {
	if (input.path.startsWith("readme:")) {
		Object.assign(input, inputToReadmePath(input.path));
		return;
	}
	if (input.path.startsWith("scalar:")) {
		Object.assign(input, inputToScalarPath(input.path));
		return;
	}
	if (input.path.startsWith(".")) return;
	if (input.path.startsWith(heyApiRegistryBaseUrl)) {
		input.path = input.path.slice(heyApiRegistryBaseUrl.length + 1);
		Object.assign(input, inputToHeyApiPath(input));
		return;
	}
	const parts = input.path.split("/");
	if (parts.length === 2 && parts.filter(Boolean).length === 2) {
		Object.assign(input, inputToHeyApiPath(input));
		return;
	}
};

//#endregion
//#region src/config/input.ts
const defaultWatch = {
	enabled: false,
	interval: 1e3,
	timeout: 6e4
};
const getWatch = (input) => {
	let watch = { ...defaultWatch };
	if (typeof input.path !== "string") return watch;
	if (typeof input.watch === "boolean") watch.enabled = input.watch;
	else if (typeof input.watch === "number") {
		watch.enabled = true;
		watch.interval = input.watch;
	} else if (input.watch) watch = {
		...watch,
		...input.watch
	};
	return watch;
};
const getInput = (userConfig) => {
	const userInputs = userConfig.input instanceof Array ? userConfig.input : [userConfig.input];
	const inputs = [];
	for (const userInput of userInputs) {
		let input = {
			path: "",
			watch: defaultWatch
		};
		if (typeof userInput === "string") input.path = userInput;
		else if (userInput && (userInput.path !== void 0 || userInput.organization !== void 0)) {
			input = {
				...input,
				path: heyApiRegistryBaseUrl,
				...userInput
			};
			if (input.watch !== void 0) input.watch = getWatch(input);
		} else input = {
			...input,
			path: userInput
		};
		if (typeof input.path === "string") inputToApiRegistry(input);
		if (userConfig.watch !== void 0 && input.watch.enabled === defaultWatch.enabled && input.watch.interval === defaultWatch.interval && input.watch.timeout === defaultWatch.timeout) input.watch = getWatch({
			path: input.path,
			watch: userConfig.watch
		});
		if (input.path) inputs.push(input);
	}
	return inputs;
};

//#endregion
//#region src/config/expand.ts
function expandToJobs(configs) {
	const jobs = [];
	let jobIndex = 0;
	for (const config of configs) {
		const inputs = getInput(config);
		const outputs = config.output instanceof Array ? config.output : [config.output];
		if (outputs.length === 1) jobs.push({
			config: {
				...config,
				input: inputs,
				output: outputs[0]
			},
			index: jobIndex++
		});
		else if (outputs.length > 1 && inputs.length !== outputs.length) {
			console.warn(`âš™ï¸ ${ansi_colors.default.yellow("Warning:")} You provided ${ansi_colors.default.cyan(String(inputs.length))} ${ansi_colors.default.cyan(inputs.length === 1 ? "input" : "inputs")} and ${ansi_colors.default.yellow(String(outputs.length))} ${ansi_colors.default.yellow("outputs")}. This will produce identical output in multiple locations. You likely want to provide a single output or the same number of outputs as inputs.`);
			for (const output of outputs) jobs.push({
				config: {
					...config,
					input: inputs,
					output
				},
				index: jobIndex++
			});
		} else if (outputs.length > 1) outputs.forEach((output, index) => {
			jobs.push({
				config: {
					...config,
					input: inputs[index],
					output
				},
				index: jobIndex++
			});
		});
	}
	return jobs;
}

//#endregion
//#region src/config/packages.ts
/**
* Finds and reads the project's package.json file by searching upwards from the config file location,
* or from process.cwd() if no config file is provided.
* This ensures we get the correct dependencies even in monorepo setups.
*
* @param configFilePath - The path to the configuration file (e.g., openapi-ts.config.ts)
* @returns An object containing all project dependencies (dependencies, devDependencies, peerDependencies, optionalDependencies)
*/
const getProjectDependencies = (configFilePath) => {
	let currentDir = configFilePath ? node_path.default.dirname(configFilePath) : process.cwd();
	while (currentDir !== node_path.default.dirname(currentDir)) {
		const packageJsonPath = node_path.default.join(currentDir, "package.json");
		if (node_fs.default.existsSync(packageJsonPath)) try {
			const packageJson = JSON.parse(node_fs.default.readFileSync(packageJsonPath, "utf8"));
			return {
				...packageJson.dependencies,
				...packageJson.devDependencies,
				...packageJson.peerDependencies,
				...packageJson.optionalDependencies
			};
		} catch {}
		const parentDir = node_path.default.dirname(currentDir);
		if (parentDir === currentDir) break;
		currentDir = parentDir;
	}
	return {};
};

//#endregion
//#region src/config/logs.ts
const getLogs = (userConfig) => {
	let logs = {
		file: true,
		level: "info",
		path: process.cwd()
	};
	if (typeof userConfig?.logs === "string") logs.path = userConfig.logs;
	else logs = {
		...logs,
		...userConfig?.logs
	};
	return logs;
};

//#endregion
//#region src/config/utils/config.ts
const isPlainObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) && typeof value !== "function";
const mergeResult = (result, mapped) => {
	for (const [key, value] of Object.entries(mapped)) if (value !== void 0 && value !== "") result[key] = value;
	return result;
};
const valueToObject = ({ defaultValue, mappers: mappers$1, value }) => {
	let result = { ...defaultValue };
	switch (typeof value) {
		case "boolean":
			if (mappers$1 && "boolean" in mappers$1) {
				const mapper = mappers$1.boolean;
				result = mergeResult(result, mapper(value));
			}
			break;
		case "function":
			if (mappers$1 && "function" in mappers$1) {
				const mapper = mappers$1.function;
				result = mergeResult(result, mapper(value));
			}
			break;
		case "number":
			if (mappers$1 && "number" in mappers$1) {
				const mapper = mappers$1.number;
				result = mergeResult(result, mapper(value));
			}
			break;
		case "string":
			if (mappers$1 && "string" in mappers$1) {
				const mapper = mappers$1.string;
				result = mergeResult(result, mapper(value));
			}
			break;
		case "object":
			if (isPlainObject(value)) if (mappers$1 && "object" in mappers$1 && typeof mappers$1.object === "function") {
				const mapper = mappers$1.object;
				result = mergeResult(result, mapper(value, defaultValue));
			} else result = mergeResult(result, value);
			break;
	}
	return result;
};

//#endregion
//#region ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = isexe;
	isexe.sync = sync;
	var fs$3 = require("fs");
	function checkPathExt(path$10, options) {
		var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
		if (!pathext) return true;
		pathext = pathext.split(";");
		if (pathext.indexOf("") !== -1) return true;
		for (var i = 0; i < pathext.length; i++) {
			var p = pathext[i].toLowerCase();
			if (p && path$10.substr(-p.length).toLowerCase() === p) return true;
		}
		return false;
	}
	function checkStat(stat, path$10, options) {
		if (!stat.isSymbolicLink() && !stat.isFile()) return false;
		return checkPathExt(path$10, options);
	}
	function isexe(path$10, options, cb) {
		fs$3.stat(path$10, function(er, stat) {
			cb(er, er ? false : checkStat(stat, path$10, options));
		});
	}
	function sync(path$10, options) {
		return checkStat(fs$3.statSync(path$10), path$10, options);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = isexe;
	isexe.sync = sync;
	var fs$2 = require("fs");
	function isexe(path$10, options, cb) {
		fs$2.stat(path$10, function(er, stat) {
			cb(er, er ? false : checkStat(stat, options));
		});
	}
	function sync(path$10, options) {
		return checkStat(fs$2.statSync(path$10), options);
	}
	function checkStat(stat, options) {
		return stat.isFile() && checkMode(stat, options);
	}
	function checkMode(stat, options) {
		var mod = stat.mode;
		var uid = stat.uid;
		var gid = stat.gid;
		var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
		var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
		var u = parseInt("100", 8);
		var g = parseInt("010", 8);
		var o = parseInt("001", 8);
		var ug = u | g;
		return mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	require("fs");
	var core;
	if (process.platform === "win32" || global.TESTING_WINDOWS) core = require_windows();
	else core = require_mode();
	module.exports = isexe;
	isexe.sync = sync;
	function isexe(path$10, options, cb) {
		if (typeof options === "function") {
			cb = options;
			options = {};
		}
		if (!cb) {
			if (typeof Promise !== "function") throw new TypeError("callback not provided");
			return new Promise(function(resolve, reject) {
				isexe(path$10, options || {}, function(er, is) {
					if (er) reject(er);
					else resolve(is);
				});
			});
		}
		core(path$10, options || {}, function(er, is) {
			if (er) {
				if (er.code === "EACCES" || options && options.ignoreErrors) {
					er = null;
					is = false;
				}
			}
			cb(er, is);
		});
	}
	function sync(path$10, options) {
		try {
			return core.sync(path$10, options || {});
		} catch (er) {
			if (options && options.ignoreErrors || er.code === "EACCES") return false;
			else throw er;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
	const path$6 = require("path");
	const COLON = isWindows ? ";" : ":";
	const isexe = require_isexe();
	const getNotFoundError = (cmd) => Object.assign(/* @__PURE__ */ new Error(`not found: ${cmd}`), { code: "ENOENT" });
	const getPathInfo = (cmd, opt) => {
		const colon = opt.colon || COLON;
		const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [...isWindows ? [process.cwd()] : [], ...(opt.path || process.env.PATH || "").split(colon)];
		const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
		const pathExt = isWindows ? pathExtExe.split(colon) : [""];
		if (isWindows) {
			if (cmd.indexOf(".") !== -1 && pathExt[0] !== "") pathExt.unshift("");
		}
		return {
			pathEnv,
			pathExt,
			pathExtExe
		};
	};
	const which = (cmd, opt, cb) => {
		if (typeof opt === "function") {
			cb = opt;
			opt = {};
		}
		if (!opt) opt = {};
		const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
		const found = [];
		const step = (i) => new Promise((resolve, reject) => {
			if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
			const ppRaw = pathEnv[i];
			const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
			const pCmd = path$6.join(pathPart, cmd);
			resolve(subStep(!pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd, i, 0));
		});
		const subStep = (p, i, ii) => new Promise((resolve, reject) => {
			if (ii === pathExt.length) return resolve(step(i + 1));
			const ext = pathExt[ii];
			isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
				if (!er && is) if (opt.all) found.push(p + ext);
				else return resolve(p + ext);
				return resolve(subStep(p, i, ii + 1));
			});
		});
		return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
	};
	const whichSync = (cmd, opt) => {
		opt = opt || {};
		const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
		const found = [];
		for (let i = 0; i < pathEnv.length; i++) {
			const ppRaw = pathEnv[i];
			const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
			const pCmd = path$6.join(pathPart, cmd);
			const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
			for (let j = 0; j < pathExt.length; j++) {
				const cur = p + pathExt[j];
				try {
					if (isexe.sync(cur, { pathExt: pathExtExe })) if (opt.all) found.push(cur);
					else return cur;
				} catch (ex) {}
			}
		}
		if (opt.all && found.length) return found;
		if (opt.nothrow) return null;
		throw getNotFoundError(cmd);
	};
	module.exports = which;
	which.sync = whichSync;
}));

//#endregion
//#region ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const pathKey = (options = {}) => {
		const environment = options.env || process.env;
		if ((options.platform || process.platform) !== "win32") return "PATH";
		return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
	};
	module.exports = pathKey;
	module.exports.default = pathKey;
}));

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const path$5 = require("path");
	const which = require_which();
	const getPathKey = require_path_key();
	function resolveCommandAttempt(parsed, withoutPathExt) {
		const env = parsed.options.env || process.env;
		const cwd = process.cwd();
		const hasCustomCwd = parsed.options.cwd != null;
		const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
		if (shouldSwitchCwd) try {
			process.chdir(parsed.options.cwd);
		} catch (err) {}
		let resolved;
		try {
			resolved = which.sync(parsed.command, {
				path: env[getPathKey({ env })],
				pathExt: withoutPathExt ? path$5.delimiter : void 0
			});
		} catch (e) {} finally {
			if (shouldSwitchCwd) process.chdir(cwd);
		}
		if (resolved) resolved = path$5.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
		return resolved;
	}
	function resolveCommand(parsed) {
		return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
	}
	module.exports = resolveCommand;
}));

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js
var require_escape = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
	function escapeCommand(arg) {
		arg = arg.replace(metaCharsRegExp, "^$1");
		return arg;
	}
	function escapeArgument(arg, doubleEscapeMetaChars) {
		arg = `${arg}`;
		arg = arg.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
		arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
		arg = `"${arg}"`;
		arg = arg.replace(metaCharsRegExp, "^$1");
		if (doubleEscapeMetaChars) arg = arg.replace(metaCharsRegExp, "^$1");
		return arg;
	}
	module.exports.command = escapeCommand;
	module.exports.argument = escapeArgument;
}));

//#endregion
//#region ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = /^#!(.*)/;
}));

//#endregion
//#region ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const shebangRegex = require_shebang_regex();
	module.exports = (string = "") => {
		const match = string.match(shebangRegex);
		if (!match) return null;
		const [path$10, argument] = match[0].replace(/#! ?/, "").split(" ");
		const binary = path$10.split("/").pop();
		if (binary === "env") return argument;
		return argument ? `${binary} ${argument}` : binary;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const fs$1 = require("fs");
	const shebangCommand = require_shebang_command();
	function readShebang(command) {
		const size = 150;
		const buffer = Buffer.alloc(size);
		let fd;
		try {
			fd = fs$1.openSync(command, "r");
			fs$1.readSync(fd, buffer, 0, size, 0);
			fs$1.closeSync(fd);
		} catch (e) {}
		return shebangCommand(buffer.toString());
	}
	module.exports = readShebang;
}));

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const path$4 = require("path");
	const resolveCommand = require_resolveCommand();
	const escape = require_escape();
	const readShebang = require_readShebang();
	const isWin = process.platform === "win32";
	const isExecutableRegExp = /\.(?:com|exe)$/i;
	const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
	function detectShebang(parsed) {
		parsed.file = resolveCommand(parsed);
		const shebang = parsed.file && readShebang(parsed.file);
		if (shebang) {
			parsed.args.unshift(parsed.file);
			parsed.command = shebang;
			return resolveCommand(parsed);
		}
		return parsed.file;
	}
	function parseNonShell(parsed) {
		if (!isWin) return parsed;
		const commandFile = detectShebang(parsed);
		const needsShell = !isExecutableRegExp.test(commandFile);
		if (parsed.options.forceShell || needsShell) {
			const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
			parsed.command = path$4.normalize(parsed.command);
			parsed.command = escape.command(parsed.command);
			parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
			parsed.args = [
				"/d",
				"/s",
				"/c",
				`"${[parsed.command].concat(parsed.args).join(" ")}"`
			];
			parsed.command = process.env.comspec || "cmd.exe";
			parsed.options.windowsVerbatimArguments = true;
		}
		return parsed;
	}
	function parse(command, args, options) {
		if (args && !Array.isArray(args)) {
			options = args;
			args = null;
		}
		args = args ? args.slice(0) : [];
		options = Object.assign({}, options);
		const parsed = {
			command,
			args,
			options,
			file: void 0,
			original: {
				command,
				args
			}
		};
		return options.shell ? parsed : parseNonShell(parsed);
	}
	module.exports = parse;
}));

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js
var require_enoent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const isWin = process.platform === "win32";
	function notFoundError(original, syscall) {
		return Object.assign(/* @__PURE__ */ new Error(`${syscall} ${original.command} ENOENT`), {
			code: "ENOENT",
			errno: "ENOENT",
			syscall: `${syscall} ${original.command}`,
			path: original.command,
			spawnargs: original.args
		});
	}
	function hookChildProcess(cp$1, parsed) {
		if (!isWin) return;
		const originalEmit = cp$1.emit;
		cp$1.emit = function(name, arg1) {
			if (name === "exit") {
				const err = verifyENOENT(arg1, parsed);
				if (err) return originalEmit.call(cp$1, "error", err);
			}
			return originalEmit.apply(cp$1, arguments);
		};
	}
	function verifyENOENT(status, parsed) {
		if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, "spawn");
		return null;
	}
	function verifyENOENTSync(status, parsed) {
		if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, "spawnSync");
		return null;
	}
	module.exports = {
		hookChildProcess,
		verifyENOENT,
		verifyENOENTSync,
		notFoundError
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js
var require_cross_spawn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const cp = require("child_process");
	const parse = require_parse();
	const enoent = require_enoent();
	function spawn(command, args, options) {
		const parsed = parse(command, args, options);
		const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
		enoent.hookChildProcess(spawned, parsed);
		return spawned;
	}
	function spawnSync(command, args, options) {
		const parsed = parse(command, args, options);
		const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
		result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
		return result;
	}
	module.exports = spawn;
	module.exports.spawn = spawn;
	module.exports.sync = spawnSync;
	module.exports._parse = parse;
	module.exports._enoent = enoent;
}));

//#endregion
//#region src/config/output/postprocess.ts
var import_cross_spawn = require_cross_spawn();
const postProcessors = {
	"biome:format": {
		args: [
			"format",
			"--write",
			"{{path}}"
		],
		command: "biome",
		name: "Biome (Format)"
	},
	"biome:lint": {
		args: [
			"lint",
			"--apply",
			"{{path}}"
		],
		command: "biome",
		name: "Biome (Lint)"
	},
	eslint: {
		args: ["{{path}}", "--fix"],
		command: "eslint",
		name: "ESLint"
	},
	oxfmt: {
		args: ["{{path}}"],
		command: "oxfmt",
		name: "Oxfmt"
	},
	oxlint: {
		args: ["--fix", "{{path}}"],
		command: "oxlint",
		name: "Oxlint"
	},
	prettier: {
		args: [
			"--ignore-unknown",
			"{{path}}",
			"--write",
			"--ignore-path",
			"./.prettierignore"
		],
		command: "prettier",
		name: "Prettier"
	}
};
const postprocessOutput = (config, jobPrefix) => {
	for (const processor of config.postProcess) {
		const resolved = typeof processor === "string" ? postProcessors[processor] : processor;
		const name = resolved.name ?? resolved.command;
		const args = resolved.args.map((arg) => arg.replace("{{path}}", config.path));
		console.log(`${jobPrefix}ðŸ§¹ Running ${ansi_colors.default.cyanBright(name)}`);
		(0, import_cross_spawn.sync)(resolved.command, args);
	}
};

//#endregion
//#region src/config/output/source/config.ts
function resolveSource(config) {
	const source$2 = valueToObject({
		defaultValue: {
			enabled: Boolean(config.source),
			extension: "json",
			fileName: "source",
			serialize: (input) => JSON.stringify(input, null, 2)
		},
		mappers: { boolean: (enabled) => ({ enabled }) },
		value: config.source
	});
	if (source$2.path === void 0 || source$2.path === true) source$2.path = "";
	else if (source$2.path === false) source$2.path = null;
	return source$2;
}

//#endregion
//#region src/config/output/config.ts
function getOutput(userConfig) {
	if (userConfig.output instanceof Array) throw new Error("Unexpected array of outputs in user configuration. This should have been expanded already.");
	const userOutput = typeof userConfig.output === "string" ? { path: userConfig.output } : userConfig.output ?? {};
	const legacyPostProcess = resolveLegacyPostProcess(userOutput);
	const output = valueToObject({
		defaultValue: {
			clean: true,
			fileName: {
				case: "preserve",
				name: "{{name}}",
				suffix: ".gen"
			},
			format: null,
			header: "// This file is auto-generated by @hey-api/openapi-ts",
			indexFile: true,
			lint: null,
			path: "",
			postProcess: [],
			preferExportAll: false
		},
		mappers: { object: (fields, defaultValue) => ({
			...fields,
			fileName: valueToObject({
				defaultValue: { ...defaultValue.fileName },
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: fields.fileName
			})
		}) },
		value: userOutput
	});
	output.tsConfig = loadTsConfig(findTsConfigPath(output.tsConfigPath));
	if (output.importFileExtension === void 0 && (output.tsConfig?.options.moduleResolution === typescript.default.ModuleResolutionKind.NodeNext || output.tsConfig?.options.moduleResolution === typescript.default.ModuleResolutionKind.Node16)) output.importFileExtension = ".js";
	if (output.importFileExtension && !output.importFileExtension.startsWith(".")) output.importFileExtension = `.${output.importFileExtension}`;
	output.postProcess = normalizePostProcess(userOutput.postProcess ?? legacyPostProcess);
	output.source = resolveSource(output);
	return output;
}
function resolveLegacyPostProcess(config) {
	const result = [];
	if (config.lint !== void 0) {
		let processor;
		let preset;
		if (config.lint) {
			preset = config.lint === "biome" ? "biome:lint" : config.lint;
			processor = postProcessors[preset];
			if (processor) result.push(processor);
		}
		_hey_api_codegen_core.log.warnDeprecated({
			context: "output",
			field: "lint",
			replacement: `postProcess: [${processor && preset ? `'${preset}'` : ""}]`
		});
	}
	if (config.format !== void 0) {
		let processor;
		let preset;
		if (config.format) {
			preset = config.format === "biome" ? "biome:format" : config.format;
			processor = postProcessors[preset];
			if (processor) result.push(processor);
		}
		_hey_api_codegen_core.log.warnDeprecated({
			context: "output",
			field: "format",
			replacement: `postProcess: [${processor && preset ? `'${preset}'` : ""}]`
		});
	}
	return result;
}
function normalizePostProcess(input) {
	if (!input) return [];
	return input.map((item) => {
		if (typeof item === "string") {
			const preset = postProcessors[item];
			if (!preset) throw new Error(`Unknown post-processor preset: "${item}"`);
			return preset;
		}
		return {
			name: item.name ?? item.command,
			...item
		};
	});
}

//#endregion
//#region src/config/parser.ts
const defaultPaginationKeywords = [
	"after",
	"before",
	"cursor",
	"offset",
	"page",
	"start"
];
const getParser = (userConfig) => {
	return valueToObject({
		defaultValue: {
			hooks: {},
			pagination: { keywords: defaultPaginationKeywords },
			transforms: {
				enums: {
					case: "PascalCase",
					enabled: false,
					mode: "root",
					name: "{{name}}Enum"
				},
				propertiesRequiredByDefault: false,
				readWrite: {
					enabled: true,
					requests: {
						case: "preserve",
						name: "{{name}}Writable"
					},
					responses: {
						case: "preserve",
						name: "{{name}}"
					}
				}
			},
			validate_EXPERIMENTAL: false
		},
		mappers: { object: (fields, defaultValue) => ({
			...fields,
			pagination: valueToObject({
				defaultValue: { ...defaultValue.pagination },
				value: fields.pagination
			}),
			transforms: valueToObject({
				defaultValue: { ...defaultValue.transforms },
				mappers: { object: (fields$1, defaultValue$1) => ({
					...fields$1,
					enums: valueToObject({
						defaultValue: {
							...defaultValue$1.enums,
							enabled: fields$1.enums !== void 0 ? Boolean(fields$1.enums) : defaultValue$1.enums.enabled
						},
						mappers: {
							boolean: (enabled) => ({ enabled }),
							string: (mode) => ({ mode })
						},
						value: fields$1.enums
					}),
					propertiesRequiredByDefault: fields$1.propertiesRequiredByDefault !== void 0 ? fields$1.propertiesRequiredByDefault : defaultValue$1.propertiesRequiredByDefault,
					readWrite: valueToObject({
						defaultValue: {
							...defaultValue$1.readWrite,
							enabled: fields$1.readWrite !== void 0 ? Boolean(fields$1.readWrite) : defaultValue$1.readWrite.enabled
						},
						mappers: {
							boolean: (enabled) => ({ enabled }),
							object: (fields$2, defaultValue$2) => ({
								...fields$2,
								requests: valueToObject({
									defaultValue: { ...defaultValue$2.requests },
									mappers: {
										function: (name) => ({ name }),
										string: (name) => ({ name })
									},
									value: fields$2.requests
								}),
								responses: valueToObject({
									defaultValue: { ...defaultValue$2.responses },
									mappers: {
										function: (name) => ({ name }),
										string: (name) => ({ name })
									},
									value: fields$2.responses
								})
							})
						},
						value: fields$1.readWrite
					})
				}) },
				value: fields.transforms
			}),
			validate_EXPERIMENTAL: fields.validate_EXPERIMENTAL === true ? "warn" : fields.validate_EXPERIMENTAL
		}) },
		value: userConfig.parser
	});
};

//#endregion
//#region src/plugins/shared/utils/config.ts
const definePluginConfig = (defaultConfig$24) => (userConfig) => ({
	...defaultConfig$24,
	config: {
		...defaultConfig$24.config,
		...userConfig
	}
});
/**
* Reusable mappers for `enabled` and `name` fields.
*/
const mappers = {
	boolean: (enabled) => ({ enabled }),
	function: (name) => ({ name }),
	string: (name) => ({ name })
};

//#endregion
//#region src/plugins/@angular/common/httpRequests/config.ts
function resolveHttpRequests(config, context) {
	let input = config.httpRequests;
	if (typeof input === "string" || typeof input === "function") input = { strategy: input };
	else if (typeof input === "boolean" || !input) input = { enabled: Boolean(input) };
	const strategy = input.strategy ?? "flat";
	return context.valueToObject({
		defaultValue: {
			container: "class",
			enabled: true,
			methods: "instance",
			nesting: "operationId",
			nestingDelimiters: /[./]/,
			strategy,
			strategyDefaultTag: "default"
		},
		mappers: { object(value) {
			value.containerName = context.valueToObject({
				defaultValue: strategy === "single" ? {
					casing: "PascalCase",
					name: "HttpRequests"
				} : { casing: "PascalCase" },
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: value.containerName
			});
			value.methodName = context.valueToObject({
				defaultValue: strategy === "flat" ? {
					casing: "camelCase",
					name: "{{name}}Request"
				} : { casing: "camelCase" },
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: value.methodName
			});
			value.segmentName = context.valueToObject({
				defaultValue: {
					casing: "PascalCase",
					name: "{{name}}Requests"
				},
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: value.segmentName
			});
			return value;
		} },
		value: input
	});
}

//#endregion
//#region src/openApi/shared/locations/operation.ts
/**
* Built-in strategies for operations.
*/
const OperationStrategy = {
	byTags: (config) => (operation) => {
		const tags = operation.tags && operation.tags.length > 0 ? operation.tags : [config.fallback];
		const pathSegments = (config.path ?? OperationPath.id())(operation);
		return tags.map((tag) => [tag, ...pathSegments]);
	},
	flat: (config) => (operation) => {
		const pathSegments = (config?.path ?? OperationPath.id())(operation);
		return [[pathSegments[pathSegments.length - 1]]];
	},
	single: (config) => (operation) => {
		const pathSegments = (config.path ?? OperationPath.id())(operation);
		return [[config.root, ...pathSegments]];
	}
};
/**
* Built-in path derivation helpers for operations.
*/
const OperationPath = {
	fromOperationId: (config) => (operation) => {
		const fallback = config?.fallback ?? OperationPath.id();
		if (!operation.operationId) return fallback(operation);
		const delimiters = config?.delimiters ?? /[./]/;
		const segments = operation.operationId.split(delimiters).filter(Boolean);
		return segments.length === 0 ? fallback(operation) : segments;
	},
	fromPath: (config) => (operation) => {
		const delimiters = config?.delimiters ?? /[./]/;
		const segments = operation.path.split(delimiters).filter(Boolean);
		switch (config?.methodPosition) {
			case "prefix":
				segments.unshift(operation.method.toLowerCase());
				break;
			case "suffix":
				segments.push(operation.method.toLowerCase());
				break;
			default: break;
		}
		return segments;
	},
	id: () => (operation) => [operation.id]
};

//#endregion
//#region src/plugins/@angular/common/httpRequests/resolve.ts
function resolvePath$2(plugin) {
	if (plugin.config.httpRequests.nesting === "id") return OperationPath.id();
	if (plugin.config.httpRequests.nesting === "operationId") return OperationPath.fromOperationId({
		delimiters: plugin.config.httpRequests.nestingDelimiters,
		fallback: OperationPath.id()
	});
	return plugin.config.httpRequests.nesting;
}
function resolveHttpRequestsStrategy(plugin) {
	if (plugin.config.httpRequests.strategy === "flat") return OperationStrategy.flat({ path: (operation) => [resolvePath$2(plugin)(operation).join(".")] });
	if (plugin.config.httpRequests.strategy === "single") {
		const root = plugin.config.httpRequests.containerName;
		return OperationStrategy.single({
			path: resolvePath$2(plugin),
			root: typeof root.name === "string" ? root.name : root.name?.("") ?? ""
		});
	}
	if (plugin.config.httpRequests.strategy === "byTags") return OperationStrategy.byTags({
		fallback: plugin.config.httpRequests.strategyDefaultTag,
		path: resolvePath$2(plugin)
	});
	return plugin.config.httpRequests.strategy;
}

//#endregion
//#region src/plugins/@angular/common/httpResources/config.ts
function resolveHttpResources(config, context) {
	let input = config.httpResources;
	if (typeof input === "string" || typeof input === "function") input = { strategy: input };
	else if (typeof input === "boolean" || !input) input = { enabled: Boolean(input) };
	const strategy = input.strategy ?? "flat";
	return context.valueToObject({
		defaultValue: {
			container: "class",
			enabled: true,
			methods: "instance",
			nesting: "operationId",
			nestingDelimiters: /[./]/,
			strategy,
			strategyDefaultTag: "default"
		},
		mappers: { object(value) {
			value.containerName = context.valueToObject({
				defaultValue: strategy === "single" ? {
					casing: "PascalCase",
					name: "HttpResources"
				} : { casing: "PascalCase" },
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: value.containerName
			});
			value.methodName = context.valueToObject({
				defaultValue: strategy === "flat" ? {
					casing: "camelCase",
					name: "{{name}}Resource"
				} : { casing: "camelCase" },
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: value.methodName
			});
			value.segmentName = context.valueToObject({
				defaultValue: {
					casing: "PascalCase",
					name: "{{name}}Resources"
				},
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: value.segmentName
			});
			return value;
		} },
		value: input
	});
}

//#endregion
//#region src/plugins/@angular/common/httpResources/resolve.ts
function resolvePath$1(plugin) {
	if (plugin.config.httpResources.nesting === "id") return OperationPath.id();
	if (plugin.config.httpResources.nesting === "operationId") return OperationPath.fromOperationId({
		delimiters: plugin.config.httpResources.nestingDelimiters,
		fallback: OperationPath.id()
	});
	return plugin.config.httpResources.nesting;
}
function resolveHttpResourcesStrategy(plugin) {
	if (plugin.config.httpResources.strategy === "flat") return OperationStrategy.flat({ path: (operation) => [resolvePath$1(plugin)(operation).join(".")] });
	if (plugin.config.httpResources.strategy === "single") {
		const root = plugin.config.httpResources.containerName;
		return OperationStrategy.single({
			path: resolvePath$1(plugin),
			root: typeof root.name === "string" ? root.name : root.name?.("") ?? ""
		});
	}
	if (plugin.config.httpResources.strategy === "byTags") return OperationStrategy.byTags({
		fallback: plugin.config.httpResources.strategyDefaultTag,
		path: resolvePath$1(plugin)
	});
	return plugin.config.httpResources.strategy;
}

//#endregion
//#region src/plugins/@hey-api/client-core/utils.ts
const getClientBaseUrlKey = (config) => {
	const client = getClientPlugin(config);
	if (client.name === "@hey-api/client-axios" || client.name === "@hey-api/client-nuxt") return "baseURL";
	return "baseUrl";
};
const getClientPlugin = (config) => {
	for (const name of config.pluginOrder) {
		const plugin = config.plugins[name];
		if (plugin?.tags?.includes("client")) return plugin;
	}
	return {
		config: { name: "" },
		name: ""
	};
};

//#endregion
//#region src/ir/parameter.ts
const getPaginationSchema = ({ context, parameter }) => {
	if (!parameter.pagination) return;
	if (parameter.pagination === true) return parameter.schema;
	let schema = parameter.schema;
	if (schema.$ref) schema = context.resolveIrRef(schema.$ref);
	return schema.properties[parameter.pagination];
};
const hasParameterGroupObjectRequired = (parameterGroup) => {
	for (const name in parameterGroup) if (parameterGroup[name].required) return true;
	return false;
};
const hasParametersObjectRequired = (parameters) => {
	if (!parameters) return false;
	if (hasParameterGroupObjectRequired(parameters.cookie)) return true;
	if (hasParameterGroupObjectRequired(parameters.header)) return true;
	if (hasParameterGroupObjectRequired(parameters.path)) return true;
	if (hasParameterGroupObjectRequired(parameters.query)) return true;
	return false;
};
const parameterWithPagination = ({ context, parameters }) => {
	if (!parameters) return;
	for (const name in parameters.cookie) {
		const parameter = parameters.cookie[name];
		if (parameter.pagination) return {
			in: parameter.location,
			name: parameter.pagination === true ? parameter.name : `${parameter.name}.${parameter.pagination}`,
			schema: getPaginationSchema({
				context,
				parameter
			})
		};
	}
	for (const name in parameters.header) {
		const parameter = parameters.header[name];
		if (parameter.pagination) return {
			in: parameter.location,
			name: parameter.pagination === true ? parameter.name : `${parameter.name}.${parameter.pagination}`,
			schema: getPaginationSchema({
				context,
				parameter
			})
		};
	}
	for (const name in parameters.path) {
		const parameter = parameters.path[name];
		if (parameter.pagination) return {
			in: parameter.location,
			name: parameter.pagination === true ? parameter.name : `${parameter.name}.${parameter.pagination}`,
			schema: getPaginationSchema({
				context,
				parameter
			})
		};
	}
	for (const name in parameters.query) {
		const parameter = parameters.query[name];
		if (parameter.pagination) return {
			in: parameter.location,
			name: parameter.pagination === true ? parameter.name : `${parameter.name}.${parameter.pagination}`,
			schema: getPaginationSchema({
				context,
				parameter
			})
		};
	}
};

//#endregion
//#region src/ir/schema.ts
/**
* Ensure we don't produce redundant types, e.g. string | string.
*/
const deduplicateSchema = ({ detectFormat = true, schema }) => {
	if (!schema.items) return schema;
	const uniqueItems = [];
	const typeIds = [];
	for (const item of schema.items) {
		if (!item.type && item.items || schema.type === "tuple") {
			uniqueItems.push(item);
			continue;
		}
		if (!item.type || item.type === "boolean" || item.type === "integer" || item.type === "null" || item.type === "number" || item.type === "string" || item.type === "unknown" || item.type === "void") {
			const constant = item.const !== void 0 ? `const-${item.const}` : "";
			const format = item.format !== void 0 && detectFormat ? `format-${item.format}` : "";
			const constraints = [
				item.minLength !== void 0 ? `minLength-${item.minLength}` : "",
				item.maxLength !== void 0 ? `maxLength-${item.maxLength}` : "",
				item.minimum !== void 0 ? `minimum-${item.minimum}` : "",
				item.maximum !== void 0 ? `maximum-${item.maximum}` : "",
				item.exclusiveMinimum !== void 0 ? `exclusiveMinimum-${item.exclusiveMinimum}` : "",
				item.exclusiveMaximum !== void 0 ? `exclusiveMaximum-${item.exclusiveMaximum}` : "",
				item.minItems !== void 0 ? `minItems-${item.minItems}` : "",
				item.maxItems !== void 0 ? `maxItems-${item.maxItems}` : "",
				item.pattern !== void 0 ? `pattern-${item.pattern}` : ""
			].join("");
			const typeId = `${item.$ref ?? ""}${item.type ?? ""}${constant}${format}${constraints}`;
			if (!typeIds.includes(typeId)) {
				typeIds.push(typeId);
				uniqueItems.push(item);
			}
			continue;
		}
		uniqueItems.push(item);
	}
	let result = { ...schema };
	result.items = uniqueItems;
	if (result.items.length <= 1 && result.type !== "array" && result.type !== "enum" && result.type !== "tuple") {
		const liftedSchema = result.items[0];
		delete result.logicalOperator;
		delete result.items;
		result = {
			...result,
			...liftedSchema
		};
	}
	if (result.type === "unknown") return {};
	return result;
};

//#endregion
//#region src/ir/utils.ts
/**
* Simply adds `items` to the schema. Also handles setting the logical operator
* and avoids setting it for a single item or tuples.
*/
const addItemsToSchema = ({ items, logicalOperator = "or", mutateSchemaOneItem = false, schema }) => {
	if (!items.length) return schema;
	if (schema.type === "tuple") {
		schema.items = items;
		return schema;
	}
	if (items.length !== 1) {
		schema.items = items;
		schema.logicalOperator = logicalOperator;
		return schema;
	}
	if (mutateSchemaOneItem) {
		schema = {
			...schema,
			...items[0]
		};
		return schema;
	}
	schema.items = items;
	return schema;
};

//#endregion
//#region src/ir/operation.ts
const hasOperationDataRequired = (operation) => {
	if (hasParametersObjectRequired(operation.parameters)) return true;
	if (operation.body?.required) return true;
	return false;
};
const createOperationKey = ({ method, path: path$10 }) => `${method.toUpperCase()} ${path$10}`;
const operationPagination = ({ context, operation }) => {
	const body = operation.body;
	if (!body || !body.pagination) return parameterWithPagination({
		context,
		parameters: operation.parameters
	});
	if (body.pagination === true) return {
		in: "body",
		name: "body",
		schema: body.schema
	};
	const schema = body.schema;
	const resolvedSchema = schema.$ref ? context.resolveIrRef(schema.$ref) : schema;
	const paginationProp = ("schema" in resolvedSchema ? resolvedSchema.schema : resolvedSchema)?.properties?.[body.pagination];
	if (!paginationProp) return parameterWithPagination({
		context,
		parameters: operation.parameters
	});
	return {
		in: "body",
		name: body.pagination,
		schema: paginationProp
	};
};
const statusCodeToGroup = ({ statusCode }) => {
	switch (statusCode) {
		case "1XX": return "1XX";
		case "2XX": return "2XX";
		case "3XX": return "3XX";
		case "4XX": return "4XX";
		case "5XX": return "5XX";
		case "default": return "default";
		default: return `${statusCode[0]}XX`;
	}
};
const operationResponsesMap = (operation) => {
	const result = {};
	if (!operation.responses) return result;
	const errors = {
		properties: {},
		type: "object"
	};
	const responses = {
		properties: {},
		type: "object"
	};
	let defaultResponse;
	for (const name in operation.responses) {
		const response = operation.responses[name];
		switch (statusCodeToGroup({ statusCode: name })) {
			case "1XX":
			case "3XX": break;
			case "2XX":
				responses.properties[name] = response.schema;
				break;
			case "4XX":
			case "5XX":
				errors.properties[name] = response.schema;
				break;
			case "default":
				defaultResponse = response;
				break;
		}
	}
	if (defaultResponse) {
		let inferred = false;
		if (!Object.keys(responses.properties).length) {
			responses.properties.default = defaultResponse.schema;
			inferred = true;
		}
		const description = (defaultResponse.schema.description ?? "").toLocaleLowerCase();
		const $ref = (defaultResponse.schema.$ref ?? "").toLocaleLowerCase();
		if (["success"].some((keyword) => description.includes(keyword) || $ref.includes(keyword))) {
			responses.properties.default = defaultResponse.schema;
			inferred = true;
		}
		if (["error", "problem"].some((keyword) => description.includes(keyword) || $ref.includes(keyword))) {
			errors.properties.default = defaultResponse.schema;
			inferred = true;
		}
		if (!inferred) errors.properties.default = defaultResponse.schema;
	}
	const errorKeys = Object.keys(errors.properties);
	if (errorKeys.length) {
		errors.required = errorKeys;
		result.errors = errors;
		let errorUnion = addItemsToSchema({
			items: Object.values(errors.properties),
			mutateSchemaOneItem: true,
			schema: {}
		});
		errorUnion = deduplicateSchema({ schema: errorUnion });
		if (Object.keys(errorUnion).length && errorUnion.type !== "unknown") result.error = errorUnion;
	}
	const responseKeys = Object.keys(responses.properties);
	if (responseKeys.length) {
		responses.required = responseKeys;
		result.responses = responses;
		let responseUnion = addItemsToSchema({
			items: Object.values(responses.properties),
			mutateSchemaOneItem: true,
			schema: {}
		});
		responseUnion = deduplicateSchema({ schema: responseUnion });
		if (Object.keys(responseUnion).length && responseUnion.type !== "unknown") result.response = responseUnion;
	}
	return result;
};

//#endregion
//#region src/ts-dsl/base.ts
var TsDsl = class {
	analyze(_) {}
	clone() {
		const cloned = Object.create(Object.getPrototypeOf(this));
		Object.assign(cloned, this);
		return cloned;
	}
	exported;
	file;
	get name() {
		return {
			...this._name,
			set: (value) => {
				this._name = (0, _hey_api_codegen_core.ref)(value);
				if ((0, _hey_api_codegen_core.isSymbol)(value)) value.setNode(this);
			},
			toString: () => this._name ? this.$name(this._name) : ""
		};
	}
	nameSanitizer;
	language = "typescript";
	parent;
	root = false;
	scope = "value";
	structuralChildren;
	structuralParents;
	symbol;
	toAst() {}
	"~brand" = _hey_api_codegen_core.nodeBrand;
	$if(value, ifTrue, ifFalse) {
		if (value) {
			let result;
			try {
				result = ifTrue?.(this, value);
			} catch {}
			if (result === void 0) try {
				result = ifTrue?.(value);
			} catch {}
			if (result === void 0) try {
				result = ifTrue?.();
			} catch {}
			return result ?? this;
		}
		if (ifFalse) {
			let result;
			try {
				result = ifFalse?.(this, value);
			} catch {}
			if (result === void 0) try {
				result = ifFalse?.(value);
			} catch {}
			if (result === void 0) try {
				result = ifFalse?.();
			} catch {}
			return result ?? this;
		}
		return this;
	}
	$maybeId(expr) {
		return typeof expr === "string" ? typescript.default.factory.createIdentifier(expr) : expr;
	}
	$name(name) {
		const value = (0, _hey_api_codegen_core.fromRef)(name);
		if ((0, _hey_api_codegen_core.isSymbol)(value)) try {
			return value.finalName;
		} catch {
			return value.name;
		}
		return String(value);
	}
	$node(value) {
		if (value === void 0) return;
		if ((0, _hey_api_codegen_core.isRef)(value)) value = (0, _hey_api_codegen_core.fromRef)(value);
		if ((0, _hey_api_codegen_core.isSymbol)(value)) return this.$maybeId(value.finalName);
		if (typeof value === "string") return this.$maybeId(value);
		if (value instanceof Array) return value.map((item) => {
			if ((0, _hey_api_codegen_core.isRef)(item)) item = (0, _hey_api_codegen_core.fromRef)(item);
			return this.unwrap(item);
		});
		return this.unwrap(value);
	}
	$type(value, args) {
		if (value === void 0) return;
		if ((0, _hey_api_codegen_core.isRef)(value)) value = (0, _hey_api_codegen_core.fromRef)(value);
		if ((0, _hey_api_codegen_core.isSymbol)(value)) return typescript.default.factory.createTypeReferenceNode(value.finalName, args);
		if (typeof value === "string") return typescript.default.factory.createTypeReferenceNode(value, args);
		if (typeof value === "boolean") {
			const literal = value ? typescript.default.factory.createTrue() : typescript.default.factory.createFalse();
			return typescript.default.factory.createLiteralTypeNode(literal);
		}
		if (typeof value === "number") return typescript.default.factory.createLiteralTypeNode(typescript.default.factory.createNumericLiteral(value));
		if (value instanceof Array) return value.map((item) => this.$type(item, args));
		return this.unwrap(value);
	}
	_name;
	/** Unwraps nested nodes into raw TypeScript AST. */
	unwrap(value) {
		return (0, _hey_api_codegen_core.isNode)(value) ? value.toAst() : value;
	}
};
var TypeTsDsl = class extends TsDsl {};

//#endregion
//#region src/ts-dsl/expr/id.ts
const Mixed$52 = TsDsl;
var IdTsDsl = class extends Mixed$52 {
	"~dsl" = "IdTsDsl";
	constructor(name) {
		super();
		this.name.set(name);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	toAst() {
		return typescript.default.factory.createIdentifier(this.name.toString());
	}
};

//#endregion
//#region src/ts-dsl/layout/newline.ts
var NewlineTsDsl = class extends TsDsl {
	"~dsl" = "NewlineTsDsl";
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	toAst() {
		return this.$node(new IdTsDsl("\n"));
	}
};

//#endregion
//#region src/ts-dsl/mixins/args.ts
/**
* Adds `.arg()` and `.args()` for managing expression arguments in call-like nodes.
*/
function ArgsMixin(Base) {
	class Args extends Base {
		_args = [];
		analyze(ctx$1) {
			super.analyze(ctx$1);
			for (const arg of this._args) ctx$1.analyze(arg);
		}
		arg(arg) {
			if (arg !== void 0) this._args.push((0, _hey_api_codegen_core.ref)(arg));
			return this;
		}
		args(...args) {
			this._args.push(...args.filter((a) => a !== void 0).map((a) => (0, _hey_api_codegen_core.ref)(a)));
			return this;
		}
		$args() {
			return this.$node(this._args).map((arg) => this.$node(arg));
		}
	}
	return Args;
}

//#endregion
//#region src/ts-dsl/expr/prefix.ts
const Mixed$51 = TsDsl;
var PrefixTsDsl = class extends Mixed$51 {
	"~dsl" = "PrefixTsDsl";
	_expr;
	_op;
	constructor(expr, op) {
		super();
		this._expr = expr;
		this._op = op;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._expr);
	}
	/** Sets the operand (the expression being prefixed). */
	expr(expr) {
		this._expr = expr;
		return this;
	}
	/** Sets the operator to MinusToken for negation (`-`). */
	neg() {
		this._op = typescript.default.SyntaxKind.MinusToken;
		return this;
	}
	/** Sets the operator to ExclamationToken for logical NOT (`!`). */
	not() {
		this._op = typescript.default.SyntaxKind.ExclamationToken;
		return this;
	}
	/** Sets the operator (e.g. `ts.SyntaxKind.ExclamationToken` for `!`). */
	op(op) {
		this._op = op;
		return this;
	}
	toAst() {
		if (!this._expr) throw new Error("Missing expression for prefix unary expression");
		if (!this._op) throw new Error("Missing operator for prefix unary expression");
		return typescript.default.factory.createPrefixUnaryExpression(this._op, this.$node(this._expr));
	}
};

//#endregion
//#region src/ts-dsl/utils/factories.ts
function createFactory(name) {
	let impl;
	const slot = ((...args) => {
		if (!impl) throw new Error(`${name} factory not registered`);
		return impl(...args);
	});
	slot.set = (fn) => {
		impl = fn;
	};
	return slot;
}
const f = {
	as: createFactory("as"),
	attr: createFactory("attr"),
	await: createFactory("await"),
	call: createFactory("call"),
	new: createFactory("new"),
	return: createFactory("return"),
	type: {
		expr: createFactory("type.expr"),
		idx: createFactory("type.idx"),
		operator: createFactory("type.operator"),
		query: createFactory("type.query")
	},
	typeofExpr: createFactory("typeofExpr")
};

//#endregion
//#region src/ts-dsl/mixins/as.ts
function AsMixin(Base) {
	class As extends Base {
		analyze(ctx$1) {
			super.analyze(ctx$1);
		}
		as(...args) {
			return f.as(this, ...args);
		}
	}
	return As;
}

//#endregion
//#region src/ts-dsl/expr/literal.ts
const Mixed$50 = AsMixin(TsDsl);
var LiteralTsDsl = class extends Mixed$50 {
	"~dsl" = "LiteralTsDsl";
	value;
	constructor(value) {
		super();
		this.value = value;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	toAst() {
		if (typeof this.value === "boolean") return this.value ? typescript.default.factory.createTrue() : typescript.default.factory.createFalse();
		if (typeof this.value === "number") {
			const expr = typescript.default.factory.createNumericLiteral(Math.abs(this.value));
			return this.value < 0 ? this.$node(new PrefixTsDsl(expr).neg()) : expr;
		}
		if (typeof this.value === "string") return typescript.default.factory.createStringLiteral(this.value, true);
		if (typeof this.value === "bigint") return typescript.default.factory.createBigIntLiteral(this.value.toString());
		if (this.value === null) return typescript.default.factory.createNull();
		throw new Error(`Unsupported literal: ${String(this.value)}`);
	}
};

//#endregion
//#region src/ts-dsl/utils/regexp.ts
/**
* Matches characters from the start as long as they're not allowed.
*/
const illegalStartCharactersRegExp = /^[^$_\p{ID_Start}]+/u;
/**
* Matches string if it contains only digits and optionally decimal point or
* leading minus sign.
*/
const numberRegExp = /^-?\d+(\.\d+)?$/;
/**
* Javascript identifier regexp pattern retrieved from
* {@link} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers
*/
const validTypescriptIdentifierRegExp = /^[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*$/u;
const regexp = {
	illegalStartCharacters: illegalStartCharactersRegExp,
	number: numberRegExp,
	typeScriptIdentifier: validTypescriptIdentifierRegExp
};

//#endregion
//#region src/ts-dsl/utils/keywords.ts
const browserGlobals = [
	"document",
	"history",
	"location",
	"navigator",
	"window"
];
const javaScriptGlobals = [
	"console",
	"Array",
	"Date",
	"Error",
	"Function",
	"JSON",
	"Map",
	"Math",
	"Object",
	"Promise",
	"RegExp",
	"Set",
	"WeakMap",
	"WeakSet"
];
const javaScriptKeywords = [
	"arguments",
	"async",
	"await",
	"break",
	"case",
	"catch",
	"class",
	"const",
	"continue",
	"debugger",
	"default",
	"delete",
	"do",
	"else",
	"enum",
	"eval",
	"export",
	"extends",
	"false",
	"finally",
	"for",
	"from",
	"function",
	"if",
	"implements",
	"import",
	"in",
	"instanceof",
	"interface",
	"let",
	"new",
	"null",
	"package",
	"private",
	"protected",
	"public",
	"return",
	"static",
	"super",
	"switch",
	"this",
	"throw",
	"true",
	"try",
	"typeof",
	"var",
	"void",
	"while",
	"with",
	"yield"
];
const nodeGlobals = [
	"global",
	"process",
	"Buffer"
];
const typeScriptKeywords = [
	"any",
	"as",
	"bigint",
	"boolean",
	"namespace",
	"never",
	"null",
	"number",
	"string",
	"symbol",
	"type",
	"undefined",
	"unknown",
	"void"
];
const keywords = {
	browserGlobals,
	javaScriptGlobals,
	javaScriptKeywords,
	nodeGlobals,
	typeScriptKeywords
};

//#endregion
//#region src/ts-dsl/utils/reserved.ts
var ReservedList = class {
	_array;
	_set;
	constructor(values) {
		this._array = values;
		this._set = new Set(values);
	}
	get "~values"() {
		return this._set;
	}
	/**
	* Updates the reserved list with new values.
	*
	* @param values New reserved values or a function that receives the previous
	* reserved values and returns the new ones.
	*/
	set(values) {
		const vals = typeof values === "function" ? values(this._array) : values;
		this._array = vals;
		this._set = new Set(vals);
	}
};
const runtimeReserved = new ReservedList([
	...keywords.browserGlobals,
	...keywords.javaScriptGlobals,
	...keywords.javaScriptKeywords,
	...keywords.nodeGlobals,
	...keywords.typeScriptKeywords
]);
const typeReserved = new ReservedList([...keywords.javaScriptKeywords, ...keywords.typeScriptKeywords]);
/**
* Reserved names for identifiers. These names will not be used
* for variables, functions, classes, or other identifiers in generated code.
*/
const reserved = {
	runtime: runtimeReserved,
	type: typeReserved
};

//#endregion
//#region src/ts-dsl/utils/name.ts
const safeAccessorName = (name) => {
	regexp.number.lastIndex = 0;
	if (regexp.number.test(name)) return name.startsWith("-") ? `'${name}'` : name;
	regexp.typeScriptIdentifier.lastIndex = 0;
	if (regexp.typeScriptIdentifier.test(name)) return name;
	return `'${name}'`;
};
const safeMemberName = (name) => {
	regexp.typeScriptIdentifier.lastIndex = 0;
	if (regexp.typeScriptIdentifier.test(name)) return new IdTsDsl(name);
	return new LiteralTsDsl(name);
};
const safePropName = (name) => {
	regexp.number.lastIndex = 0;
	if (regexp.number.test(name)) return name.startsWith("-") ? new LiteralTsDsl(name) : new LiteralTsDsl(Number(name));
	regexp.typeScriptIdentifier.lastIndex = 0;
	if (regexp.typeScriptIdentifier.test(name)) return new IdTsDsl(name);
	return new LiteralTsDsl(name);
};
const safeName = (name, reserved$1) => {
	let sanitized = "";
	let index;
	const first = name[0];
	regexp.illegalStartCharacters.lastIndex = 0;
	if (regexp.illegalStartCharacters.test(first)) {
		sanitized += "_";
		index = 0;
	} else {
		sanitized += first;
		index = 1;
	}
	while (index < name.length) {
		const char = name[index];
		sanitized += /^[\u200c\u200d\p{ID_Continue}]$/u.test(char) ? char : "_";
		index += 1;
	}
	if (reserved$1["~values"].has(sanitized)) sanitized = `${sanitized}_`;
	return sanitized || "_";
};
const safeRuntimeName = (name) => safeName(name, reserved.runtime);
const safeTypeName = (name) => safeName(name, reserved.type);

//#endregion
//#region src/ts-dsl/decl/decorator.ts
const Mixed$49 = ArgsMixin(TsDsl);
var DecoratorTsDsl = class extends Mixed$49 {
	"~dsl" = "DecoratorTsDsl";
	nameSanitizer = safeRuntimeName;
	constructor(name, ...args) {
		super();
		this.name.set(name);
		this.args(...args);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.name);
	}
	toAst() {
		const target = this.$node(this.name);
		const args = this.$args();
		return typescript.default.factory.createDecorator(args.length ? typescript.default.factory.createCallExpression(target, void 0, args) : target);
	}
};

//#endregion
//#region src/ts-dsl/mixins/decorator.ts
function DecoratorMixin(Base) {
	class Decorator extends Base {
		decorators = [];
		analyze(ctx$1) {
			super.analyze(ctx$1);
			for (const decorator of this.decorators) ctx$1.analyze(decorator);
		}
		decorator(name, ...args) {
			this.decorators.push(new DecoratorTsDsl(name, ...args));
			return this;
		}
		$decorators() {
			return this.$node(this.decorators);
		}
	}
	return Decorator;
}

//#endregion
//#region src/ts-dsl/utils/context.ts
function accessChainToNode(accessChain) {
	let result;
	accessChain.forEach((node, index) => {
		if (index === 0) result = node;
		else result = result.attr(node.name);
	});
	return result;
}
function getAccessChainForNode(node) {
	const accessChain = structuralToAccessChain([...getStructuralChainForNode(node, /* @__PURE__ */ new Set())]);
	if (accessChain.length === 0) return [node.clone()];
	return accessChain.map((node$1) => node$1.clone());
}
function getScope(node) {
	return node.scope ?? "value";
}
function getStructuralChainForNode(node, visited) {
	if (visited.has(node)) return [];
	visited.add(node);
	if (isStopNode(node)) return [];
	if (node.structuralParents) for (const [parent] of node.structuralParents) {
		if (getScope(parent) !== getScope(node)) continue;
		const chain = getStructuralChainForNode(parent, visited);
		if (chain.length > 0) return [...chain, node];
	}
	if (!node.root) return [];
	return [node];
}
function isAccessorNode(node) {
	return node["~dsl"] === "FieldTsDsl" || node["~dsl"] === "GetterTsDsl" || node["~dsl"] === "MethodTsDsl";
}
function isStopNode(node) {
	return node["~dsl"] === "FuncTsDsl" || node["~dsl"] === "TemplateTsDsl";
}
/**
* Fold a structural chain to an access chain by removing
* non-accessor nodes.
*/
function structuralToAccessChain(structuralChain) {
	const accessChain = [];
	structuralChain.forEach((node, index) => {
		if (index === 0) accessChain.push(node);
		else if (isAccessorNode(node)) accessChain.push(node);
	});
	return accessChain;
}
function transformAccessChain(accessChain, options = {}) {
	return accessChain.map((node, index) => {
		const transformedNode = options.transform?.(node, index, accessChain);
		if (transformedNode) return transformedNode;
		const accessNode = node.toAccessNode?.(node, options, {
			chain: accessChain,
			index,
			isLeaf: index === accessChain.length - 1,
			isRoot: index === 0,
			length: accessChain.length
		});
		if (accessNode) return accessNode;
		if (index === 0) {
			if (node["~dsl"] === "ClassTsDsl") {
				const nextNode = accessChain[index + 1];
				if (nextNode && isAccessorNode(nextNode)) {
					if (nextNode.hasModifier("static")) return $(node.name);
				}
				return $.new(node.name).args();
			}
			return $(node.name);
		}
		return node;
	});
}
var TsDslContext = class {
	/**
	* Build an expression for accessing the node.
	*
	* @param node - The node or symbol to build access for
	* @param options - Access options
	* @returns Expression for accessing the node
	*
	* @example
	* ```ts
	* ctx.access(node); // â†’ Expression for accessing the node
	* ```
	*/
	access(node, options) {
		const n = (0, _hey_api_codegen_core.isSymbol)(node) ? node.node : node;
		if (!n) throw new Error(`Symbol ${node.name} is not resolved to a node.`);
		return accessChainToNode(transformAccessChain(getAccessChainForNode(n), options));
	}
	/**
	* Build an example.
	*
	* @param node - The node to generate an example for
	* @param options - Example options
	* @returns Full example string
	*
	* @example
	* ```ts
	* ctx.example(node, { moduleName: 'my-sdk' }); // â†’ Full example string
	* ```
	*/
	example(node, options, astOptions) {
		if (astOptions) return TypeScriptRenderer.astToString(astOptions);
		options ||= {};
		const accessChain = getAccessChainForNode(node);
		if (options.importName) accessChain[0].name.set(options.importName);
		const importNode = $(accessChain[0].name.toString());
		const finalChain = transformAccessChain(accessChain, { context: "example" });
		const setupNode = options.importSetup ? typeof options.importSetup === "function" ? options.importSetup({
			$,
			node: importNode
		}) : options.importSetup : finalChain[0];
		const setupName = options.setupName;
		let payload = typeof options.payload === "function" ? options.payload({ $ }) : options.payload;
		payload = payload instanceof Array ? payload : payload ? [payload] : [];
		let nodes = [];
		if (setupName) nodes = [$.const(setupName).assign(setupNode), $.await(accessChainToNode([$(setupName), ...finalChain.slice(1)]).call(...payload))];
		else nodes = [$.await(accessChainToNode([setupNode, ...finalChain.slice(1)]).call(...payload))];
		const localName = importNode.name.toString();
		return TypeScriptRenderer.astToString({
			imports: [[{
				imports: !options.importKind || options.importKind === "named" ? [{
					isTypeOnly: false,
					localName,
					sourceName: localName
				}] : [],
				isTypeOnly: false,
				kind: options.importKind ?? "named",
				localName: options.importKind !== "named" ? localName : void 0,
				modulePath: options.moduleName ?? "your-package"
			}]],
			nodes,
			trailingNewline: false
		});
	}
};
const ctx = new TsDslContext();

//#endregion
//#region src/ts-dsl/layout/doc.ts
var DocTsDsl = class extends TsDsl {
	"~dsl" = "DocTsDsl";
	_lines = [];
	constructor(lines, fn) {
		super();
		if (lines) this.add(lines);
		fn?.(this);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	add(lines) {
		this._lines.push(lines);
		return this;
	}
	apply(node) {
		const lines = this._lines.reduce((lines$1, line) => {
			if (typeof line === "function") line = line(ctx);
			for (const l of typeof line === "string" ? [line] : line) if (l || l === "") lines$1.push(l);
			return lines$1;
		}, []);
		if (!lines.length) return node;
		const jsdocTexts = lines.map((line) => typescript.default.factory.createJSDocText(`${line}\n`));
		const jsdoc = typescript.default.factory.createJSDocComment(typescript.default.factory.createNodeArray(jsdocTexts), void 0);
		const cleanedJsdoc = typescript.default.createPrinter().printNode(typescript.default.EmitHint.Unspecified, jsdoc, node.getSourceFile?.() ?? typescript.default.createSourceFile("", "", typescript.default.ScriptTarget.Latest)).replace("/*", "").replace("*  */", "");
		typescript.default.addSyntheticLeadingComment(node, typescript.default.SyntaxKind.MultiLineCommentTrivia, cleanedJsdoc, true);
		return node;
	}
	toAst() {
		return this.$node(new IdTsDsl(""));
	}
};

//#endregion
//#region src/ts-dsl/mixins/doc.ts
function DocMixin(Base) {
	class Doc extends Base {
		_doc;
		analyze(ctx$1) {
			super.analyze(ctx$1);
		}
		doc(lines, fn) {
			this._doc = new DocTsDsl(lines, fn);
			return this;
		}
		$docs(node) {
			return this._doc ? this._doc.apply(node) : node;
		}
	}
	return Doc;
}

//#endregion
//#region src/ts-dsl/mixins/modifiers.ts
function modifierToKind(modifier) {
	switch (modifier) {
		case "abstract": return typescript.default.SyntaxKind.AbstractKeyword;
		case "async": return typescript.default.SyntaxKind.AsyncKeyword;
		case "const": return typescript.default.SyntaxKind.ConstKeyword;
		case "declare": return typescript.default.SyntaxKind.DeclareKeyword;
		case "default": return typescript.default.SyntaxKind.DefaultKeyword;
		case "export": return typescript.default.SyntaxKind.ExportKeyword;
		case "override": return typescript.default.SyntaxKind.OverrideKeyword;
		case "private": return typescript.default.SyntaxKind.PrivateKeyword;
		case "protected": return typescript.default.SyntaxKind.ProtectedKeyword;
		case "public": return typescript.default.SyntaxKind.PublicKeyword;
		case "readonly": return typescript.default.SyntaxKind.ReadonlyKeyword;
		case "static": return typescript.default.SyntaxKind.StaticKeyword;
	}
}
function ModifiersMixin(Base) {
	class Modifiers extends Base {
		modifiers = [];
		analyze(ctx$1) {
			super.analyze(ctx$1);
		}
		hasModifier(modifier) {
			const kind = modifierToKind(modifier);
			return Boolean(this.modifiers.find((mod) => mod.kind === kind));
		}
		_m(modifier, condition) {
			if (condition) {
				const kind = modifierToKind(modifier);
				this.modifiers.push(typescript.default.factory.createModifier(kind));
			}
			return this;
		}
	}
	return Modifiers;
}
/**
* Mixin that adds an `abstract` modifier to a node.
*/
function AbstractMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Abstract extends Mixed$53 {
		abstract(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			return this._m("abstract", cond);
		}
	}
	return Abstract;
}
/**
* Mixin that adds an `async` modifier to a node.
*/
function AsyncMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Async extends Mixed$53 {
		async(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			return this._m("async", cond);
		}
	}
	return Async;
}
/**
* Mixin that adds a `const` modifier to a node.
*/
function ConstMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Const extends Mixed$53 {
		const(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			return this._m("const", cond);
		}
	}
	return Const;
}
/**
* Mixin that adds a `default` modifier to a node.
*/
function DefaultMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Default extends Mixed$53 {
		/**
		* Adds the `default` keyword modifier if the condition is true.
		*
		* @param condition - Whether to add the modifier (default: true).
		* @returns The target object for chaining.
		*/
		default(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			return this._m("default", cond);
		}
	}
	return Default;
}
/**
* Mixin that adds an `export` modifier to a node.
*/
function ExportMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Export extends Mixed$53 {
		/**
		* Adds the `export` keyword modifier if the condition is true.
		*
		* @param condition - Whether to add the modifier (default: true).
		* @returns The target object for chaining.
		*/
		export(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			this.exported = cond;
			if (this.symbol) this.symbol.setExported(cond);
			return this._m("export", cond);
		}
	}
	return Export;
}
/**
* Mixin that adds a `private` modifier to a node.
*/
function PrivateMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Private extends Mixed$53 {
		private(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			return this._m("private", cond);
		}
	}
	return Private;
}
/**
* Mixin that adds a `protected` modifier to a node.
*/
function ProtectedMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Protected extends Mixed$53 {
		protected(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			return this._m("protected", cond);
		}
	}
	return Protected;
}
/**
* Mixin that adds a `public` modifier to a node.
*/
function PublicMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Public extends Mixed$53 {
		public(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			return this._m("public", cond);
		}
	}
	return Public;
}
/**
* Mixin that adds a `readonly` modifier to a node.
*/
function ReadonlyMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Readonly extends Mixed$53 {
		readonly(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			return this._m("readonly", cond);
		}
	}
	return Readonly;
}
/**
* Mixin that adds a `static` modifier to a node.
*/
function StaticMixin(Base) {
	const Mixed$53 = ModifiersMixin(Base);
	class Static extends Mixed$53 {
		static(condition) {
			const cond = arguments.length === 0 ? true : Boolean(condition);
			return this._m("static", cond);
		}
	}
	return Static;
}

//#endregion
//#region src/ts-dsl/type/param.ts
const Mixed$48 = TsDsl;
var TypeParamTsDsl = class extends Mixed$48 {
	"~dsl" = "TypeParamTsDsl";
	scope = "type";
	constraint;
	defaultValue;
	constructor(name, fn) {
		super();
		if (name) this.name.set(name);
		fn?.(this);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.name);
		ctx$1.analyze(this.constraint);
		ctx$1.analyze(this.defaultValue);
	}
	default(value) {
		this.defaultValue = (0, _hey_api_codegen_core.ref)(value);
		return this;
	}
	extends(constraint) {
		this.constraint = (0, _hey_api_codegen_core.ref)(constraint);
		return this;
	}
	toAst() {
		if (!this.name.toString()) throw new Error("Missing type name");
		return typescript.default.factory.createTypeParameterDeclaration(void 0, this.$node(this.name), this.$type(this.constraint), this.$type(this.defaultValue));
	}
};

//#endregion
//#region src/ts-dsl/mixins/type-params.ts
function TypeParamsMixin(Base) {
	class TypeParams extends Base {
		_generics = [];
		analyze(ctx$1) {
			super.analyze(ctx$1);
			for (const g of this._generics) ctx$1.analyze(g);
		}
		generic(...args) {
			const g = new TypeParamTsDsl(...args);
			this._generics.push(g);
			return this;
		}
		generics(...args) {
			for (let arg of args) {
				if (typeof arg === "string" || typeof arg === "number" || (0, _hey_api_codegen_core.isSymbol)(arg) || (0, _hey_api_codegen_core.isRef)(arg)) arg = new TypeParamTsDsl(arg);
				this._generics.push(arg);
			}
			return this;
		}
		$generics() {
			return this.$node(this._generics);
		}
	}
	return TypeParams;
}

//#endregion
//#region src/ts-dsl/mixins/optional.ts
function OptionalMixin(Base) {
	class Optional extends Base {
		_optional;
		analyze(ctx$1) {
			super.analyze(ctx$1);
		}
		optional(condition) {
			this._optional = arguments.length === 0 ? true : Boolean(condition);
			return this;
		}
		required(condition) {
			this._optional = arguments.length === 0 ? false : !condition;
			return this;
		}
	}
	return Optional;
}

//#endregion
//#region src/ts-dsl/mixins/value.ts
function ValueMixin(Base) {
	class Value extends Base {
		value;
		analyze(ctx$1) {
			super.analyze(ctx$1);
			ctx$1.analyze(this.value);
		}
		assign(expr) {
			this.value = expr;
			return this;
		}
		$value() {
			return this.$node(this.value);
		}
	}
	return Value;
}

//#endregion
//#region src/ts-dsl/token.ts
var TokenTsDsl = class extends TsDsl {
	"~dsl" = "TokenTsDsl";
	_kind;
	/** Sets the token kind */
	kind(kind) {
		this._kind = kind;
		return this;
	}
	/** Creates `-` */
	minus() {
		return this.kind(typescript.default.SyntaxKind.MinusToken);
	}
	/** Creates `?` (optional) */
	optional() {
		return this.kind(typescript.default.SyntaxKind.QuestionToken);
	}
	/** Creates `+` */
	plus() {
		return this.kind(typescript.default.SyntaxKind.PlusToken);
	}
	/** Creates `?.` (optional chaining token) */
	questionDot() {
		return this.kind(typescript.default.SyntaxKind.QuestionDotToken);
	}
	/** Creates `readonly` */
	readonly() {
		return this.kind(typescript.default.SyntaxKind.ReadonlyKeyword);
	}
	/** Creates `...` (spread / rest) */
	spread() {
		return this.kind(typescript.default.SyntaxKind.DotDotDotToken);
	}
	toAst() {
		if (!this._kind) throw new Error(`Token missing \`.kind(kind)\``);
		return typescript.default.factory.createToken(this._kind);
	}
};

//#endregion
//#region src/ts-dsl/mixins/type-args.ts
function TypeArgsMixin(Base) {
	class TypeArgs extends Base {
		_generics = [];
		analyze(ctx$1) {
			super.analyze(ctx$1);
			for (const g of this._generics) ctx$1.analyze(g);
		}
		generic(arg) {
			this._generics.push((0, _hey_api_codegen_core.ref)(arg));
			return this;
		}
		generics(...args) {
			this._generics.push(...args.map((a) => (0, _hey_api_codegen_core.ref)(a)));
			return this;
		}
		$generics() {
			return this.$type(this._generics);
		}
	}
	return TypeArgs;
}

//#endregion
//#region src/ts-dsl/mixins/type-expr.ts
function TypeExprMixin(Base) {
	class TypeExpr extends Base {
		analyze(ctx$1) {
			super.analyze(ctx$1);
		}
		idx(...args) {
			return f.type.idx(this, ...args);
		}
		keyof() {
			return f.type.operator().keyof(this);
		}
		readonly() {
			return f.type.operator().readonly(this);
		}
		returnType(...args) {
			return f.type.expr("ReturnType").generic(f.type.query(this, ...args));
		}
		typeofExpr(...args) {
			return f.typeofExpr(this, ...args);
		}
		typeofType(...args) {
			return f.type.query(this, ...args);
		}
		unique() {
			return f.type.operator().unique(this);
		}
	}
	return TypeExpr;
}

//#endregion
//#region src/ts-dsl/type/attr.ts
const Mixed$47 = TypeExprMixin(TsDsl);
var TypeAttrTsDsl = class extends Mixed$47 {
	"~dsl" = "TypeAttrTsDsl";
	scope = "type";
	_base;
	_right;
	constructor(base, right) {
		super();
		if (right) {
			this.base(base);
			this.right(right);
		} else {
			this.base();
			this.right(base);
		}
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._base);
		ctx$1.analyze(this._right);
	}
	base(base) {
		if ((0, _hey_api_codegen_core.isRef)(base)) this._base = base;
		else this._base = base ? (0, _hey_api_codegen_core.ref)(base) : void 0;
		return this;
	}
	right(right) {
		this._right = (0, _hey_api_codegen_core.ref)(right);
		return this;
	}
	toAst() {
		if (!this._base) throw new Error("TypeAttrTsDsl: missing base for qualified name");
		const left = this.$node(this._base);
		if (!typescript.default.isEntityName(left)) throw new Error("TypeAttrTsDsl: base must be an EntityName");
		return typescript.default.factory.createQualifiedName(left, this.$node(this._right));
	}
};

//#endregion
//#region src/ts-dsl/type/expr.ts
const Mixed$46 = TypeArgsMixin(TypeExprMixin(TsDsl));
var TypeExprTsDsl = class extends Mixed$46 {
	"~dsl" = "TypeExprTsDsl";
	scope = "type";
	_exprInput;
	constructor(name, fn) {
		super();
		if (typeof name === "function") name(this);
		else {
			this._exprInput = name ? (0, _hey_api_codegen_core.ref)(name) : void 0;
			fn?.(this);
		}
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._exprInput);
	}
	/** Accesses a nested type (e.g. `Foo.Bar`). */
	attr(right) {
		this._exprInput = (0, _hey_api_codegen_core.isNode)(right) ? (0, _hey_api_codegen_core.ref)(right.base(this._exprInput)) : (0, _hey_api_codegen_core.ref)(new TypeAttrTsDsl(this._exprInput, right));
		return this;
	}
	toAst() {
		if (!this._exprInput) throw new Error("TypeExpr must have an expression");
		return typescript.default.factory.createTypeReferenceNode(this.$type(this._exprInput), this.$generics());
	}
};
f.type.expr.set((...args) => new TypeExprTsDsl(...args));

//#endregion
//#region src/ts-dsl/decl/field.ts
const Mixed$45 = DecoratorMixin(DocMixin(OptionalMixin(PrivateMixin(ProtectedMixin(PublicMixin(ReadonlyMixin(StaticMixin(ValueMixin(TsDsl)))))))));
var FieldTsDsl = class extends Mixed$45 {
	"~dsl" = "FieldTsDsl";
	nameSanitizer = safeAccessorName;
	_type;
	constructor(name, fn) {
		super();
		this.name.set(name);
		fn?.(this);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.name);
		ctx$1.analyze(this._type);
	}
	/** Sets the field type. */
	type(type) {
		this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);
		return this;
	}
	toAst() {
		const node = typescript.default.factory.createPropertyDeclaration([...this.$decorators(), ...this.modifiers], this.$node(this.name), this._optional ? this.$node(new TokenTsDsl().optional()) : void 0, this.$type(this._type), this.$value());
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/stmt/stmt.ts
const Mixed$44 = TsDsl;
var StmtTsDsl = class extends Mixed$44 {
	"~dsl" = "StmtTsDsl";
	_inner;
	constructor(inner) {
		super();
		this._inner = inner;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._inner);
	}
	toAst() {
		const node = this.$node(this._inner);
		return typescript.default.isStatement(node) ? node : typescript.default.factory.createExpressionStatement(node);
	}
};

//#endregion
//#region src/ts-dsl/mixins/do.ts
/**
* Adds `.do()` for appending statements or expressions to a body.
*/
function DoMixin(Base) {
	class Do extends Base {
		_do = [];
		analyze(ctx$1) {
			super.analyze(ctx$1);
			ctx$1.pushScope();
			try {
				for (const item of this._do) ctx$1.analyze(item);
			} finally {
				ctx$1.popScope();
			}
		}
		do(...items) {
			this._do.push(...items);
			return this;
		}
		$do() {
			return this.$node(this._do.map((item) => new StmtTsDsl(item)));
		}
	}
	return Do;
}

//#endregion
//#region src/ts-dsl/decl/pattern.ts
const Mixed$43 = TsDsl;
/**
* Builds binding patterns (e.g. `{ foo, bar }`, `[a, b, ...rest]`).
*/
var PatternTsDsl = class extends Mixed$43 {
	"~dsl" = "PatternTsDsl";
	pattern;
	_spread;
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	/** Defines an array pattern (e.g. `[a, b, c]`). */
	array(...props) {
		this.pattern = {
			kind: "array",
			values: props[0] instanceof Array ? [...props[0]] : props
		};
		return this;
	}
	/** Defines an object pattern (e.g. `{ a, b: alias }`). */
	object(...props) {
		const entries = {};
		for (const p of props) if (typeof p === "string") entries[p] = p;
		else if (p instanceof Array) for (const n of p) entries[n] = n;
		else Object.assign(entries, p);
		this.pattern = {
			kind: "object",
			values: entries
		};
		return this;
	}
	/** Adds a spread element (e.g. `...rest`, `...options`, `...args`). */
	spread(name) {
		this._spread = name;
		return this;
	}
	toAst() {
		if (!this.pattern) throw new Error("PatternTsDsl requires object() or array() pattern");
		if (this.pattern.kind === "object") {
			const elements = Object.entries(this.pattern.values).map(([key, alias]) => key === alias ? typescript.default.factory.createBindingElement(void 0, void 0, key, void 0) : typescript.default.factory.createBindingElement(void 0, key, alias, void 0));
			const spread = this.createSpread();
			if (spread) elements.push(spread);
			return typescript.default.factory.createObjectBindingPattern(elements);
		}
		if (this.pattern.kind === "array") {
			const elements = this.pattern.values.map((p) => typescript.default.factory.createBindingElement(void 0, void 0, p, void 0));
			const spread = this.createSpread();
			if (spread) elements.push(spread);
			return typescript.default.factory.createArrayBindingPattern(elements);
		}
		throw new Error("PatternTsDsl requires object() or array() pattern");
	}
	createSpread() {
		return this._spread ? typescript.default.factory.createBindingElement(this.$node(new TokenTsDsl().spread()), void 0, this.$node(new IdTsDsl(this._spread))) : void 0;
	}
};

//#endregion
//#region src/ts-dsl/mixins/pattern.ts
/**
* Mixin providing `.array()`, `.object()`, and `.spread()` methods for defining destructuring patterns.
*/
function PatternMixin(Base) {
	class Pattern extends Base {
		pattern;
		analyze(ctx$1) {
			super.analyze(ctx$1);
			ctx$1.analyze(this.pattern);
		}
		array(...props) {
			(this.pattern ??= new PatternTsDsl()).array(...props);
			return this;
		}
		object(...props) {
			(this.pattern ??= new PatternTsDsl()).object(...props);
			return this;
		}
		/** Adds a spread element (e.g. `...args`, `...options`) to the pattern. */
		spread(name) {
			(this.pattern ??= new PatternTsDsl()).spread(name);
			return this;
		}
		/** Renders the pattern into a `BindingName`. */
		$pattern() {
			if (!this.pattern) return;
			return this.$node(this.pattern);
		}
	}
	return Pattern;
}

//#endregion
//#region src/ts-dsl/decl/param.ts
const Mixed$42 = DecoratorMixin(OptionalMixin(PatternMixin(ValueMixin(TsDsl))));
var ParamTsDsl = class extends Mixed$42 {
	"~dsl" = "ParamTsDsl";
	_type;
	constructor(name, fn) {
		super();
		if (typeof name === "function") name(this);
		else {
			this.name.set(name);
			fn?.(this);
		}
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.name);
		ctx$1.analyze(this._type);
	}
	/** Sets the parameter type. */
	type(type) {
		this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);
		return this;
	}
	toAst() {
		const name = this.$pattern() || this.name.toString();
		if (!name) throw new Error("Param must have either a name or a destructuring pattern");
		return typescript.default.factory.createParameterDeclaration(this.$decorators(), void 0, name, this._optional ? this.$node(new TokenTsDsl().optional()) : void 0, this.$type(this._type), this.$value());
	}
};

//#endregion
//#region src/ts-dsl/mixins/param.ts
function ParamMixin(Base) {
	class Param extends Base {
		_params = [];
		analyze(ctx$1) {
			super.analyze(ctx$1);
			for (const param of this._params) ctx$1.analyze(param);
		}
		param(name, fn) {
			const p = new ParamTsDsl(name, fn);
			this._params.push(p);
			return this;
		}
		params(...params) {
			this._params.push(...params);
			return this;
		}
		$params() {
			return this.$node(this._params);
		}
	}
	return Param;
}

//#endregion
//#region src/ts-dsl/mixins/layout.ts
function LayoutMixin(Base) {
	class Layout extends Base {
		static DEFAULT_THRESHOLD = 3;
		layout;
		analyze(ctx$1) {
			super.analyze(ctx$1);
		}
		auto(threshold = Layout.DEFAULT_THRESHOLD) {
			this.layout = threshold;
			return this;
		}
		inline() {
			this.layout = false;
			return this;
		}
		pretty() {
			this.layout = true;
			return this;
		}
		$multiline(count) {
			if (this.layout === void 0) this.layout = Layout.DEFAULT_THRESHOLD;
			if (count === 0) return false;
			return typeof this.layout === "number" ? count >= this.layout : this.layout;
		}
	}
	return Layout;
}

//#endregion
//#region src/ts-dsl/stmt/block.ts
const Mixed$41 = DoMixin(LayoutMixin(TsDsl));
var BlockTsDsl = class extends Mixed$41 {
	"~dsl" = "BlockTsDsl";
	constructor(...items) {
		super();
		this.do(...items);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	toAst() {
		const statements = this.$do();
		return typescript.default.factory.createBlock(statements, this.$multiline(statements.length));
	}
};

//#endregion
//#region src/ts-dsl/decl/init.ts
const Mixed$40 = DecoratorMixin(DoMixin(DocMixin(ParamMixin(PrivateMixin(ProtectedMixin(PublicMixin(TsDsl)))))));
var InitTsDsl = class extends Mixed$40 {
	"~dsl" = "InitTsDsl";
	constructor(fn) {
		super();
		fn?.(this);
	}
	analyze(ctx$1) {
		ctx$1.pushScope();
		try {
			super.analyze(ctx$1);
		} finally {
			ctx$1.popScope();
		}
	}
	toAst() {
		const node = typescript.default.factory.createConstructorDeclaration([...this.$decorators(), ...this.modifiers], this.$params(), this.$node(new BlockTsDsl(...this._do).pretty()));
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/mixins/type-returns.ts
function TypeReturnsMixin(Base) {
	class TypeReturns extends Base {
		_returns;
		analyze(ctx$1) {
			super.analyze(ctx$1);
			ctx$1.analyze(this._returns);
		}
		returns(type) {
			this._returns = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);
			return this;
		}
		$returns() {
			return this.$type(this._returns);
		}
	}
	return TypeReturns;
}

//#endregion
//#region src/ts-dsl/decl/method.ts
const Mixed$39 = AbstractMixin(AsyncMixin(DecoratorMixin(DoMixin(DocMixin(OptionalMixin(ParamMixin(PrivateMixin(ProtectedMixin(PublicMixin(StaticMixin(TypeParamsMixin(TypeReturnsMixin(TsDsl)))))))))))));
var MethodTsDsl = class extends Mixed$39 {
	"~dsl" = "MethodTsDsl";
	nameSanitizer = safeAccessorName;
	constructor(name, fn) {
		super();
		this.name.set(name);
		fn?.(this);
	}
	analyze(ctx$1) {
		ctx$1.analyze(this.name);
		ctx$1.pushScope();
		try {
			super.analyze(ctx$1);
		} finally {
			ctx$1.popScope();
		}
	}
	toAst() {
		const node = typescript.default.factory.createMethodDeclaration([...this.$decorators(), ...this.modifiers], void 0, this.$node(this.name), this._optional ? this.$node(new TokenTsDsl().optional()) : void 0, this.$generics(), this.$params(), this.$returns(), this.$node(new BlockTsDsl(...this._do).pretty()));
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/decl/class.ts
const Mixed$38 = AbstractMixin(DecoratorMixin(DefaultMixin(DocMixin(ExportMixin(TypeParamsMixin(TsDsl))))));
var ClassTsDsl = class extends Mixed$38 {
	"~dsl" = "ClassTsDsl";
	nameSanitizer = safeRuntimeName;
	baseClass;
	body = [];
	constructor(name) {
		super();
		this.name.set(name);
		if ((0, _hey_api_codegen_core.isSymbol)(name)) name.setKind("class");
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.baseClass);
		ctx$1.analyze(this.name);
		ctx$1.pushScope();
		try {
			for (const item of this.body) ctx$1.analyze(item);
		} finally {
			ctx$1.popScope();
		}
	}
	/** Returns true if the class has any members. */
	get hasBody() {
		return this.body.length > 0;
	}
	/** Adds one or more class members (fields, methods, etc.). */
	do(...items) {
		this.body.push(...items);
		return this;
	}
	/** Records a base class to extend from. */
	extends(base) {
		this.baseClass = base ? (0, _hey_api_codegen_core.ref)(base) : void 0;
		return this;
	}
	/** Adds a class field. */
	field(name, fn) {
		const f$1 = new FieldTsDsl(name, fn);
		this.body.push(f$1);
		return this;
	}
	/** Adds a class constructor. */
	init(fn) {
		const i = typeof fn === "function" ? new InitTsDsl(fn) : fn || new InitTsDsl();
		this.body.push(i);
		return this;
	}
	/** Adds a class method. */
	method(name, fn) {
		const m = new MethodTsDsl(name, fn);
		this.body.push(m);
		return this;
	}
	/** Inserts an empty line between members for formatting. */
	newline() {
		this.body.push(new NewlineTsDsl());
		return this;
	}
	toAst() {
		const body = this.$node(this.body);
		const node = typescript.default.factory.createClassDeclaration([...this.$decorators(), ...this.modifiers], this.$node(this.name), this.$generics(), this._heritage(), body);
		return this.$docs(node);
	}
	/** Builds heritage clauses (extends). */
	_heritage() {
		const node = this.$node(this.baseClass);
		if (!node) return [];
		return [typescript.default.factory.createHeritageClause(typescript.default.SyntaxKind.ExtendsKeyword, [typescript.default.factory.createExpressionWithTypeArguments(node, void 0)])];
	}
};

//#endregion
//#region src/ts-dsl/decl/member.ts
const Mixed$37 = DocMixin(TsDsl);
var EnumMemberTsDsl = class extends Mixed$37 {
	"~dsl" = "EnumMemberTsDsl";
	_value;
	constructor(name, value) {
		super();
		this.name.set(name);
		if (typeof value === "function") value(this);
		else this.value(value);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._value);
	}
	/** Sets the enum member value. */
	value(value) {
		this._value = value;
		return this;
	}
	toAst() {
		const node = typescript.default.factory.createEnumMember(this.$node(safeMemberName(this.name.toString())), this.$node(this._value));
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/decl/enum.ts
const Mixed$36 = ConstMixin(DocMixin(ExportMixin(TsDsl)));
var EnumTsDsl = class extends Mixed$36 {
	"~dsl" = "EnumTsDsl";
	nameSanitizer = safeRuntimeName;
	_members = [];
	constructor(name, fn) {
		super();
		this.name.set(name);
		if ((0, _hey_api_codegen_core.isSymbol)(name)) name.setKind("enum");
		fn?.(this);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.name);
		ctx$1.pushScope();
		try {
			for (const member of this._members) ctx$1.analyze(member);
		} finally {
			ctx$1.popScope();
		}
	}
	/** Adds an enum member. */
	member(name, value) {
		const m = new EnumMemberTsDsl(name, value);
		this._members.push(m);
		return this;
	}
	/** Adds multiple enum members. */
	members(...members) {
		this._members.push(...members);
		return this;
	}
	toAst() {
		const node = typescript.default.factory.createEnumDeclaration(this.modifiers, this.$node(this.name), this.$node(this._members));
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/decl/func.ts
const Mixed$35 = AbstractMixin(AsMixin(AsyncMixin(DecoratorMixin(DoMixin(DocMixin(ParamMixin(PrivateMixin(ProtectedMixin(PublicMixin(StaticMixin(TypeParamsMixin(TypeReturnsMixin(TsDsl)))))))))))));
var ImplFuncTsDsl = class extends Mixed$35 {
	"~dsl" = "FuncTsDsl";
	nameSanitizer = safeRuntimeName;
	mode;
	constructor(name, fn) {
		super();
		if (typeof name === "function") {
			this.mode = "arrow";
			name(this);
		} else if (name) {
			this.mode = "decl";
			this.name.set(name);
			if ((0, _hey_api_codegen_core.isSymbol)(name)) name.setKind("function");
			fn?.(this);
		}
	}
	analyze(ctx$1) {
		ctx$1.pushScope();
		try {
			super.analyze(ctx$1);
			ctx$1.analyze(this.name);
		} finally {
			ctx$1.popScope();
		}
	}
	/** Switches the function to an arrow function form. */
	arrow() {
		this.mode = "arrow";
		return this;
	}
	/** Switches the function to a function declaration form. */
	decl() {
		this.mode = "decl";
		return this;
	}
	/** Switches the function to a function expression form. */
	expr() {
		this.mode = "expr";
		return this;
	}
	toAst() {
		const body = this.$node(new BlockTsDsl(...this._do).pretty());
		if (this.mode === "decl") {
			if (!this.name.toString()) throw new Error("Function declaration requires a name");
			const node$1 = typescript.default.factory.createFunctionDeclaration([...this.$decorators(), ...this.modifiers], void 0, this.$node(this.name), this.$generics(), this.$params(), this.$returns(), body);
			return this.$docs(node$1);
		}
		if (this.mode === "expr") {
			const node$1 = typescript.default.factory.createFunctionExpression(this.modifiers, void 0, this.$node(this.name), this.$generics(), this.$params(), this.$returns(), body);
			return this.$docs(node$1);
		}
		const node = typescript.default.factory.createArrowFunction(this.modifiers, this.$generics(), this.$params(), this.$returns(), void 0, body.statements.length === 1 && typescript.default.isReturnStatement(body.statements[0]) && body.statements[0].expression ? body.statements[0].expression : body);
		return this.$docs(node);
	}
};
const FuncTsDsl = ImplFuncTsDsl;

//#endregion
//#region src/ts-dsl/decl/getter.ts
const Mixed$34 = AbstractMixin(AsyncMixin(DecoratorMixin(DoMixin(DocMixin(ParamMixin(PrivateMixin(ProtectedMixin(PublicMixin(StaticMixin(TypeReturnsMixin(TsDsl)))))))))));
var GetterTsDsl = class extends Mixed$34 {
	"~dsl" = "GetterTsDsl";
	nameSanitizer = safeAccessorName;
	constructor(name, fn) {
		super();
		this.name.set(name);
		fn?.(this);
	}
	analyze(ctx$1) {
		ctx$1.analyze(this.name);
		ctx$1.pushScope();
		try {
			super.analyze(ctx$1);
		} finally {
			ctx$1.popScope();
		}
	}
	toAst() {
		const node = typescript.default.factory.createGetAccessorDeclaration([...this.$decorators(), ...this.modifiers], this.$node(this.name), this.$params(), this.$returns(), this.$node(new BlockTsDsl(...this._do).pretty()));
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/decl/setter.ts
const Mixed$33 = AbstractMixin(AsyncMixin(DecoratorMixin(DoMixin(DocMixin(ParamMixin(PrivateMixin(ProtectedMixin(PublicMixin(StaticMixin(TsDsl))))))))));
var SetterTsDsl = class extends Mixed$33 {
	"~dsl" = "SetterTsDsl";
	nameSanitizer = safeAccessorName;
	constructor(name, fn) {
		super();
		this.name.set(name);
		fn?.(this);
	}
	analyze(ctx$1) {
		ctx$1.analyze(this.name);
		ctx$1.pushScope();
		try {
			super.analyze(ctx$1);
		} finally {
			ctx$1.popScope();
		}
	}
	toAst() {
		const node = typescript.default.factory.createSetAccessorDeclaration([...this.$decorators(), ...this.modifiers], this.$node(this.name), this.$params(), this.$node(new BlockTsDsl(...this._do).pretty()));
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/expr/array.ts
const Mixed$32 = AsMixin(LayoutMixin(TsDsl));
var ArrayTsDsl = class extends Mixed$32 {
	"~dsl" = "ArrayTsDsl";
	_elements = [];
	constructor(...exprs) {
		super();
		this.elements(...exprs);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		for (const item of this._elements) ctx$1.analyze(item.expr);
	}
	/** Adds a single array element. */
	element(expr) {
		const node = typeof expr === "string" || typeof expr === "number" || typeof expr === "boolean" ? new LiteralTsDsl(expr) : expr;
		this._elements.push({
			expr: node,
			kind: "element"
		});
		return this;
	}
	/** Adds multiple array elements. */
	elements(...exprs) {
		for (const expr of exprs) this.element(expr);
		return this;
	}
	/** Adds a spread element (`...expr`). */
	spread(expr) {
		this._elements.push({
			expr,
			kind: "spread"
		});
		return this;
	}
	toAst() {
		const elements = this._elements.map((item) => {
			const node = this.$node(item.expr);
			return item.kind === "spread" ? typescript.default.factory.createSpreadElement(node) : node;
		});
		return typescript.default.factory.createArrayLiteralExpression(elements, this.$multiline(this._elements.length));
	}
};

//#endregion
//#region src/ts-dsl/mixins/expr.ts
function ExprMixin(Base) {
	class Expr extends Base {
		analyze(ctx$1) {
			super.analyze(ctx$1);
		}
		attr(...args) {
			return f.attr(this, ...args);
		}
		await() {
			return f.await(this);
		}
		call(...args) {
			return f.call(this, ...args);
		}
		return() {
			return f.return(this);
		}
	}
	return Expr;
}

//#endregion
//#region src/ts-dsl/expr/as.ts
const Mixed$31 = AsMixin(ExprMixin(TsDsl));
var AsTsDsl = class extends Mixed$31 {
	"~dsl" = "AsTsDsl";
	expr;
	type;
	constructor(expr, type) {
		super();
		this.expr = (0, _hey_api_codegen_core.ref)(expr);
		this.type = (0, _hey_api_codegen_core.ref)(type);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.expr);
		ctx$1.analyze(this.type);
	}
	toAst() {
		return typescript.default.factory.createAsExpression(this.$node(this.expr), this.$type(this.type));
	}
};
f.as.set((...args) => new AsTsDsl(...args));

//#endregion
//#region src/ts-dsl/expr/binary.ts
const Mixed$30 = AsMixin(ExprMixin(TsDsl));
var BinaryTsDsl = class extends Mixed$30 {
	"~dsl" = "BinaryTsDsl";
	_base;
	_expr;
	_op;
	constructor(base, op, expr) {
		super();
		this._base = (0, _hey_api_codegen_core.ref)(base);
		this._op = op;
		if (expr) this._expr = (0, _hey_api_codegen_core.ref)(expr);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._base);
		ctx$1.analyze(this._expr);
	}
	/** Logical AND â€” `this && expr` */
	and(expr) {
		return this.opAndExpr("&&", expr);
	}
	/** Creates an assignment expression (e.g. `this = expr`). */
	assign(expr) {
		return this.opAndExpr("=", expr);
	}
	/** Nullish coalescing â€” `this ?? expr` */
	coalesce(expr) {
		return this.opAndExpr("??", expr);
	}
	/** Division â€” `this / expr` */
	div(expr) {
		return this.opAndExpr("/", expr);
	}
	/** Strict equality â€” `this === expr` */
	eq(expr) {
		return this.opAndExpr("===", expr);
	}
	/** Greater than â€” `this > expr` */
	gt(expr) {
		return this.opAndExpr(">", expr);
	}
	/** Greater than or equal â€” `this >= expr` */
	gte(expr) {
		return this.opAndExpr(">=", expr);
	}
	/** Loose equality â€” `this == expr` */
	looseEq(expr) {
		return this.opAndExpr("==", expr);
	}
	/** Loose inequality â€” `this != expr` */
	looseNeq(expr) {
		return this.opAndExpr("!=", expr);
	}
	/** Less than â€” `this < expr` */
	lt(expr) {
		return this.opAndExpr("<", expr);
	}
	/** Less than or equal â€” `this <= expr` */
	lte(expr) {
		return this.opAndExpr("<=", expr);
	}
	/** Subtraction â€” `this - expr` */
	minus(expr) {
		return this.opAndExpr("-", expr);
	}
	/** Strict inequality â€” `this !== expr` */
	neq(expr) {
		return this.opAndExpr("!==", expr);
	}
	/** Nullish assignment â€” `this ??= expr` */
	nullishAssign(expr) {
		return this.opAndExpr("??=", expr);
	}
	/** Logical OR â€” `this || expr` */
	or(expr) {
		return this.opAndExpr("||", expr);
	}
	/** Addition â€” `this + expr` */
	plus(expr) {
		return this.opAndExpr("+", expr);
	}
	/** Multiplication â€” `this * expr` */
	times(expr) {
		return this.opAndExpr("*", expr);
	}
	toAst() {
		if (!this._op) throw new Error("BinaryTsDsl: missing operator");
		const expr = this.$node(this._expr);
		if (!expr) throw new Error("BinaryTsDsl: missing right-hand expression");
		const base = this.$node(this._base);
		const operator = typeof this._op === "string" ? this.opToToken(this._op) : this._op;
		return typescript.default.factory.createBinaryExpression(base, operator, expr);
	}
	/** Sets the binary operator and right-hand operand for this expression. */
	opAndExpr(op, expr) {
		this._expr = (0, _hey_api_codegen_core.ref)(expr);
		this._op = op;
		return this;
	}
	opToToken(op) {
		const token = {
			"!=": typescript.default.SyntaxKind.ExclamationEqualsToken,
			"!==": typescript.default.SyntaxKind.ExclamationEqualsEqualsToken,
			"&&": typescript.default.SyntaxKind.AmpersandAmpersandToken,
			"*": typescript.default.SyntaxKind.AsteriskToken,
			"+": typescript.default.SyntaxKind.PlusToken,
			"-": typescript.default.SyntaxKind.MinusToken,
			"/": typescript.default.SyntaxKind.SlashToken,
			"<": typescript.default.SyntaxKind.LessThanToken,
			"<=": typescript.default.SyntaxKind.LessThanEqualsToken,
			"=": typescript.default.SyntaxKind.EqualsToken,
			"==": typescript.default.SyntaxKind.EqualsEqualsToken,
			"===": typescript.default.SyntaxKind.EqualsEqualsEqualsToken,
			">": typescript.default.SyntaxKind.GreaterThanToken,
			">=": typescript.default.SyntaxKind.GreaterThanEqualsToken,
			"??": typescript.default.SyntaxKind.QuestionQuestionToken,
			"??=": typescript.default.SyntaxKind.QuestionQuestionEqualsToken,
			"||": typescript.default.SyntaxKind.BarBarToken
		}[op];
		if (!token) throw new Error(`Unsupported operator: ${op}`);
		return token;
	}
};

//#endregion
//#region src/ts-dsl/mixins/operator.ts
function OperatorMixin(Base) {
	class Operator extends Base {
		analyze(ctx$1) {
			super.analyze(ctx$1);
		}
		and(expr) {
			return new BinaryTsDsl(this).and(expr);
		}
		assign(expr) {
			return new BinaryTsDsl(this, "=", expr);
		}
		coalesce(expr) {
			return new BinaryTsDsl(this).coalesce(expr);
		}
		div(expr) {
			return new BinaryTsDsl(this).div(expr);
		}
		eq(expr) {
			return new BinaryTsDsl(this).eq(expr);
		}
		gt(expr) {
			return new BinaryTsDsl(this).gt(expr);
		}
		gte(expr) {
			return new BinaryTsDsl(this).gte(expr);
		}
		looseEq(expr) {
			return new BinaryTsDsl(this).looseEq(expr);
		}
		looseNeq(expr) {
			return new BinaryTsDsl(this).looseNeq(expr);
		}
		lt(expr) {
			return new BinaryTsDsl(this).lt(expr);
		}
		lte(expr) {
			return new BinaryTsDsl(this).lte(expr);
		}
		minus(expr) {
			return new BinaryTsDsl(this).minus(expr);
		}
		neq(expr) {
			return new BinaryTsDsl(this).neq(expr);
		}
		nullishAssign(expr) {
			return new BinaryTsDsl(this).nullishAssign(expr);
		}
		or(expr) {
			return new BinaryTsDsl(this).or(expr);
		}
		plus(expr) {
			return new BinaryTsDsl(this).plus(expr);
		}
		times(expr) {
			return new BinaryTsDsl(this).times(expr);
		}
	}
	return Operator;
}

//#endregion
//#region src/ts-dsl/expr/attr.ts
const Mixed$29 = AsMixin(ExprMixin(OperatorMixin(OptionalMixin(TsDsl))));
var AttrTsDsl = class extends Mixed$29 {
	"~dsl" = "AttrTsDsl";
	left;
	constructor(left, right) {
		super();
		this.left = (0, _hey_api_codegen_core.ref)(left);
		this.name.set(right);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.left);
		ctx$1.analyze(this.name);
	}
	toAst() {
		const leftNode = this.$node(this.left);
		regexp.typeScriptIdentifier.lastIndex = 0;
		const right = (0, _hey_api_codegen_core.fromRef)(this.name);
		if (!regexp.typeScriptIdentifier.test(this.name.toString())) {
			let value = (0, _hey_api_codegen_core.isSymbol)(right) ? right.finalName : right;
			if (typeof value === "string") {
				if (value.startsWith("'") && value.endsWith("'") || value.startsWith("\"") && value.endsWith("\"")) value = value.slice(1, -1);
			}
			if (this._optional) return typescript.default.factory.createElementAccessChain(leftNode, this.$node(new TokenTsDsl().questionDot()), this.$node(new LiteralTsDsl(value)));
			return typescript.default.factory.createElementAccessExpression(leftNode, this.$node(new LiteralTsDsl(value)));
		}
		if (this._optional) return typescript.default.factory.createPropertyAccessChain(leftNode, this.$node(new TokenTsDsl().questionDot()), this.$node(this.name));
		return typescript.default.factory.createPropertyAccessExpression(leftNode, this.$node(this.name));
	}
};
f.attr.set((...args) => new AttrTsDsl(...args));

//#endregion
//#region src/ts-dsl/expr/await.ts
const Mixed$28 = ExprMixin(TsDsl);
var AwaitTsDsl = class extends Mixed$28 {
	"~dsl" = "AwaitTsDsl";
	_awaitExpr;
	constructor(expr) {
		super();
		this._awaitExpr = (0, _hey_api_codegen_core.ref)(expr);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._awaitExpr);
	}
	toAst() {
		return typescript.default.factory.createAwaitExpression(this.$node(this._awaitExpr));
	}
};
f.await.set((...args) => new AwaitTsDsl(...args));

//#endregion
//#region src/ts-dsl/expr/call.ts
const Mixed$27 = ArgsMixin(AsMixin(ExprMixin(TypeArgsMixin(TsDsl))));
var CallTsDsl = class extends Mixed$27 {
	"~dsl" = "CallTsDsl";
	_callExpr;
	constructor(expr, ...args) {
		super();
		this._callExpr = (0, _hey_api_codegen_core.ref)(expr);
		this.args(...args);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._callExpr);
	}
	toAst() {
		return typescript.default.factory.createCallExpression(this.$node(this._callExpr), this.$generics(), this.$args());
	}
};
f.call.set((...args) => new CallTsDsl(...args));

//#endregion
//#region src/ts-dsl/expr/expr.ts
const Mixed$26 = AsMixin(ExprMixin(OperatorMixin(TypeExprMixin(TsDsl))));
var ExprTsDsl = class extends Mixed$26 {
	"~dsl" = "ExprTsDsl";
	_exprInput;
	constructor(id) {
		super();
		this._exprInput = (0, _hey_api_codegen_core.ref)(id);
		if (typeof id === "string" || (0, _hey_api_codegen_core.isSymbol)(id)) this.name.set(id);
		else if ((0, _hey_api_codegen_core.isNode)(id)) this.name.set(id.name);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._exprInput);
	}
	toAst() {
		return this.$node(this._exprInput);
	}
};

//#endregion
//#region src/ts-dsl/layout/hint.ts
var HintTsDsl = class extends TsDsl {
	"~dsl" = "HintTsDsl";
	_lines = [];
	constructor(lines, fn) {
		super();
		if (lines) this.add(lines);
		fn?.(this);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	add(lines) {
		this._lines.push(lines);
		return this;
	}
	apply(node) {
		const lines = this._lines.reduce((lines$1, line) => {
			if (typeof line === "function") line = line(ctx);
			for (const l of typeof line === "string" ? [line] : line) if (l || l === "") lines$1.push(l);
			return lines$1;
		}, []);
		if (!lines.length) return node;
		for (const line of lines) typescript.default.addSyntheticLeadingComment(node, typescript.default.SyntaxKind.SingleLineCommentTrivia, ` ${line}`, false);
		return node;
	}
	toAst() {
		return this.$node(new IdTsDsl(""));
	}
};

//#endregion
//#region src/ts-dsl/mixins/hint.ts
function HintMixin(Base) {
	class Hint extends Base {
		_hint;
		analyze(ctx$1) {
			super.analyze(ctx$1);
		}
		hint(lines, fn) {
			this._hint = new HintTsDsl(lines, fn);
			return this;
		}
		$hint(node) {
			return this._hint ? this._hint.apply(node) : node;
		}
	}
	return Hint;
}

//#endregion
//#region src/ts-dsl/expr/prop.ts
const Mixed$25 = DocMixin(TsDsl);
var ObjectPropTsDsl = class extends Mixed$25 {
	"~dsl" = "ObjectPropTsDsl";
	_value;
	_meta;
	constructor(meta) {
		super();
		this._meta = meta;
	}
	get kind() {
		return this._meta.kind;
	}
	get propName() {
		return this._meta.name;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._value);
	}
	get isValid() {
		return this.missingRequiredCalls().length === 0;
	}
	value(value) {
		if (typeof value === "function") value(this);
		else this._value = (0, _hey_api_codegen_core.ref)(value);
		return this;
	}
	toAst() {
		this.$validate();
		const node = this.$node(this._value);
		if (this._meta.kind === "spread") {
			if (typescript.default.isStatement(node)) throw new Error("Invalid spread: object spread must be an expression, not a statement.");
			const result$1 = typescript.default.factory.createSpreadAssignment(node);
			return this.$docs(result$1);
		}
		if (this._meta.kind === "getter") {
			const getter = new GetterTsDsl(this._meta.name).do(node);
			const result$1 = this.$node(getter);
			return this.$docs(result$1);
		}
		if (this._meta.kind === "setter") {
			const setter = new SetterTsDsl(this._meta.name).do(node);
			const result$1 = this.$node(setter);
			return this.$docs(result$1);
		}
		if (typescript.default.isIdentifier(node) && node.text === this._meta.name) {
			const result$1 = typescript.default.factory.createShorthandPropertyAssignment(this._meta.name);
			return this.$docs(result$1);
		}
		if (typescript.default.isStatement(node)) throw new Error("Invalid property: object property value must be an expression, not a statement.");
		const result = typescript.default.factory.createPropertyAssignment(this._meta.kind === "computed" ? typescript.default.factory.createComputedPropertyName(this.$node(new IdTsDsl(this._meta.name))) : this.$node(safePropName(this._meta.name)), node);
		return this.$docs(result);
	}
	$validate() {
		const missing = this.missingRequiredCalls();
		if (missing.length === 0) return;
		throw new Error(`Object property${this._meta.name ? ` "${this._meta.name}"` : ""} missing ${missing.join(" and ")}`);
	}
	missingRequiredCalls() {
		const missing = [];
		if (!this._value) missing.push(".value()");
		return missing;
	}
};

//#endregion
//#region src/ts-dsl/expr/object.ts
const Mixed$24 = AsMixin(ExprMixin(HintMixin(LayoutMixin(TsDsl))));
var ObjectTsDsl = class extends Mixed$24 {
	"~dsl" = "ObjectTsDsl";
	_props = /* @__PURE__ */ new Map();
	_spreadCounter = 0;
	constructor(...props) {
		super();
		this.props(...props);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		for (const prop of this._props.values()) ctx$1.analyze(prop);
	}
	/** Returns composite key for the property. */
	_propKey(prop) {
		if (prop.kind === "spread") return `spread:${this._spreadCounter++}`;
		return `${prop.kind}:${prop.propName}`;
	}
	/** Adds a computed property (e.g. `{ [expr]: value }`), or removes if null. */
	computed(name, expr) {
		if (expr === null) this._props.delete(`computed:${name}`);
		else this._props.set(`computed:${name}`, new ObjectPropTsDsl({
			kind: "computed",
			name
		}).value(expr));
		return this;
	}
	/** Adds a getter property (e.g. `{ get foo() { ... } }`), or removes if null. */
	getter(name, stmt) {
		if (stmt === null) this._props.delete(`getter:${name}`);
		else this._props.set(`getter:${name}`, new ObjectPropTsDsl({
			kind: "getter",
			name
		}).value(stmt));
		return this;
	}
	/** Returns true if object has at least one property or spread. */
	hasProps() {
		return this._props.size > 0;
	}
	/** Returns true if object has no properties or spreads. */
	get isEmpty() {
		return this._props.size === 0;
	}
	/** Adds a property assignment, or removes if null. */
	prop(name, expr) {
		if (expr === null) this._props.delete(`prop:${name}`);
		else this._props.set(`prop:${name}`, new ObjectPropTsDsl({
			kind: "prop",
			name
		}).value(expr));
		return this;
	}
	/** Adds multiple properties. */
	props(...props) {
		for (const prop of props) this._props.set(this._propKey(prop), prop);
		return this;
	}
	/** Adds a setter property (e.g. `{ set foo(v) { ... } }`), or removes if null. */
	setter(name, stmt) {
		if (stmt === null) this._props.delete(`setter:${name}`);
		else this._props.set(`setter:${name}`, new ObjectPropTsDsl({
			kind: "setter",
			name
		}).value(stmt));
		return this;
	}
	/** Adds a spread property (e.g. `{ ...options }`). */
	spread(expr) {
		const key = `spread:${this._spreadCounter++}`;
		this._props.set(key, new ObjectPropTsDsl({ kind: "spread" }).value(expr));
		return this;
	}
	toAst() {
		const props = [...this._props.values()];
		const node = typescript.default.factory.createObjectLiteralExpression(this.$node(props), this.$multiline(props.length));
		return this.$hint(node);
	}
};

//#endregion
//#region src/ts-dsl/expr/fromValue.ts
const fromValue$1 = (input, options) => {
	if ((0, _hey_api_codegen_core.isNode)(input)) return input;
	if (input === null || typeof input === "number" || typeof input === "boolean" || typeof input === "string" || typeof input === "bigint") return new LiteralTsDsl(input);
	if (input instanceof Array) {
		const arr = new ArrayTsDsl(...input.map((v) => fromValue$1(v, options)));
		if (options?.layout === "pretty") arr.pretty();
		return arr;
	}
	if (typeof input === "object") {
		const obj = new ObjectTsDsl();
		for (const [key, val] of Object.entries(input)) {
			const expr = fromValue$1(val, options);
			obj.prop(key, expr);
		}
		if (options?.layout === "pretty") obj.pretty();
		return obj;
	}
	throw new Error(`$.fromValue(): Unsupported input type ${String(input)}`);
};

//#endregion
//#region src/ts-dsl/expr/new.ts
const Mixed$23 = ArgsMixin(AsMixin(ExprMixin(TypeArgsMixin(TsDsl))));
var NewTsDsl = class extends Mixed$23 {
	"~dsl" = "NewTsDsl";
	_newExpr;
	constructor(expr, ...args) {
		super();
		this._newExpr = (0, _hey_api_codegen_core.ref)(expr);
		this.args(...args);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._newExpr);
	}
	toAst() {
		return typescript.default.factory.createNewExpression(this.$node(this._newExpr), this.$generics(), this.$args());
	}
};
f.new.set((...args) => new NewTsDsl(...args));

//#endregion
//#region src/ts-dsl/expr/regexp.ts
const Mixed$22 = TsDsl;
var RegExpTsDsl = class extends Mixed$22 {
	"~dsl" = "RegExpTsDsl";
	pattern;
	flags;
	constructor(pattern, flags) {
		super();
		this.pattern = pattern;
		this.flags = flags;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	toAst() {
		const literal = `/${(this.pattern.startsWith("/") && this.pattern.endsWith("/") ? this.pattern.slice(1, -1) : this.pattern).replace(/(?<!\\)\//g, "\\/")}/${this.flags ?? ""}`;
		return typescript.default.factory.createRegularExpressionLiteral(literal);
	}
};

//#endregion
//#region src/ts-dsl/expr/template.ts
const Mixed$21 = TsDsl;
var TemplateTsDsl = class extends Mixed$21 {
	"~dsl" = "TemplateTsDsl";
	parts = [];
	constructor(value) {
		super();
		if (value !== void 0) this.add(value);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		for (const part of this.parts) ctx$1.analyze(part);
	}
	add(value) {
		this.parts.push((0, _hey_api_codegen_core.ref)(value));
		return this;
	}
	toAst() {
		const parts = this.$node(this.parts.map((p) => {
			const part = (0, _hey_api_codegen_core.fromRef)(p);
			return (0, _hey_api_codegen_core.isSymbol)(part) ? part.finalName : part;
		}));
		const normalized = [];
		for (let index = 0; index < parts.length; index++) {
			const current = parts[index];
			if (typeof current === "string") {
				let merged = current;
				while (index + 1 < parts.length && typeof parts[index + 1] === "string") {
					merged += parts[index + 1];
					index++;
				}
				normalized.push(merged);
			} else if (typeof current === "number") normalized.push(String(current));
			else normalized.push(current);
		}
		if (normalized.length === 0 || typeof normalized[0] !== "string") normalized.unshift("");
		if (normalized.length === 1 && typeof normalized[0] === "string") return typescript.default.factory.createNoSubstitutionTemplateLiteral(normalized[0]);
		if (normalized.length === 2 && typeof normalized[0] === "string" && typeof normalized[1] !== "string") return typescript.default.factory.createTemplateExpression(typescript.default.factory.createTemplateHead(normalized[0]), [typescript.default.factory.createTemplateSpan(normalized[1], typescript.default.factory.createTemplateTail(""))]);
		const head = typescript.default.factory.createTemplateHead(normalized.shift());
		const spans = [];
		while (normalized.length) {
			const expr = normalized.shift();
			const next = typeof normalized[0] === "string" ? normalized.shift() : "";
			const isLast = normalized.length === 0;
			spans.push(typescript.default.factory.createTemplateSpan(expr, isLast ? typescript.default.factory.createTemplateTail(next) : typescript.default.factory.createTemplateMiddle(next)));
		}
		return typescript.default.factory.createTemplateExpression(head, spans);
	}
};

//#endregion
//#region src/ts-dsl/expr/ternary.ts
const Mixed$20 = TsDsl;
var TernaryTsDsl = class extends Mixed$20 {
	"~dsl" = "TernaryTsDsl";
	_condition;
	_then;
	_else;
	constructor(condition) {
		super();
		if (condition) this.condition(condition);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._condition);
		ctx$1.analyze(this._then);
		ctx$1.analyze(this._else);
	}
	condition(condition) {
		this._condition = condition;
		return this;
	}
	do(expr) {
		this._then = expr;
		return this;
	}
	otherwise(expr) {
		this._else = expr;
		return this;
	}
	toAst() {
		if (!this._condition) throw new Error("Missing condition in ternary");
		if (!this._then) throw new Error("Missing then expression in ternary");
		if (!this._else) throw new Error("Missing else expression in ternary");
		return typescript.default.factory.createConditionalExpression(this.$node(this._condition), void 0, this.$node(this._then), void 0, this.$node(this._else));
	}
};

//#endregion
//#region src/ts-dsl/expr/typeof.ts
const Mixed$19 = OperatorMixin(TsDsl);
var TypeOfExprTsDsl = class extends Mixed$19 {
	"~dsl" = "TypeOfExprTsDsl";
	_expr;
	constructor(expr) {
		super();
		this._expr = expr;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._expr);
	}
	toAst() {
		return typescript.default.factory.createTypeOfExpression(this.$node(this._expr));
	}
};
f.typeofExpr.set((...args) => new TypeOfExprTsDsl(...args));

//#endregion
//#region src/ts-dsl/layout/note.ts
var NoteTsDsl = class extends TsDsl {
	"~dsl" = "NoteTsDsl";
	_lines = [];
	constructor(lines, fn) {
		super();
		if (lines) this.add(lines);
		fn?.(this);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	add(lines) {
		this._lines.push(lines);
		return this;
	}
	apply(node) {
		const lines = this._lines.reduce((lines$1, line) => {
			if (typeof line === "function") line = line(ctx);
			for (const l of typeof line === "string" ? [line] : line) if (l || l === "") lines$1.push(l);
			return lines$1;
		}, []);
		if (!lines.length) return node;
		typescript.default.addSyntheticLeadingComment(node, typescript.default.SyntaxKind.MultiLineCommentTrivia, `\n${lines.join("\n")}\n`, true);
		return node;
	}
	toAst() {
		return this.$node(new IdTsDsl(""));
	}
};

//#endregion
//#region src/ts-dsl/stmt/if.ts
const Mixed$18 = DoMixin(TsDsl);
var IfTsDsl = class extends Mixed$18 {
	"~dsl" = "IfTsDsl";
	_condition;
	_else;
	constructor(condition) {
		super();
		if (condition) this.condition(condition);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._condition);
		if (this._else) {
			ctx$1.pushScope();
			try {
				for (const stmt of this._else) ctx$1.analyze(stmt);
			} finally {
				ctx$1.popScope();
			}
		}
	}
	condition(condition) {
		this._condition = condition;
		return this;
	}
	otherwise(...items) {
		this._else = items;
		return this;
	}
	toAst() {
		if (!this._condition) throw new Error("Missing condition in if");
		if (!this._do) throw new Error("Missing then block in if");
		return typescript.default.factory.createIfStatement(this.$node(this._condition), this.$node(new BlockTsDsl(...this._do).pretty()), this._else ? this.$node(new BlockTsDsl(...this._else).pretty()) : void 0);
	}
};

//#endregion
//#region src/ts-dsl/stmt/return.ts
const Mixed$17 = TsDsl;
var ReturnTsDsl = class extends Mixed$17 {
	"~dsl" = "ReturnTsDsl";
	_returnExpr;
	constructor(expr) {
		super();
		if (expr) this._returnExpr = (0, _hey_api_codegen_core.ref)(expr);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._returnExpr);
	}
	toAst() {
		return typescript.default.factory.createReturnStatement(this.$node(this._returnExpr));
	}
};
f.return.set((...args) => new ReturnTsDsl(...args));

//#endregion
//#region src/ts-dsl/stmt/throw.ts
const Mixed$16 = TsDsl;
var ThrowTsDsl = class extends Mixed$16 {
	"~dsl" = "ThrowTsDsl";
	error;
	msg;
	useNew;
	constructor(error, useNew = true) {
		super();
		this.error = error;
		this.useNew = useNew;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.error);
		ctx$1.analyze(this.msg);
	}
	message(value) {
		this.msg = value;
		return this;
	}
	toAst() {
		const errorNode = this.$node(this.error);
		const messageNode = this.$node(this.msg ? [this.msg] : []).map((expr) => typeof expr === "string" ? this.$node(new LiteralTsDsl(expr)) : expr);
		if (this.useNew) return typescript.default.factory.createThrowStatement(typescript.default.factory.createNewExpression(errorNode, void 0, messageNode));
		const args = messageNode.length ? [typescript.default.factory.createCallExpression(errorNode, void 0, messageNode)] : [errorNode];
		return typescript.default.factory.createThrowStatement(args[0]);
	}
};

//#endregion
//#region src/ts-dsl/stmt/try.ts
const Mixed$15 = TsDsl;
var TryTsDsl = class extends Mixed$15 {
	"~dsl" = "TryTsDsl";
	_catch;
	_catchArg;
	_finally;
	_try;
	constructor(...tryBlock) {
		super();
		this.try(...tryBlock);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		if (this._try) {
			ctx$1.pushScope();
			try {
				for (const stmt of this._try) ctx$1.analyze(stmt);
			} finally {
				ctx$1.popScope();
			}
		}
		if (this._catch || this._catchArg) {
			ctx$1.pushScope();
			try {
				ctx$1.analyze(this._catchArg);
				if (this._catch) for (const stmt of this._catch) ctx$1.analyze(stmt);
			} finally {
				ctx$1.popScope();
			}
		}
		if (this._finally) {
			ctx$1.pushScope();
			try {
				for (const stmt of this._finally) ctx$1.analyze(stmt);
			} finally {
				ctx$1.popScope();
			}
		}
	}
	catch(...items) {
		this._catch = items;
		return this;
	}
	catchArg(arg) {
		this._catchArg = arg;
		return this;
	}
	finally(...items) {
		this._finally = items;
		return this;
	}
	try(...items) {
		this._try = items;
		return this;
	}
	toAst() {
		if (!this._try?.length) throw new Error("Missing try block");
		const catchParam = this._catchArg ? this.$node(this._catchArg) : void 0;
		return typescript.default.factory.createTryStatement(this.$node(new BlockTsDsl(...this._try).pretty()), typescript.default.factory.createCatchClause(catchParam ? typescript.default.factory.createVariableDeclaration(catchParam) : void 0, this.$node(new BlockTsDsl(...this._catch ?? []).pretty())), this._finally ? this.$node(new BlockTsDsl(...this._finally).pretty()) : void 0);
	}
};

//#endregion
//#region src/ts-dsl/stmt/var.ts
const Mixed$14 = DefaultMixin(DocMixin(ExportMixin(HintMixin(PatternMixin(ValueMixin(TsDsl))))));
var VarTsDsl = class extends Mixed$14 {
	"~dsl" = "VarTsDsl";
	nameSanitizer = safeRuntimeName;
	kind = typescript.default.NodeFlags.None;
	_type;
	constructor(name) {
		super();
		if (name) this.name.set(name);
		if ((0, _hey_api_codegen_core.isSymbol)(name)) name.setKind("var");
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.name);
		ctx$1.analyze(this._type);
	}
	const() {
		this.kind = typescript.default.NodeFlags.Const;
		return this;
	}
	let() {
		this.kind = typescript.default.NodeFlags.Let;
		return this;
	}
	/** Sets the variable type. */
	type(type) {
		this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);
		return this;
	}
	var() {
		this.kind = typescript.default.NodeFlags.None;
		return this;
	}
	toAst() {
		const name = this.$pattern() ?? this.$node(this.name);
		if (!name) throw new Error("Var must have either a name or a destructuring pattern");
		const node = typescript.default.factory.createVariableStatement(this.modifiers, typescript.default.factory.createVariableDeclarationList([typescript.default.factory.createVariableDeclaration(name, void 0, this.$type(this._type), this.$value())], this.kind));
		return this.$docs(this.$hint(node));
	}
};

//#endregion
//#region src/ts-dsl/type/alias.ts
const Mixed$13 = DocMixin(ExportMixin(TypeParamsMixin(TsDsl)));
var TypeAliasTsDsl = class extends Mixed$13 {
	"~dsl" = "TypeAliasTsDsl";
	nameSanitizer = safeTypeName;
	scope = "type";
	value;
	constructor(name, fn) {
		super();
		this.name.set(name);
		if ((0, _hey_api_codegen_core.isSymbol)(name)) name.setKind("type");
		fn?.(this);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.name);
		ctx$1.analyze(this.value);
	}
	/** Sets the type expression on the right-hand side of `= ...`. */
	type(node) {
		this.value = node;
		return this;
	}
	toAst() {
		if (!this.value) throw new Error(`Type alias '${this.name.toString()}' is missing a type definition`);
		const node = typescript.default.factory.createTypeAliasDeclaration(this.modifiers, this.$node(this.name), this.$generics(), this.$type(this.value));
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/type/and.ts
const Mixed$12 = TsDsl;
var TypeAndTsDsl = class extends Mixed$12 {
	"~dsl" = "TypeAndTsDsl";
	scope = "type";
	_types = [];
	constructor(...nodes) {
		super();
		this.types(...nodes);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		for (const type of this._types) ctx$1.analyze(type);
	}
	types(...nodes) {
		this._types.push(...nodes.map((n) => (0, _hey_api_codegen_core.ref)(n)));
		return this;
	}
	toAst() {
		const flat = [];
		for (const node of this._types) {
			const type = this.$type(node);
			if (typescript.default.isIntersectionTypeNode(type)) flat.push(...type.types);
			else flat.push(type);
		}
		return typescript.default.factory.createIntersectionTypeNode(flat);
	}
};

//#endregion
//#region src/ts-dsl/type/literal.ts
const Mixed$11 = TsDsl;
var TypeLiteralTsDsl = class extends Mixed$11 {
	"~dsl" = "TypeLiteralTsDsl";
	scope = "type";
	value;
	constructor(value) {
		super();
		this.value = value;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	toAst() {
		return typescript.default.factory.createLiteralTypeNode(this.$node(new LiteralTsDsl(this.value)));
	}
};

//#endregion
//#region src/ts-dsl/type/idx-sig.ts
const Mixed$10 = DocMixin(ReadonlyMixin(TsDsl));
var TypeIdxSigTsDsl = class extends Mixed$10 {
	"~dsl" = "TypeIdxSigTsDsl";
	scope = "type";
	_key;
	_type;
	constructor(name, fn) {
		super();
		this.name.set(name);
		fn?.(this);
	}
	/** Element kind. */
	get kind() {
		return "idxSig";
	}
	/** Index signature parameter name. */
	get propName() {
		return this.name.toString();
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._key);
		ctx$1.analyze(this._type);
	}
	/** Returns true when all required builder calls are present. */
	get isValid() {
		return this.missingRequiredCalls().length === 0;
	}
	/** Sets the key type: `[name: T]` */
	key(type) {
		this._key = type;
		return this;
	}
	/** Sets the property type. */
	type(type) {
		this._type = type;
		return this;
	}
	toAst() {
		this.$validate();
		const node = typescript.default.factory.createIndexSignature(this.modifiers, [typescript.default.factory.createParameterDeclaration(void 0, void 0, this.$node(this.name), void 0, this.$type(this._key))], this.$type(this._type));
		return this.$docs(node);
	}
	$validate() {
		const missing = this.missingRequiredCalls();
		if (missing.length === 0) return;
		const name = this.name.toString();
		throw new Error(`Index signature${name ? ` "${name}"` : ""} missing ${missing.join(" and ")}`);
	}
	missingRequiredCalls() {
		const missing = [];
		if (!this._key) missing.push(".key()");
		if (!this._type) missing.push(".â€‹type()");
		return missing;
	}
};

//#endregion
//#region src/ts-dsl/type/prop.ts
const Mixed$9 = DocMixin(OptionalMixin(ReadonlyMixin(TsDsl)));
var TypePropTsDsl = class extends Mixed$9 {
	"~dsl" = "TypePropTsDsl";
	scope = "type";
	_type;
	constructor(name, fn) {
		super();
		this.name.set(name);
		fn(this);
	}
	/** Element kind. */
	get kind() {
		return "prop";
	}
	/** Property name. */
	get propName() {
		return this.name.toString();
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._type);
	}
	/** Sets the property type. */
	type(type) {
		this._type = (0, _hey_api_codegen_core.ref)(type);
		return this;
	}
	toAst() {
		const name = this.name.toString();
		if (!this._type || !name) throw new Error(`Type not specified for property '${name}'`);
		const node = typescript.default.factory.createPropertySignature(this.modifiers, this.$node(safePropName(name)), this._optional ? this.$node(new TokenTsDsl().optional()) : void 0, this.$type(this._type));
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/type/object.ts
const Mixed$8 = TsDsl;
var TypeObjectTsDsl = class extends Mixed$8 {
	"~dsl" = "TypeObjectTsDsl";
	scope = "type";
	_props = /* @__PURE__ */ new Map();
	analyze(ctx$1) {
		super.analyze(ctx$1);
		for (const prop of this._props.values()) ctx$1.analyze(prop);
	}
	/** Returns true if object has at least one property or index signature. */
	hasProps() {
		return this._props.size > 0;
	}
	/** Adds an index signature to the object type, or removes if fn is null. */
	idxSig(name, fn) {
		const key = `idxSig:${name}`;
		if (fn === null) this._props.delete(key);
		else this._props.set(key, new TypeIdxSigTsDsl(name, fn));
		return this;
	}
	/** Returns true if object has no properties or index signatures. */
	get isEmpty() {
		return this._props.size === 0;
	}
	/** Adds a property signature, or removes if fn is null. */
	prop(name, fn) {
		const key = `prop:${name}`;
		if (fn === null) this._props.delete(key);
		else this._props.set(key, new TypePropTsDsl(name, fn));
		return this;
	}
	/** Adds multiple properties/index signatures. */
	props(...members) {
		for (const member of members) this._props.set(`${member.kind}:${member.propName}`, member);
		return this;
	}
	toAst() {
		return typescript.default.factory.createTypeLiteralNode(this.$node([...this._props.values()]));
	}
};

//#endregion
//#region src/ts-dsl/type/tuple.ts
const Mixed$7 = TsDsl;
var TypeTupleTsDsl = class extends Mixed$7 {
	"~dsl" = "TypeTupleTsDsl";
	scope = "type";
	_elements = [];
	constructor(...nodes) {
		super();
		this.elements(...nodes);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		for (const type of this._elements) ctx$1.analyze(type);
	}
	elements(...types) {
		this._elements.push(...types);
		return this;
	}
	toAst() {
		return typescript.default.factory.createTupleTypeNode(this._elements.map((t) => this.$type(t)));
	}
};

//#endregion
//#region src/ts-dsl/type/fromValue.ts
const fromValue = (input) => {
	if ((0, _hey_api_codegen_core.isNode)(input)) return input;
	if (input === null) return new TypeLiteralTsDsl(input);
	if (typeof input === "number" || typeof input === "boolean" || typeof input === "string") return new TypeLiteralTsDsl(input);
	if (input instanceof Array) return new TypeTupleTsDsl(...input.map((v) => fromValue(v)));
	if (typeof input === "object") {
		const obj = new TypeObjectTsDsl();
		for (const [key, val] of Object.entries(input)) {
			const type = fromValue(val);
			obj.prop(key, (p) => p.type(type));
		}
		return obj;
	}
	throw new Error(`$.type.fromValue(): Unsupported input type ${String(input)}`);
};

//#endregion
//#region src/ts-dsl/type/func.ts
const Mixed$6 = DocMixin(ParamMixin(TypeParamsMixin(TypeReturnsMixin(TsDsl))));
var TypeFuncTsDsl = class extends Mixed$6 {
	"~dsl" = "TypeFuncTsDsl";
	scope = "type";
	analyze(ctx$1) {
		super.analyze(ctx$1);
	}
	toAst() {
		const returns = this.$returns();
		if (returns === void 0) throw new Error("Missing return type in function type DSL");
		const node = typescript.default.factory.createFunctionTypeNode(this.$generics(), this.$params(), returns);
		return this.$docs(node);
	}
};

//#endregion
//#region src/ts-dsl/type/idx.ts
const Mixed$5 = TypeExprMixin(TsDsl);
var TypeIdxTsDsl = class extends Mixed$5 {
	"~dsl" = "TypeIdxTsDsl";
	scope = "type";
	_base;
	_index;
	constructor(base, index) {
		super();
		this.base(base);
		this.index(index);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._base);
		ctx$1.analyze(this._index);
	}
	base(base) {
		this._base = base;
		return this;
	}
	index(index) {
		this._index = index;
		return this;
	}
	toAst() {
		return typescript.default.factory.createIndexedAccessTypeNode(this.$type(this._base), this.$type(this._index));
	}
};
f.type.idx.set((...args) => new TypeIdxTsDsl(...args));

//#endregion
//#region src/ts-dsl/type/mapped.ts
const Mixed$4 = TsDsl;
var TypeMappedTsDsl = class extends Mixed$4 {
	"~dsl" = "TypeMappedTsDsl";
	scope = "type";
	questionToken;
	readonlyToken;
	_key;
	_type;
	constructor(name) {
		super();
		if (name) this.name.set(name);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.questionToken);
		ctx$1.analyze(this.readonlyToken);
		ctx$1.analyze(this._key);
		ctx$1.analyze(this._type);
	}
	/** Returns true when all required builder calls are present. */
	get isValid() {
		return this.missingRequiredCalls().length === 0;
	}
	/** Sets the key constraint: `[K in Constraint]` */
	key(type) {
		this._key = type;
		return this;
	}
	/** Removes `readonly` from the mapped members (`[K in X]-readonly`). */
	mutable() {
		this.readonlyToken = new TokenTsDsl().minus();
		return this;
	}
	/** Makes `[K in X]?:` optional. */
	optional() {
		this.questionToken = new TokenTsDsl().optional();
		return this;
	}
	/** Makes `[K in X]` readonly */
	readonly() {
		this.readonlyToken = new TokenTsDsl().readonly();
		return this;
	}
	/** Removes `?` from the mapped members (`[K in X]-?:`). */
	required() {
		this.questionToken = new TokenTsDsl().minus();
		return this;
	}
	/** Sets the mapped value type: `[K in X]: ValueType` */
	type(type) {
		this._type = type;
		return this;
	}
	toAst() {
		this.$validate();
		return typescript.default.factory.createMappedTypeNode(this.$node(this.readonlyToken), typescript.default.factory.createTypeParameterDeclaration(void 0, this.$node(this.name), this.$type(this._key), void 0), void 0, this.$node(this.questionToken), this.$type(this._type), void 0);
	}
	$validate() {
		const missing = this.missingRequiredCalls();
		if (missing.length === 0) return;
		const name = this.name.toString();
		throw new Error(`Mapped type${name ? ` "${name}"` : ""} missing ${missing.join(" and ")}`);
	}
	missingRequiredCalls() {
		const missing = [];
		if (!this._key) missing.push(".key()");
		if (!this._type) missing.push(".â€‹type()");
		return missing;
	}
};

//#endregion
//#region src/ts-dsl/type/operator.ts
const Mixed$3 = TsDsl;
/**
* Builds a TypeScript `TypeOperatorNode`, such as:
*
* - `keyof T`
* - `readonly U`
* - `unique V`
*
* This DSL provides both a generic `.operator()` API and convenient
* shorthand methods (`.keyof()`, `.readonly()`, `.unique()`).
*
* The node will throw during render if required fields are missing.
*/
var TypeOperatorTsDsl = class extends Mixed$3 {
	"~dsl" = "TypeOperatorTsDsl";
	scope = "type";
	_op;
	_type;
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._type);
	}
	/** Shorthand: builds `keyof T`. */
	keyof(type) {
		this.operator(typescript.default.SyntaxKind.KeyOfKeyword);
		this.type(type);
		return this;
	}
	/** Sets the operator explicitly. */
	operator(op) {
		this._op = op;
		return this;
	}
	/** Shorthand: builds `readonly T`. */
	readonly(type) {
		this.operator(typescript.default.SyntaxKind.ReadonlyKeyword);
		this.type(type);
		return this;
	}
	/** Sets the target type of the operator. */
	type(type) {
		this._type = type;
		return this;
	}
	/** Shorthand: builds `unique T`. */
	unique(type) {
		this.operator(typescript.default.SyntaxKind.UniqueKeyword);
		this.type(type);
		return this;
	}
	toAst() {
		this.$validate();
		return typescript.default.factory.createTypeOperatorNode(this._op, this.$type(this._type));
	}
	/** Throws if required fields are not set. */
	$validate() {
		const missing = this.missingRequiredCalls();
		if (missing.length === 0) return;
		throw new Error(`Type operator missing ${missing.join(" and ")}`);
	}
	missingRequiredCalls() {
		const missing = [];
		if (!this._op) missing.push(".operator()");
		if (!this._type) missing.push(".â€‹type()");
		return missing;
	}
};
f.type.operator.set((...args) => new TypeOperatorTsDsl(...args));

//#endregion
//#region src/ts-dsl/type/or.ts
const Mixed$2 = TsDsl;
var TypeOrTsDsl = class extends Mixed$2 {
	"~dsl" = "TypeOrTsDsl";
	scope = "type";
	_types = [];
	constructor(...nodes) {
		super();
		this.types(...nodes);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		for (const type of this._types) ctx$1.analyze(type);
	}
	types(...nodes) {
		this._types.push(...nodes.map((n) => (0, _hey_api_codegen_core.ref)(n)));
		return this;
	}
	toAst() {
		const flat = [];
		for (const node of this._types) {
			const type = this.$type(node);
			if (typescript.default.isUnionTypeNode(type)) flat.push(...type.types);
			else flat.push(type);
		}
		return typescript.default.factory.createUnionTypeNode(flat);
	}
};

//#endregion
//#region src/ts-dsl/type/query.ts
const Mixed$1 = TypeExprMixin(TsDsl);
var TypeQueryTsDsl = class extends Mixed$1 {
	"~dsl" = "TypeQueryTsDsl";
	scope = "type";
	_expr;
	constructor(expr) {
		super();
		this._expr = expr;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this._expr);
	}
	toAst() {
		const expr = this.$node(this._expr);
		return typescript.default.factory.createTypeQueryNode(expr);
	}
};
f.type.query.set((...args) => new TypeQueryTsDsl(...args));

//#endregion
//#region src/ts-dsl/type/template.ts
const Mixed = TsDsl;
var TypeTemplateTsDsl = class extends Mixed {
	"~dsl" = "TypeTemplateTsDsl";
	scope = "type";
	parts = [];
	constructor(value) {
		super();
		if (value !== void 0) this.add(value);
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		for (const part of this.parts) ctx$1.analyze(part);
	}
	/** Adds a raw string segment or embedded type expression. */
	add(part) {
		this.parts.push(part);
		return this;
	}
	toAst() {
		const parts = this.$node(this.parts);
		const normalized = [];
		for (let index = 0; index < parts.length; index++) {
			const current = parts[index];
			if (typeof current === "string") {
				let merged = current;
				while (index + 1 < parts.length && typeof parts[index + 1] === "string") {
					merged += parts[index + 1];
					index++;
				}
				normalized.push(merged);
			} else normalized.push(current);
		}
		if (normalized.length === 0 || typeof normalized[0] !== "string") normalized.unshift("");
		if (normalized.length === 1 && typeof normalized[0] === "string") return typescript.default.factory.createTemplateLiteralType(typescript.default.factory.createTemplateHead(normalized[0]), []);
		if (normalized.length === 2 && typeof normalized[0] === "string" && typeof normalized[1] !== "string") return typescript.default.factory.createTemplateLiteralType(typescript.default.factory.createTemplateHead(normalized[0]), [typescript.default.factory.createTemplateLiteralTypeSpan(normalized[1], typescript.default.factory.createTemplateTail(""))]);
		const head = typescript.default.factory.createTemplateHead(normalized.shift());
		const spans = [];
		while (normalized.length) {
			const type = normalized.shift();
			const next = typeof normalized[0] === "string" ? normalized.shift() : "";
			const isLast = normalized.length === 0;
			spans.push(typescript.default.factory.createTemplateLiteralTypeSpan(type, isLast ? typescript.default.factory.createTemplateTail(next) : typescript.default.factory.createTemplateMiddle(next)));
		}
		return typescript.default.factory.createTemplateLiteralType(head, spans);
	}
};

//#endregion
//#region src/ts-dsl/utils/lazy.ts
var LazyTsDsl = class extends TsDsl {
	"~dsl" = "LazyTsDsl";
	_thunk;
	constructor(thunk) {
		super();
		this._thunk = thunk;
	}
	analyze(ctx$1) {
		super.analyze(ctx$1);
		ctx$1.analyze(this.toResult());
	}
	toResult() {
		return this._thunk(ctx);
	}
	toAst() {
		return this.toResult().toAst();
	}
};

//#endregion
//#region src/ts-dsl/utils/render-utils.ts
const printer = typescript.default.createPrinter({
	newLine: typescript.default.NewLineKind.LineFeed,
	removeComments: false
});
const blankFile = typescript.default.createSourceFile("", "", typescript.default.ScriptTarget.ESNext, false, typescript.default.ScriptKind.TS);
/** Print a TypeScript node to a string. */
function astToString(node) {
	const result = printer.printNode(typescript.default.EmitHint.Unspecified, node, blankFile);
	try {
		/**
		* TypeScript Compiler API escapes unicode characters by default and there
		* is no way to disable this behavior
		* {@link https://github.com/microsoft/TypeScript/issues/36174}
		*/
		return result.replace(/\\u([0-9a-fA-F]{4})/g, (_, hex) => String.fromCharCode(Number.parseInt(hex, 16)));
	} catch {
		return result;
	}
}
const moduleSortKey = ({ file, fromFile, preferFileExtension, root }) => {
	const filePath = file.finalPath.split(node_path.default.sep).join("/");
	let modulePath = fromFile.finalPath.split(node_path.default.sep).join("/");
	if (fromFile.external && !node_path.default.isAbsolute(modulePath)) return [
		0,
		0,
		modulePath
	];
	if (!modulePath.startsWith(root.split(node_path.default.sep).join("/"))) return [
		1,
		0,
		modulePath
	];
	const rel = node_path.default.relative(node_path.default.dirname(filePath), node_path.default.dirname(modulePath)).split(node_path.default.sep).join("/");
	let parentCount;
	if (!rel.startsWith("..")) {
		modulePath = `./${rel ? `${rel}/` : ""}${fromFile.name}${fromFile.extension ?? ""}`;
		parentCount = 0;
	} else {
		modulePath = `${rel}/${fromFile.name}${fromFile.extension ?? ""}`;
		parentCount = rel.split(node_path.default.sep).filter((segment) => segment === "..").length;
	}
	if (modulePath.endsWith(".ts")) modulePath = modulePath.slice(0, -3);
	if (preferFileExtension) modulePath += preferFileExtension;
	else if (modulePath.endsWith("/index")) modulePath = modulePath.slice(0, -6);
	return [
		2,
		parentCount,
		modulePath
	];
};

//#endregion
//#region src/ts-dsl/utils/render.ts
function headerToLines(header) {
	if (!header) return [];
	const lines = [];
	if (typeof header === "string") {
		lines.push(...header.split(/\r?\n/));
		return lines;
	}
	for (const line of header) lines.push(...line.split(/\r?\n/));
	return lines;
}
var TypeScriptRenderer = class TypeScriptRenderer {
	/**
	* Function to generate a file header.
	*
	* @private
	*/
	_header;
	/**
	* Whether `export * from 'module'` should be used when possible instead of named exports.
	*
	* @private
	*/
	_preferExportAll;
	/**
	* Controls whether imports/exports include a file extension (e.g., '.ts' or '.js').
	*
	* @private
	*/
	_preferFileExtension;
	/**
	* Optional function to transform module specifiers.
	*
	* @private
	*/
	_resolveModuleName;
	constructor(args = {}) {
		this._header = args.header;
		this._preferExportAll = args.preferExportAll ?? false;
		this._preferFileExtension = args.preferFileExtension ?? "";
		this._resolveModuleName = args.resolveModuleName;
	}
	render(ctx$1) {
		const header = typeof this._header === "function" ? this._header(ctx$1) : this._header;
		return TypeScriptRenderer.astToString({
			exports: this.getExports(ctx$1),
			exportsOptions: { preferExportAll: this._preferExportAll },
			header,
			imports: this.getImports(ctx$1),
			nodes: ctx$1.file.nodes
		});
	}
	supports(ctx$1) {
		return ctx$1.file.language === "typescript";
	}
	static astToString(args) {
		let text = "";
		for (const header of headerToLines(args.header)) text += `${header}\n`;
		let imports = "";
		for (const group of args.imports ?? []) {
			if (imports) imports += "\n";
			for (const imp of group) imports += `${astToString(TypeScriptRenderer.toImportAst(imp))}\n`;
		}
		text = `${text}${text && imports ? "\n" : ""}${imports}`;
		let nodes = "";
		for (const node of args.nodes ?? []) {
			if (nodes) nodes += "\n";
			nodes += `${astToString(node.toAst())}\n`;
		}
		text = `${text}${text && nodes ? "\n" : ""}${nodes}`;
		let exports$1 = "";
		for (const group of args.exports ?? []) {
			if (!exports$1 && nodes || exports$1) exports$1 += "\n";
			for (const exp of group) exports$1 += `${astToString(TypeScriptRenderer.toExportAst(exp, args.exportsOptions))}\n`;
		}
		text = `${text}${text && exports$1 ? "\n" : ""}${exports$1}`;
		if (args.trailingNewline === false && text.endsWith("\n")) text = text.slice(0, -1);
		return text;
	}
	static toExportAst(group, options) {
		const specifiers = group.exports.map((exp) => {
			return typescript.default.factory.createExportSpecifier(exp.isTypeOnly, exp.sourceName !== exp.exportedName ? $.id(exp.sourceName).toAst() : void 0, $.id(exp.exportedName).toAst());
		});
		const exportClause = group.namespaceExport ? typescript.default.factory.createNamespaceExport($.id(group.namespaceExport).toAst()) : (!group.canExportAll || !options?.preferExportAll) && specifiers.length ? typescript.default.factory.createNamedExports(specifiers) : void 0;
		return typescript.default.factory.createExportDeclaration(void 0, group.isTypeOnly, exportClause, $.literal(group.modulePath).toAst());
	}
	static toImportAst(group) {
		const specifiers = group.imports.map((imp) => {
			return typescript.default.factory.createImportSpecifier(imp.isTypeOnly, imp.sourceName !== imp.localName ? $.id(imp.sourceName).toAst() : void 0, $.id(imp.localName).toAst());
		});
		const importClause = typescript.default.factory.createImportClause(group.isTypeOnly, group.kind === "default" ? $.id(group.localName ?? "").toAst() : void 0, group.kind === "namespace" ? typescript.default.factory.createNamespaceImport($.id(group.localName ?? "").toAst()) : specifiers.length > 0 ? typescript.default.factory.createNamedImports(specifiers) : void 0);
		return typescript.default.factory.createImportDeclaration(void 0, importClause, $.literal(group.modulePath).toAst());
	}
	getExports(ctx$1) {
		const groups = /* @__PURE__ */ new Map();
		for (const exp of ctx$1.file.exports) {
			const sortKey = moduleSortKey({
				file: ctx$1.file,
				fromFile: exp.from,
				preferFileExtension: this._preferFileExtension,
				root: ctx$1.project.root
			});
			const modulePath = this._resolveModuleName?.(sortKey[2]) ?? sortKey[2];
			const [groupIndex] = sortKey;
			if (!groups.has(groupIndex)) groups.set(groupIndex, /* @__PURE__ */ new Map());
			const moduleMap = groups.get(groupIndex);
			if (!moduleMap.has(modulePath)) moduleMap.set(modulePath, {
				group: {
					canExportAll: exp.canExportAll,
					exports: exp.exports,
					isTypeOnly: exp.isTypeOnly,
					modulePath,
					namespaceExport: exp.namespaceExport
				},
				sortKey
			});
		}
		return Array.from(groups.entries()).sort((a, b) => a[0] - b[0]).map(([, moduleMap]) => {
			const entries = Array.from(moduleMap.values());
			entries.sort((a, b) => {
				const d = a.sortKey[1] - b.sortKey[1];
				return d !== 0 ? d : a.group.modulePath.localeCompare(b.group.modulePath);
			});
			return entries.map((e) => {
				const group = e.group;
				if (group.namespaceExport) group.exports = [];
				else {
					if (!group.exports.find((exp) => !exp.isTypeOnly)) {
						group.isTypeOnly = true;
						for (const exp of group.exports) exp.isTypeOnly = false;
					}
					group.exports.sort((a, b) => a.exportedName.localeCompare(b.exportedName));
				}
				return group;
			});
		});
	}
	getImports(ctx$1) {
		const groups = /* @__PURE__ */ new Map();
		for (const imp of ctx$1.file.imports) {
			const sortKey = moduleSortKey({
				file: ctx$1.file,
				fromFile: imp.from,
				preferFileExtension: this._preferFileExtension,
				root: ctx$1.project.root
			});
			const modulePath = this._resolveModuleName?.(sortKey[2]) ?? sortKey[2];
			const [groupIndex] = sortKey;
			if (!groups.has(groupIndex)) groups.set(groupIndex, /* @__PURE__ */ new Map());
			const moduleMap = groups.get(groupIndex);
			if (!moduleMap.has(modulePath)) moduleMap.set(modulePath, {
				group: {
					imports: [],
					isTypeOnly: false,
					kind: imp.kind,
					modulePath
				},
				sortKey
			});
			const group = moduleMap.get(modulePath).group;
			if (imp.kind !== "named") {
				group.isTypeOnly = imp.isTypeOnly;
				group.kind = imp.kind;
				group.localName = imp.localName;
			} else group.imports.push(...imp.imports);
		}
		return Array.from(groups.entries()).sort((a, b) => a[0] - b[0]).map(([, moduleMap]) => {
			const entries = Array.from(moduleMap.values());
			entries.sort((a, b) => {
				const d = a.sortKey[1] - b.sortKey[1];
				return d !== 0 ? d : a.group.modulePath.localeCompare(b.group.modulePath);
			});
			return entries.map((e) => {
				const group = e.group;
				if (group.kind === "namespace") group.imports = [];
				else {
					if (!group.imports.find((imp) => !imp.isTypeOnly)) {
						group.isTypeOnly = true;
						for (const imp of group.imports) imp.isTypeOnly = false;
					}
					group.imports.sort((a, b) => a.localName.localeCompare(b.localName));
				}
				return group;
			});
		});
	}
};

//#endregion
//#region src/ts-dsl/index.ts
const tsDsl = {
	array: (...args) => new ArrayTsDsl(...args),
	as: (...args) => new AsTsDsl(...args),
	attr: (...args) => new AttrTsDsl(...args),
	await: (...args) => new AwaitTsDsl(...args),
	binary: (...args) => new BinaryTsDsl(...args),
	block: (...args) => new BlockTsDsl(...args),
	call: (...args) => new CallTsDsl(...args),
	class: (...args) => new ClassTsDsl(...args),
	const: (...args) => new VarTsDsl(...args).const(),
	decorator: (...args) => new DecoratorTsDsl(...args),
	doc: (...args) => new DocTsDsl(...args),
	enum: (...args) => new EnumTsDsl(...args),
	expr: (...args) => new ExprTsDsl(...args),
	field: (...args) => new FieldTsDsl(...args),
	fromValue: (...args) => fromValue$1(...args),
	func: ((nameOrFn, fn) => {
		if (nameOrFn === void 0) return new FuncTsDsl();
		if (typeof nameOrFn !== "string") return new FuncTsDsl(nameOrFn);
		if (fn === void 0) return new FuncTsDsl(nameOrFn);
		return new FuncTsDsl(nameOrFn, fn);
	}),
	getter: (...args) => new GetterTsDsl(...args),
	hint: (...args) => new HintTsDsl(...args),
	id: (...args) => new IdTsDsl(...args),
	if: (...args) => new IfTsDsl(...args),
	init: (...args) => new InitTsDsl(...args),
	lazy: (...args) => new LazyTsDsl(...args),
	let: (...args) => new VarTsDsl(...args).let(),
	literal: (...args) => new LiteralTsDsl(...args),
	member: (...args) => new EnumMemberTsDsl(...args),
	method: (...args) => new MethodTsDsl(...args),
	neg: (...args) => new PrefixTsDsl(...args).neg(),
	new: (...args) => new NewTsDsl(...args),
	newline: (...args) => new NewlineTsDsl(...args),
	not: (...args) => new PrefixTsDsl(...args).not(),
	note: (...args) => new NoteTsDsl(...args),
	object: (...args) => new ObjectTsDsl(...args),
	param: (...args) => new ParamTsDsl(...args),
	pattern: (...args) => new PatternTsDsl(...args),
	prefix: (...args) => new PrefixTsDsl(...args),
	prop: (...args) => new ObjectPropTsDsl(...args),
	regexp: (...args) => new RegExpTsDsl(...args),
	return: (...args) => new ReturnTsDsl(...args),
	setter: (...args) => new SetterTsDsl(...args),
	stmt: (...args) => new StmtTsDsl(...args),
	template: (...args) => new TemplateTsDsl(...args),
	ternary: (...args) => new TernaryTsDsl(...args),
	throw: (...args) => new ThrowTsDsl(...args),
	token: (...args) => new TokenTsDsl(...args),
	try: (...args) => new TryTsDsl(...args),
	type: Object.assign((...args) => new TypeExprTsDsl(...args), {
		alias: (...args) => new TypeAliasTsDsl(...args),
		and: (...args) => new TypeAndTsDsl(...args),
		attr: (...args) => new TypeAttrTsDsl(...args),
		expr: (...args) => new TypeExprTsDsl(...args),
		fromValue: (...args) => fromValue(...args),
		func: (...args) => new TypeFuncTsDsl(...args),
		idx: (...args) => new TypeIdxTsDsl(...args),
		literal: (...args) => new TypeLiteralTsDsl(...args),
		mapped: (...args) => new TypeMappedTsDsl(...args),
		object: (...args) => new TypeObjectTsDsl(...args),
		operator: (...args) => new TypeOperatorTsDsl(...args),
		or: (...args) => new TypeOrTsDsl(...args),
		param: (...args) => new TypeParamTsDsl(...args),
		query: (...args) => new TypeQueryTsDsl(...args),
		template: (...args) => new TypeTemplateTsDsl(...args),
		tuple: (...args) => new TypeTupleTsDsl(...args)
	}),
	typeofExpr: (...args) => new TypeOfExprTsDsl(...args),
	var: (...args) => new VarTsDsl(...args)
};
const $ = Object.assign((...args) => new ExprTsDsl(...args), tsDsl);

//#endregion
//#region src/utils/naming/naming.ts
const uppercaseRegExp = /[\p{Lu}]/u;
const lowercaseRegExp = /[\p{Ll}]/u;
const identifierRegExp = /([\p{Alpha}\p{N}_]|$)/u;
const separatorsRegExp = /[_.$+:\- `\\[\](){}\\/]+/;
const leadingSeparatorsRegExp = /* @__PURE__ */ new RegExp(`^${separatorsRegExp.source}`);
const separatorsAndIdentifierRegExp = new RegExp(`${separatorsRegExp.source}${identifierRegExp.source}`, "gu");
const numbersAndIdentifierRegExp = new RegExp(`\\d+${identifierRegExp.source}`, "gu");
const preserveCase = (value, casing) => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;
	let isLastLastCharPreserved = false;
	const separator = casing === "snake_case" || casing === "SCREAMING_SNAKE_CASE" ? "_" : "-";
	for (let index = 0; index < value.length; index++) {
		const character = value[index];
		isLastLastCharPreserved = index > 2 ? value[index - 3] === separator : true;
		let nextIndex = index + 1;
		let nextCharacter = value[nextIndex];
		separatorsRegExp.lastIndex = 0;
		while (nextCharacter && separatorsRegExp.test(nextCharacter)) {
			nextIndex += 1;
			nextCharacter = value[nextIndex];
		}
		const isSeparatorBeforeNextCharacter = nextIndex !== index + 1;
		lowercaseRegExp.lastIndex = 0;
		uppercaseRegExp.lastIndex = 0;
		if (uppercaseRegExp.test(character) && (isLastCharLower || nextCharacter && !isSeparatorBeforeNextCharacter && nextCharacter !== "s" && lowercaseRegExp.test(nextCharacter))) {
			value = `${value.slice(0, index)}${separator}${value.slice(index)}`;
			index++;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharLower = false;
			isLastCharUpper = true;
		} else if (isLastCharUpper && isLastLastCharUpper && lowercaseRegExp.test(character) && !isLastLastCharPreserved && !(character === "s" && (!nextCharacter || nextCharacter.toLocaleLowerCase() !== nextCharacter))) {
			value = `${value.slice(0, index - 1)}${separator}${value.slice(index - 1)}`;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharLower = true;
			isLastCharUpper = false;
		} else {
			const characterLower = character.toLocaleLowerCase();
			const characterUpper = character.toLocaleUpperCase();
			isLastLastCharUpper = isLastCharUpper;
			isLastCharLower = characterLower === character && characterUpper !== character;
			isLastCharUpper = characterUpper === character && characterLower !== character;
		}
	}
	return value;
};
/**
* Convert a string to the specified casing.
*
* @param value - The string to convert
* @param casing - The target casing
* @param options - Additional options
* @returns The converted string
*/
const toCase = (value, casing, options = {}) => {
	const stripLeadingSeparators = options.stripLeadingSeparators ?? true;
	let result = value.trim();
	if (!result.length || !casing || casing === "preserve") return result;
	if (result.length === 1) {
		separatorsRegExp.lastIndex = 0;
		if (separatorsRegExp.test(result)) return "";
		return casing === "PascalCase" || casing === "SCREAMING_SNAKE_CASE" ? result.toLocaleUpperCase() : result.toLocaleLowerCase();
	}
	if (result !== result.toLocaleLowerCase()) result = preserveCase(result, casing);
	if (stripLeadingSeparators || result[0] !== value[0]) result = result.replace(leadingSeparatorsRegExp, "");
	result = casing === "SCREAMING_SNAKE_CASE" ? result.toLocaleUpperCase() : result.toLocaleLowerCase();
	if (casing === "PascalCase") result = `${result.charAt(0).toLocaleUpperCase()}${result.slice(1)}`;
	if (casing === "snake_case" || casing === "SCREAMING_SNAKE_CASE") {
		result = result.replaceAll(separatorsAndIdentifierRegExp, (match, identifier, offset) => {
			if (offset === 0 && !stripLeadingSeparators) return match;
			return `_${identifier}`;
		});
		if (result[result.length - 1] === "_") result = result.slice(0, result.length - 1);
	} else {
		separatorsAndIdentifierRegExp.lastIndex = 0;
		numbersAndIdentifierRegExp.lastIndex = 0;
		result = result.replaceAll(numbersAndIdentifierRegExp, (match, _, offset) => {
			if ([
				"_",
				"-",
				"."
			].includes(result.charAt(offset + match.length))) return match;
			return match.toLocaleUpperCase();
		});
		result = result.replaceAll(separatorsAndIdentifierRegExp, (match, identifier, offset) => {
			if (offset === 0 && !stripLeadingSeparators && match[0] && value.startsWith(match[0])) return match;
			return identifier.toLocaleUpperCase();
		});
	}
	return result;
};
/**
* Apply naming configuration to a value.
*
* Casing is applied first, then transformation.
*/
function applyNaming(value, config) {
	let result = value;
	const casing = config.casing ?? config.case;
	if (config.name) if (typeof config.name === "function") result = config.name(result);
	else {
		const separator = !casing || casing === "preserve" ? "" : "-";
		result = config.name.replace("{{name}}", `${separator}${result}${separator}`);
	}
	return toCase(result, casing);
}

//#endregion
//#region src/plugins/@hey-api/sdk/shared/class.ts
const createRegistryClass = ({ plugin, sdkSymbol, symbol }) => {
	const symbolDefaultKey = plugin.symbol("defaultKey");
	const symbolInstances = plugin.symbol("instances");
	return $.class(symbol).generic("T").field(symbolDefaultKey, (f$1) => f$1.private().readonly().assign($.literal("default"))).newline().field(symbolInstances, (f$1) => f$1.private().readonly().type($.type("Map").generics("string", "T")).assign($.new("Map"))).newline().method("get", (m) => m.returns("T").param("key", (p) => p.type("string").optional()).do($.const("instance").assign($("this").attr(symbolInstances).attr("get").call($("key").coalesce($("this").attr(symbolDefaultKey)))), $.if($.not("instance")).do($.throw("Error").message($.template("No SDK client found. Create one with \"new ").add(sdkSymbol).add("()\" to fix this error."))), $.return("instance"))).newline().method("set", (m) => m.returns("void").param("value", (p) => p.type("T")).param("key", (p) => p.type("string").optional()).do($("this").attr(symbolInstances).attr("set").call($("key").coalesce($("this").attr(symbolDefaultKey)), "value")));
};
const createClientClass = ({ plugin, symbol }) => {
	const symClient = plugin.getSymbol({ category: "client" });
	const optionalClient = Boolean(plugin.config.client && symClient);
	const symbolClient = plugin.external("client.Client");
	return $.class(symbol).field("client", (f$1) => f$1.protected().type(symbolClient)).newline().init((i) => i.param("args", (p) => p.optional(optionalClient).type($.type.object().prop("client", (p$1) => p$1.optional(optionalClient).type(symbolClient)))).do($("this").attr("client").assign($("args").attr("client").optional(optionalClient).$if(optionalClient, (a) => a.coalesce(symClient)))));
};

//#endregion
//#region src/plugins/@hey-api/sdk/shared/constants.ts
const nuxtTypeComposable = "TComposable";
const nuxtTypeDefault = "DefaultT";
const nuxtTypeResponse = "ResT";

//#endregion
//#region src/plugins/@hey-api/sdk/shared/auth.ts
const securitySchemeObjectToAuthObject = ({ securitySchemeObject }) => {
	if (securitySchemeObject.type === "openIdConnect") return {
		scheme: "bearer",
		type: "http"
	};
	if (securitySchemeObject.type === "oauth2") {
		if (securitySchemeObject.flows.password || securitySchemeObject.flows.authorizationCode || securitySchemeObject.flows.clientCredentials || securitySchemeObject.flows.implicit) return {
			scheme: "bearer",
			type: "http"
		};
		return;
	}
	if (securitySchemeObject.type === "apiKey") {
		if (securitySchemeObject.in === "header") return {
			name: securitySchemeObject.name,
			type: "apiKey"
		};
		if (securitySchemeObject.in === "query" || securitySchemeObject.in == "cookie") return {
			in: securitySchemeObject.in,
			name: securitySchemeObject.name,
			type: "apiKey"
		};
		return;
	}
	if (securitySchemeObject.type === "http") {
		const scheme = securitySchemeObject.scheme.toLowerCase();
		if (scheme === "bearer" || scheme === "basic") return {
			scheme,
			type: "http"
		};
		return;
	}
};
const operationAuth = ({ operation, plugin }) => {
	if (!operation.security || !plugin.config.auth) return [];
	const auth = [];
	for (const securitySchemeObject of operation.security) {
		const authObject = securitySchemeObjectToAuthObject({ securitySchemeObject });
		if (authObject) auth.push(authObject);
		else if (securitySchemeObject.type !== "mutualTLS") console.warn(`â—ï¸ SDK warning: unsupported security scheme. Please open an issue if you'd like it added https://github.com/hey-api/openapi-ts/issues\n${JSON.stringify(securitySchemeObject, null, 2)}`);
	}
	return auth;
};

//#endregion
//#region src/utils/ref.ts
const jsonPointerSlash = /~1/g;
const jsonPointerTilde = /~0/g;
/**
* Returns the reusable component name from `$ref`.
*/
const refToName = ($ref) => {
	const path$10 = jsonPointerToPath($ref);
	const name = path$10[path$10.length - 1];
	return decodeURI(name);
};
/**
* Encodes a path segment for use in a JSON Pointer (RFC 6901).
*
* - Replaces all '~' with '~0'.
* - Replaces all '/' with '~1'.
*
* This ensures that path segments containing these characters are safely
* represented in JSON Pointer strings.
*
* @param segment - The path segment (string or number) to encode.
* @returns The encoded segment as a string.
*/
const encodeJsonPointerSegment = (segment) => String(segment).replace(/~/g, "~0").replace(/\//g, "~1");
/**
* Converts a JSON Pointer string (RFC 6901) to an array of path segments.
*
* - Removes the leading '#' if present.
* - Splits the pointer on '/'.
* - Decodes '~1' to '/' and '~0' to '~' in each segment.
* - Returns an empty array for the root pointer ('#' or '').
*
* @param pointer - The JSON Pointer string to convert (e.g., '#/components/schemas/Foo').
* @returns An array of decoded path segments.
*/
const jsonPointerToPath = (pointer) => {
	let clean = pointer.trim();
	if (clean.startsWith("#")) clean = clean.slice(1);
	if (clean.startsWith("/")) clean = clean.slice(1);
	if (!clean) return [];
	return clean.split("/").map((part) => part.replace(jsonPointerSlash, "/").replace(jsonPointerTilde, "~"));
};
/**
* Normalizes a JSON Pointer string to a canonical form.
*
* - Ensures the pointer starts with '#'.
* - Removes trailing slashes (except for root).
* - Collapses multiple consecutive slashes into one.
* - Trims whitespace from the input.
*
* @param pointer - The JSON Pointer string to normalize.
* @returns The normalized JSON Pointer string.
*/
const normalizeJsonPointer = (pointer) => {
	let normalized = pointer.trim();
	if (!normalized.startsWith("#")) normalized = `#${normalized}`;
	if (normalized.length > 1 && normalized.endsWith("/")) normalized = normalized.slice(0, -1);
	normalized = normalized.replace(/\/+/g, "/");
	return normalized;
};
/**
* Encode path as JSON Pointer (RFC 6901).
*
* @param path
* @returns
*/
const pathToJsonPointer = (path$10) => {
	const segments = path$10.map(encodeJsonPointerSegment).join("/");
	return "#" + (segments ? `/${segments}` : "");
};
/**
* Checks if a $ref points to a top-level component (not a deep path reference).
*
* Top-level component references:
* - OpenAPI 3.x: #/components/{type}/{name} (3 segments)
* - OpenAPI 2.0: #/definitions/{name} (2 segments)
*
* Deep path references (4+ segments for 3.x, 3+ for 2.0) should be inlined
* because they don't have corresponding registered symbols.
*
* @param $ref - The $ref string to check
* @returns true if the ref points to a top-level component, false otherwise
*/
const isTopLevelComponentRef = ($ref) => {
	const path$10 = jsonPointerToPath($ref);
	if (path$10[0] === "components") return path$10.length === 3;
	if (path$10[0] === "definitions") return path$10.length === 2;
	return false;
};
const resolveRef = ({ $ref, spec }) => {
	const path$10 = jsonPointerToPath(decodeURI($ref));
	let current = spec;
	for (const part of path$10) {
		const segment = part;
		if (current[segment] === void 0) throw new Error(`Reference not found: ${$ref}`);
		current = current[segment];
	}
	return current;
};

//#endregion
//#region src/plugins/@hey-api/sdk/shared/signature.ts
/**
* Collects and resolves all operation parameters for flattened SDK signatures.
* - Prefixes all conflicting names with their location (e.g. path_foo, query_foo)
* - Returns a flat map of resolved parameter names to their metadata
*/
function getSignatureParameters({ operation }) {
	const locations = [
		"header",
		"path",
		"query"
	];
	const nameToLocations = {};
	const addParameter = (name, location) => {
		if (!nameToLocations[name]) nameToLocations[name] = /* @__PURE__ */ new Set();
		nameToLocations[name].add(location);
	};
	for (const location of locations) {
		const parameters = operation.parameters?.[location];
		if (parameters) for (const key in parameters) {
			const parameter = parameters[key];
			addParameter(parameter.name, location);
		}
	}
	if (operation.body) if (!operation.body.schema.logicalOperator && operation.body.schema.type === "object" && operation.body.schema.properties) {
		const properties = operation.body.schema.properties;
		for (const key in properties) addParameter(key, "body");
	} else if (operation.body.schema.$ref) addParameter(toCase(refToName(operation.body.schema.$ref), "camelCase"), "body");
	else addParameter("body", "body");
	const conflicts = /* @__PURE__ */ new Set();
	for (const name in nameToLocations) if (nameToLocations[name].size > 1) conflicts.add(name);
	const signatureParameters = {};
	const fields = [];
	for (const location of locations) {
		const parameters = operation.parameters?.[location];
		if (parameters) for (const key in parameters) {
			const parameter = parameters[key];
			const originalName = parameter.name;
			const name = conflicts.has(originalName) ? `${location}_${originalName}` : originalName;
			const signatureParameter = {
				isRequired: parameter.required ?? false,
				name,
				schema: parameter.schema
			};
			if (name !== originalName) signatureParameter.originalName = originalName;
			signatureParameters[name] = signatureParameter;
			fields.push({
				in: location === "header" ? "headers" : location,
				key: name,
				...name !== originalName ? { map: originalName } : {}
			});
		}
	}
	if (operation.body) {
		const location = "body";
		if (!operation.body.schema.logicalOperator && operation.body.schema.type === "object" && operation.body.schema.properties) {
			const properties = operation.body.schema.properties;
			for (const originalName in properties) {
				const property = properties[originalName];
				const name = conflicts.has(originalName) ? `${location}_${originalName}` : originalName;
				const signatureParameter = {
					isRequired: property.required?.includes(originalName) ?? false,
					name,
					schema: property
				};
				if (name !== originalName) signatureParameter.originalName = originalName;
				signatureParameters[name] = signatureParameter;
				fields.push({
					in: location,
					key: name,
					...name !== originalName ? { map: originalName } : {}
				});
			}
		} else if (operation.body.schema.$ref) {
			const originalName = toCase(refToName(operation.body.schema.$ref), "camelCase");
			const name = conflicts.has(originalName) ? `${location}_${originalName}` : originalName;
			const signatureParameter = {
				isRequired: operation.body.required ?? false,
				name,
				schema: operation.body.schema
			};
			if (name !== originalName) signatureParameter.originalName = originalName;
			signatureParameters[name] = signatureParameter;
			fields.push({
				key: name,
				map: "body"
			});
		} else {
			signatureParameters.body = {
				isRequired: operation.body.required ?? false,
				name: "body",
				schema: operation.body.schema
			};
			fields.push({
				key: "body",
				map: "body"
			});
		}
	}
	if (!Object.keys(signatureParameters).length) return;
	return {
		fields,
		parameters: signatureParameters
	};
}

//#endregion
//#region src/plugins/@hey-api/sdk/shared/validator.ts
const createRequestValidator = ({ operation, plugin }) => {
	if (!plugin.config.validator.request) return;
	const validator = plugin.getPluginOrThrow(plugin.config.validator.request);
	if (!validator.api.createRequestValidator) return;
	return validator.api.createRequestValidator({
		operation,
		plugin: validator
	});
};
const createResponseValidator = ({ operation, plugin }) => {
	if (!plugin.config.validator.response) return;
	const validator = plugin.getPluginOrThrow(plugin.config.validator.response);
	if (!validator.api.createResponseValidator) return;
	return validator.api.createResponseValidator({
		operation,
		plugin: validator
	});
};

//#endregion
//#region src/plugins/@hey-api/sdk/shared/operation.ts
/** TODO: needs complete refactor */
const operationOptionsType = ({ isDataAllowed = true, operation, plugin, throwOnError }) => {
	const isNuxtClient = getClientPlugin(plugin.context.config).name === "@hey-api/client-nuxt";
	const symbolDataType = isDataAllowed ? plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tool: "typescript"
	}) : void 0;
	const symbolOptions = plugin.referenceSymbol({
		category: "type",
		resource: "client-options",
		tool: "sdk"
	});
	if (isNuxtClient) {
		const symbolResponseType = plugin.querySymbol({
			category: "type",
			resource: "operation",
			resourceId: operation.id,
			role: "response"
		});
		return $.type(symbolOptions).generic(nuxtTypeComposable).generic(isDataAllowed ? symbolDataType ?? "unknown" : "never").generic(symbolResponseType ?? "unknown").generic(nuxtTypeDefault);
	}
	if (throwOnError) return $.type(symbolOptions).generic(isDataAllowed ? symbolDataType ?? "unknown" : "never").generic(throwOnError);
	return $.type(symbolOptions).$if(!isDataAllowed || symbolDataType, (t) => t.generic(isDataAllowed ? symbolDataType : "never"));
};
function operationParameters({ isRequiredOptions, operation, plugin }) {
	const result = {
		argNames: [],
		fields: [],
		parameters: []
	};
	const pluginTypeScript = plugin.getPluginOrThrow("@hey-api/typescript");
	const isNuxtClient = getClientPlugin(plugin.context.config).name === "@hey-api/client-nuxt";
	if (plugin.config.paramsStructure === "flat") {
		const signature = getSignatureParameters({
			operation,
			plugin
		});
		const flatParams = $.type.object();
		if (signature) {
			let isParametersRequired = false;
			for (const key in signature.parameters) {
				const parameter = signature.parameters[key];
				if (parameter.isRequired) isParametersRequired = true;
				flatParams.prop(parameter.name, (p) => p.required(parameter.isRequired).type(pluginTypeScript.api.schemaToType({
					plugin: pluginTypeScript,
					schema: parameter.schema,
					state: (0, _hey_api_codegen_core.refs)({ path: [] })
				})));
			}
			result.argNames.push("parameters");
			for (const field of signature.fields) result.fields.push(field);
			result.parameters.push($.param("parameters", (p) => p.required(isParametersRequired).type(flatParams)));
		}
	}
	result.parameters.push($.param("options", (p) => p.required(isRequiredOptions).type(operationOptionsType({
		isDataAllowed: plugin.config.paramsStructure === "grouped",
		operation,
		plugin,
		throwOnError: isNuxtClient ? void 0 : "ThrowOnError"
	}))));
	return result;
}
/**
* Infers `responseType` value from provided response content type. This is
* an adapted version of `getParseAs()` from the Fetch API client.
*
* From Axios documentation:
* `responseType` indicates the type of data that the server will respond with
* options are: 'arraybuffer', 'document', 'json', 'text', 'stream'
* browser only: 'blob'
*/
const getResponseType = (contentType) => {
	if (!contentType) return;
	const cleanContent = contentType.split(";")[0]?.trim();
	if (!cleanContent) return;
	if (cleanContent.startsWith("application/json") || cleanContent.endsWith("+json")) return "json";
	if ([
		"application/",
		"audio/",
		"image/",
		"video/"
	].some((type) => cleanContent.startsWith(type))) return "blob";
	if (cleanContent.startsWith("text/")) return "text";
};
function operationStatements({ isRequiredOptions, opParameters, operation, plugin }) {
	const client = getClientPlugin(plugin.context.config);
	const isNuxtClient = client.name === "@hey-api/client-nuxt";
	const symbolResponseType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: isNuxtClient ? "response" : "responses"
	});
	const symbolErrorType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: isNuxtClient ? "error" : "errors"
	});
	const reqOptions = $.object();
	if (operation.body) {
		const isBinaryFormat = operation.body.schema?.format === "binary";
		switch (operation.body.type) {
			case "form-data": {
				const symbol = plugin.external("client.formDataBodySerializer");
				reqOptions.spread(symbol);
				break;
			}
			case "json":
				if (isBinaryFormat) reqOptions.prop("bodySerializer", $.literal(null));
				break;
			case "text":
			case "octet-stream":
				reqOptions.prop("bodySerializer", $.literal(null));
				break;
			case "url-search-params": {
				const symbol = plugin.external("client.urlSearchParamsBodySerializer");
				reqOptions.spread(symbol);
				break;
			}
			default:
				if (isBinaryFormat) reqOptions.prop("bodySerializer", $.literal(null));
				break;
		}
	}
	const paramSerializers = $.object();
	for (const name in operation.parameters?.query) {
		const parameter = operation.parameters.query[name];
		if (parameter.schema.type === "array" || parameter.schema.type === "tuple") {
			if (parameter.style !== "form" || !parameter.explode) paramSerializers.prop(parameter.name, $.object().prop("array", $.object().$if(parameter.explode === false, (o) => o.prop("explode", $.literal(parameter.explode))).$if(parameter.style !== "form", (o) => o.prop("style", $.literal(parameter.style)))));
		} else if (parameter.schema.type === "object") {
			if (parameter.style !== "deepObject" || !parameter.explode) paramSerializers.prop(parameter.name, $.object().prop("object", $.object().$if(parameter.explode === false, (o) => o.prop("explode", $.literal(parameter.explode))).$if(parameter.style !== "deepObject", (o) => o.prop("style", $.literal(parameter.style)))));
		}
	}
	if (paramSerializers.hasProps()) reqOptions.prop("querySerializer", $.object().prop("parameters", paramSerializers));
	const requestValidator = createRequestValidator({
		operation,
		plugin
	});
	const responseValidator = createResponseValidator({
		operation,
		plugin
	});
	if (requestValidator) reqOptions.prop("requestValidator", requestValidator.arrow());
	if (plugin.config.transformer) {
		const query = {
			category: "transform",
			resource: "operation",
			resourceId: operation.id,
			role: "response"
		};
		if (plugin.isSymbolRegistered(query)) {
			const ref$41 = plugin.referenceSymbol(query);
			reqOptions.prop("responseTransformer", $(ref$41));
		}
	}
	let hasServerSentEvents = false;
	let responseTypeValue;
	for (const statusCode in operation.responses) {
		const response = operation.responses[statusCode];
		if (!responseTypeValue && client.name === "@hey-api/client-axios") {
			if (statusCodeToGroup({ statusCode }) === "2XX") {
				responseTypeValue = getResponseType(response.mediaType);
				if (responseTypeValue) reqOptions.prop("responseType", $.literal(responseTypeValue));
			}
		}
		if (response.mediaType === "text/event-stream") hasServerSentEvents = true;
	}
	if (responseValidator) reqOptions.prop("responseValidator", responseValidator.arrow());
	if (plugin.config.responseStyle === "data") reqOptions.prop("responseStyle", $.literal(plugin.config.responseStyle));
	const auth = operationAuth({
		context: plugin.context,
		operation,
		plugin
	});
	if (auth.length) reqOptions.prop("security", $.fromValue(auth));
	reqOptions.prop("url", $.literal(operation.path));
	reqOptions.spread("options");
	const statements = [];
	const hasParams = opParameters.argNames.length;
	if (hasParams) {
		const args = [];
		const config = [];
		for (const argName of opParameters.argNames) args.push($(argName));
		for (const field of opParameters.fields) {
			const shape = $.object();
			if ("in" in field) shape.prop("in", $.literal(field.in));
			if ("key" in field) {
				if (field.key) shape.prop("key", $.literal(field.key));
				if (field.map) shape.prop("map", $.literal(field.map));
			}
			config.push(shape);
		}
		const symbol = plugin.external("client.buildClientParams");
		statements.push($.const("params").assign($(symbol).call($.array(...args), $.array($.object().prop("args", $.array(...config))))));
		reqOptions.spread("params");
	}
	if (operation.body) {
		const parameterContentType = operation.parameters?.header?.["content-type"];
		if (!Boolean(parameterContentType?.required)) {
			const headers = $.object().pretty().prop(parameterContentType?.name ?? "Content-Type", $.literal(operation.body.type === "form-data" ? null : operation.body.mediaType)).spread($("options").attr("headers").required(isRequiredOptions));
			if (hasParams) headers.spread($("params").attr("headers"));
			reqOptions.prop("headers", headers);
		}
	}
	const symbolClient = plugin.config.client ? plugin.getSymbol({ category: "client" }) : void 0;
	let clientExpression;
	const optionsClient = $("options").attr("client").required(isRequiredOptions);
	if (isInstance(plugin)) clientExpression = optionsClient.coalesce($("this").attr("client"));
	else if (symbolClient) clientExpression = optionsClient.coalesce(symbolClient);
	else clientExpression = optionsClient;
	let functionName = hasServerSentEvents ? clientExpression.attr("sse") : clientExpression;
	functionName = functionName.attr(operation.method);
	statements.push($.return(functionName.call(reqOptions).$if(isNuxtClient, (f$1) => f$1.generic(nuxtTypeComposable).generic($.type.or(symbolResponseType ?? "unknown", nuxtTypeDefault)).generic(symbolErrorType ?? "unknown").generic(nuxtTypeDefault), (f$1) => f$1.generic(symbolResponseType ?? "unknown").generic(symbolErrorType ?? "unknown").generic("ThrowOnError")).$if(plugin.config.responseStyle === "data", (f$1) => f$1.generic($.type.literal(plugin.config.responseStyle)))));
	return statements;
}

//#endregion
//#region src/plugins/@hey-api/sdk/v1/node.ts
const source$1 = globalThis.Symbol("@hey-api/sdk");
function isInstance(plugin) {
	const config = plugin.config.operations;
	return config.container === "class" && config.methods === "instance" && config.strategy !== "flat";
}
function attachComment$1(args) {
	const { node, operation } = args;
	return node.$if(createOperationComment(operation), (n, v) => n.doc(v));
}
function createShellMeta(node) {
	return {
		category: "utility",
		resource: "class",
		resourceId: node.getPath().join("."),
		tool: "sdk"
	};
}
function createFnSymbol(plugin, item) {
	const { operation, path: path$10, tags } = item.data;
	const name = item.location[item.location.length - 1];
	return plugin.symbol(applyNaming(name, plugin.config.operations.methodName), { meta: {
		category: "sdk",
		path: path$10,
		resource: "operation",
		resourceId: operation.id,
		tags,
		tool: "sdk"
	} });
}
function childToNode(resource, plugin) {
	const refChild = plugin.referenceSymbol(createShellMeta(resource));
	const memberNameStr = toCase(refChild.name, plugin.config.operations.methodName.casing ?? "camelCase");
	const memberName = plugin.symbol(memberNameStr);
	if (isInstance(plugin)) {
		const privateName = plugin.symbol(`_${memberNameStr}`);
		return [$.field(privateName, (f$1) => f$1.private().optional().type(refChild)), $.getter(memberName, (g) => g.returns(refChild).do($("this").attr(privateName).nullishAssign($.new(refChild).args($.object().prop("client", $("this").attr("client")))).return()))];
	}
	if (plugin.isSymbolRegistered(refChild.id)) return [$.field(memberName, (f$1) => f$1.static().assign($(refChild)))];
	return [$.getter(memberName, (g) => g.public().static().do($.return(refChild)))];
}
function createShell(plugin) {
	const isAngularClient = getClientPlugin(plugin.context.config).name === "@hey-api/client-angular";
	return { define: (node) => {
		const symbol = plugin.symbol(applyNaming(node.name, node.isRoot ? plugin.config.operations.containerName : plugin.config.operations.segmentName), { meta: createShellMeta(node) });
		const c = $.class(symbol).export().$if(isInstance(plugin), (c$1) => c$1.extends(plugin.referenceSymbol({
			category: "utility",
			resource: "class",
			resourceId: "HeyApiClient",
			tool: "sdk"
		}))).$if(isAngularClient && node.isRoot, (c$1) => c$1.decorator(plugin.external("@angular/core.Injectable"), $.object().prop("providedIn", $.literal("root"))));
		const dependencies = [];
		if (node.isRoot && isInstance(plugin)) enrichRootClass({
			dependencies,
			node: c,
			plugin,
			symbol
		});
		return {
			dependencies,
			node: c
		};
	} };
}
function enrichRootClass(args) {
	const { dependencies, node, plugin, symbol } = args;
	const symbolClient = plugin.symbol("HeyApiClient", { meta: {
		category: "utility",
		resource: "class",
		resourceId: "HeyApiClient",
		tool: "sdk"
	} });
	dependencies.push(createClientClass({
		plugin,
		symbol: symbolClient
	}));
	const symbolRegistry = plugin.symbol("HeyApiRegistry", { meta: {
		category: "utility",
		resource: "class",
		resourceId: "HeyApiRegistry",
		tool: "sdk"
	} });
	dependencies.push(createRegistryClass({
		plugin,
		sdkSymbol: symbol,
		symbol: symbolRegistry
	}));
	const isClientRequired = !plugin.config.client || !plugin.getSymbol({ category: "client" });
	const registry = plugin.symbol("__registry");
	node.toAccessNode = (node$1, options) => {
		if (options.context) return;
		return $(node$1.name).attr(registry).attr("get").call();
	};
	node.do($.field(registry, (f$1) => f$1.public().static().readonly().assign($.new(symbolRegistry).generic(symbol))), $.newline(), $.init((i) => i.param("args", (p) => p.required(isClientRequired).type($.type.object().prop("client", (p$1) => p$1.required(isClientRequired).type(plugin.external("client.Client"))).prop("key", (p$1) => p$1.optional().type("string")))).do($("super").call("args"), $(symbol).attr(registry).attr("set").call("this", $("args").attr("key").required(isClientRequired)))));
}
function exampleIntent(node, operation, plugin) {
	const config = plugin.config.examples;
	if (!config.enabled) return;
	plugin.intent({ async run(context) {
		const { payload } = config;
		let example = ctx.example(node, {
			...config,
			payload: (ctx$1) => typeof payload === "function" ? payload(operation, ctx$1) : payload
		});
		if (config.transform) example = await config.transform(example, operation);
		if (example) context.setExample(operation, {
			lang: config.language,
			source: example
		});
	} });
}
function implementFn(args) {
	const { node, operation, plugin } = args;
	const client = getClientPlugin(plugin.context.config);
	const isNuxtClient = client.name === "@hey-api/client-nuxt";
	const isRequiredOptions = isOperationOptionsRequired({
		context: plugin.context,
		operation
	});
	const opParameters = operationParameters({
		isRequiredOptions,
		operation,
		plugin
	});
	const statements = operationStatements({
		isRequiredOptions,
		opParameters,
		operation,
		plugin
	});
	return node.$if(isNuxtClient, (m) => m.generic(nuxtTypeComposable, (t) => t.extends(plugin.external("client.Composable")).default($.type.literal("$fetch"))).generic(nuxtTypeDefault, (t) => t.$if(plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "response"
	}), (t$1, s) => t$1.extends(s).default(s), (t$1) => t$1.default("undefined"))), (m) => m.generic("ThrowOnError", (t) => t.extends("boolean").default(("throwOnError" in client.config ? client.config.throwOnError : false) ?? false))).params(...opParameters.parameters).do(...statements);
}
function toNode(model, plugin) {
	if (model.virtual) {
		const nodes$1 = [];
		for (const item of model.itemsFrom(source$1)) {
			const { operation } = item.data;
			let node$1 = $.const(createFnSymbol(plugin, item)).export().assign(implementFn({
				node: $.func(),
				operation,
				plugin
			}));
			node$1 = attachComment$1({
				node: node$1,
				operation
			});
			nodes$1.push(node$1);
			exampleIntent(node$1, operation, plugin);
		}
		return { nodes: nodes$1 };
	}
	if (!model.shell) return { nodes: [] };
	const nodes = [];
	const isAngularClient = getClientPlugin(plugin.context.config).name === "@hey-api/client-angular";
	const shell = model.shell.define(model);
	const node = shell.node;
	let index = 0;
	for (const item of model.itemsFrom(source$1)) {
		const { operation } = item.data;
		if (node["~dsl"] === "VarTsDsl") {} else {
			if (index > 0 || node.hasBody) node.newline();
			const method = implementFn({
				node: $.method(createFnSymbol(plugin, item), (m) => attachComment$1({
					node: m,
					operation
				}).public().static(!isAngularClient && !isInstance(plugin))),
				operation,
				plugin
			});
			node.do(method);
			exampleIntent(method, operation, plugin);
		}
		index += 1;
	}
	for (const child of model.children.values()) if (node["~dsl"] === "VarTsDsl") {} else {
		if (node.hasBody) node.newline();
		node.do(...childToNode(child, plugin));
	}
	nodes.push(node);
	return {
		dependencies: shell.dependencies,
		nodes
	};
}

//#endregion
//#region src/utils/escape.ts
const escapeComment = (value) => value.replace(/\*\//g, "*").replace(/\/\*/g, "*").replace(/\r?\n(.*)/g, (_l, w) => node_os.EOL + w.trim());

//#endregion
//#region src/plugins/shared/utils/operation.ts
const createOperationComment = (operation) => {
	const comments = [];
	if (operation.summary) comments.push(escapeComment(operation.summary));
	if (operation.description) {
		if (comments.length) comments.push("");
		comments.push(escapeComment(operation.description));
	}
	if (operation.deprecated) {
		if (comments.length) comments.push("");
		comments.push("@deprecated");
	}
	return comments.length ? comments : void 0;
};
/**
* TODO: replace with plugin logic...
*
* @deprecated this needs to be refactored
*/
const isOperationOptionsRequired = ({ context, operation }) => {
	const isNuxtClient = getClientPlugin(context.config).name === "@hey-api/client-nuxt";
	const plugin = context.config.plugins["@hey-api/sdk"];
	if (plugin) {
		if (!plugin.config.client && !isInstance(plugin)) return true;
		if (plugin.config.paramsStructure === "flat") return false;
	}
	return isNuxtClient || hasOperationDataRequired(operation);
};
const hasOperationSse = ({ operation }) => {
	for (const statusCode in operation.responses) if (operation.responses[statusCode].mediaType === "text/event-stream") return true;
	return false;
};

//#endregion
//#region src/plugins/@angular/common/shared/node.ts
const source = globalThis.Symbol("@angular/common");
function attachComment(args) {
	const { node, operation } = args;
	return node.$if(createOperationComment(operation), (n, v) => n.doc(v));
}
function createHttpRequestFnMeta(operation) {
	return {
		category: "utility",
		resource: "operation",
		resourceId: operation.id,
		role: "request",
		tool: "angular"
	};
}
function createHttpRequestShellMeta(node) {
	return {
		category: "utility",
		resource: "shell",
		resourceId: node.getPath().join("."),
		role: "request",
		tool: "angular"
	};
}
function createHttpResourceFnMeta(operation) {
	return {
		category: "utility",
		resource: "operation",
		resourceId: operation.id,
		role: "resource",
		tool: "angular"
	};
}
function createHttpResourceShellMeta(node) {
	return {
		category: "utility",
		resource: "shell",
		resourceId: node.getPath().join("."),
		role: "resource",
		tool: "angular"
	};
}
function createHttpRequestFnSymbol(plugin, item) {
	const { operation } = item.data;
	const name = item.location[item.location.length - 1];
	return plugin.symbol(applyNaming(name, plugin.config.httpRequests.methodName), { meta: createHttpRequestFnMeta(operation) });
}
function createHttpResourceFnSymbol(plugin, item) {
	const { operation } = item.data;
	const name = item.location[item.location.length - 1];
	return plugin.symbol(applyNaming(name, plugin.config.httpResources.methodName), { meta: createHttpResourceFnMeta(operation) });
}
function childToHttpRequestNode(resource, plugin) {
	const refChild = plugin.referenceSymbol(createHttpRequestShellMeta(resource));
	const memberNameStr = toCase(refChild.name, "camelCase");
	const memberName = plugin.symbol(memberNameStr);
	const privateName = plugin.symbol(`_${memberNameStr}`);
	return [$.field(privateName, (f$1) => f$1.private().optional().type(refChild)), $.getter(memberName, (g) => g.returns(refChild).do($("this").attr(privateName).nullishAssign($.new(refChild).args()).return()))];
}
function childToHttpResourceNode(resource, plugin) {
	const refChild = plugin.referenceSymbol(createHttpResourceShellMeta(resource));
	const memberNameStr = toCase(refChild.name, "camelCase");
	const memberName = plugin.symbol(memberNameStr);
	const privateName = plugin.symbol(`_${memberNameStr}`);
	return [$.field(privateName, (f$1) => f$1.private().optional().type(refChild)), $.getter(memberName, (g) => g.returns(refChild).do($("this").attr(privateName).nullishAssign($.new(refChild).args()).return()))];
}
function createHttpRequestShell(plugin) {
	const isAngularClient = getClientPlugin(plugin.context.config).name === "@hey-api/client-angular";
	const symbolInjectable = plugin.external("@angular/core.Injectable");
	return { define: (node) => {
		const symbol = plugin.symbol(applyNaming(node.name, node.isRoot ? plugin.config.httpRequests.containerName : plugin.config.httpRequests.segmentName), { meta: createHttpRequestShellMeta(node) });
		return {
			dependencies: [],
			node: $.class(symbol).export().$if(isAngularClient && node.isRoot, (c) => c.decorator(symbolInjectable, $.object().prop("providedIn", $.literal("root"))))
		};
	} };
}
function createHttpResourceShell(plugin) {
	const isAngularClient = getClientPlugin(plugin.context.config).name === "@hey-api/client-angular";
	const symbolInjectable = plugin.external("@angular/core.Injectable");
	return { define: (node) => {
		const symbol = plugin.symbol(applyNaming(node.name, node.isRoot ? plugin.config.httpResources.containerName : plugin.config.httpResources.segmentName), { meta: createHttpResourceShellMeta(node) });
		return {
			dependencies: [],
			node: $.class(symbol).export().$if(isAngularClient && node.isRoot, (c) => c.decorator(symbolInjectable, $.object().prop("providedIn", $.literal("root"))))
		};
	} };
}
function implementHttpRequestFn(args) {
	const { node, operation, plugin } = args;
	const isRequiredOptions = isOperationOptionsRequired({
		context: plugin.context,
		operation
	});
	const symbolHttpRequest = plugin.external("@angular/common/http.HttpRequest");
	const symbolClient = plugin.getSymbol({ category: "client" });
	const symbolOptions = plugin.referenceSymbol({
		category: "type",
		resource: "client-options",
		tool: "sdk"
	});
	const symbolDataType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tool: "typescript"
	});
	return node.param("options", (p) => p.required(isRequiredOptions).type($.type(symbolOptions).generic(symbolDataType ?? "unknown").generic("ThrowOnError"))).generic("ThrowOnError", (g) => g.extends("boolean").default(false)).returns($.type(symbolHttpRequest).generic("unknown")).do($.return($("options").attr("client").optional().$if(symbolClient, (c, s) => c.coalesce(s)).attr("requestOptions").call($.object().prop("responseStyle", $.literal("data")).prop("method", $.literal(operation.method.toUpperCase())).prop("url", $.literal(operation.path)).spread("options"))));
}
function implementHttpResourceFn(args) {
	const { node, operation, plugin } = args;
	const isRequiredOptions = isOperationOptionsRequired({
		context: plugin.context,
		operation
	});
	const symbolHttpResource = plugin.external("@angular/common/http.httpResource");
	const symbolInject = plugin.external("@angular/core.inject");
	const symbolOptions = plugin.referenceSymbol({
		category: "type",
		resource: "client-options",
		tool: "sdk"
	});
	const symbolDataType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tool: "typescript"
	});
	const symbolResponseType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "response"
	});
	return node.param("options", (p) => p.required(isRequiredOptions).type($.type.func().returns($.type.or($.type(symbolOptions).generic(symbolDataType ?? "unknown").generic("ThrowOnError"), $.type("undefined"))))).generic("ThrowOnError", (g) => g.extends("boolean").default(false)).do($.return($(symbolHttpResource).call($.func().do($.const("opts").assign($.ternary("options").do($("options").call()).otherwise($.id("undefined"))), $.return($.ternary("opts").do($.lazy((ctx$1) => ctx$1.access(plugin.referenceSymbol(createHttpRequestFnMeta(operation)), { transform: (node$1, index) => index === 0 ? node$1["~dsl"] === "ClassTsDsl" ? $(symbolInject).call($(node$1.name)) : $(node$1.name) : node$1 }).call("opts"))).otherwise($.id("undefined"))))).generic(symbolResponseType ?? "unknown")));
}
function toHttpRequestNode(model, plugin) {
	if (model.virtual) {
		const nodes$1 = [];
		for (const item of model.itemsFrom(source)) {
			const { operation } = item.data;
			let node$1 = $.const(createHttpRequestFnSymbol(plugin, item)).export().assign(implementHttpRequestFn({
				node: $.func(),
				operation,
				plugin
			}));
			node$1 = attachComment({
				node: node$1,
				operation
			});
			nodes$1.push(node$1);
		}
		return { nodes: nodes$1 };
	}
	if (!model.shell) return { nodes: [] };
	const nodes = [];
	const shell = model.shell.define(model);
	const node = shell.node;
	let index = 0;
	for (const item of model.itemsFrom(source)) {
		const { operation } = item.data;
		if (index > 0 || node.hasBody) node.newline();
		node.do(implementHttpRequestFn({
			node: $.method(createHttpRequestFnSymbol(plugin, item), (m) => attachComment({
				node: m,
				operation
			}).public()),
			operation,
			plugin
		}));
		index += 1;
	}
	for (const child of model.children.values()) {
		if (node.hasBody) node.newline();
		node.do(...childToHttpRequestNode(child, plugin));
	}
	nodes.push(node);
	return {
		dependencies: shell.dependencies,
		nodes
	};
}
function toHttpResourceNode(model, plugin) {
	if (model.virtual) {
		const nodes$1 = [];
		for (const item of model.itemsFrom(source)) {
			const { operation } = item.data;
			let node$1 = $.const(createHttpResourceFnSymbol(plugin, item)).export().assign(implementHttpResourceFn({
				node: $.func(),
				operation,
				plugin
			}));
			node$1 = attachComment({
				node: node$1,
				operation
			});
			nodes$1.push(node$1);
		}
		return { nodes: nodes$1 };
	}
	if (!model.shell) return { nodes: [] };
	const nodes = [];
	const shell = model.shell.define(model);
	const node = shell.node;
	let index = 0;
	for (const item of model.itemsFrom(source)) {
		const { operation } = item.data;
		if (index > 0 || node.hasBody) node.newline();
		node.do(implementHttpResourceFn({
			node: $.method(createHttpResourceFnSymbol(plugin, item), (m) => attachComment({
				node: m,
				operation
			}).public()),
			operation,
			plugin
		}));
		index += 1;
	}
	for (const child of model.children.values()) {
		if (node.hasBody) node.newline();
		node.do(...childToHttpResourceNode(child, plugin));
	}
	nodes.push(node);
	return {
		dependencies: shell.dependencies,
		nodes
	};
}

//#endregion
//#region src/plugins/@angular/common/plugin.ts
const handler$11 = ({ plugin }) => {
	plugin.symbol("HttpRequest", {
		external: "@angular/common/http",
		kind: "type",
		meta: {
			category: "external",
			resource: "@angular/common/http.HttpRequest"
		}
	});
	plugin.symbol("inject", {
		external: "@angular/core",
		meta: {
			category: "external",
			resource: "@angular/core.inject"
		}
	});
	plugin.symbol("Injectable", {
		external: "@angular/core",
		meta: {
			category: "external",
			resource: "@angular/core.Injectable"
		}
	});
	plugin.symbol("httpResource", {
		external: "@angular/common/http",
		meta: {
			category: "external",
			resource: "@angular/common/http.httpResource"
		}
	});
	const httpRequestStructure = new _hey_api_codegen_core.StructureModel();
	const httpResourceStructure = new _hey_api_codegen_core.StructureModel();
	if (plugin.config.httpRequests.enabled) {
		const shell = createHttpRequestShell(plugin);
		const strategy = resolveHttpRequestsStrategy(plugin);
		plugin.forEach("operation", ({ operation }) => {
			httpRequestStructure.insert({
				data: { operation },
				locations: strategy(operation).map((path$10) => ({
					path: path$10,
					shell
				})),
				source
			});
		}, { order: "declarations" });
	}
	if (plugin.config.httpResources.enabled) {
		const shell = createHttpResourceShell(plugin);
		const strategy = resolveHttpResourcesStrategy(plugin);
		plugin.forEach("operation", ({ operation }) => {
			httpResourceStructure.insert({
				data: { operation },
				locations: strategy(operation).map((path$10) => ({
					path: path$10,
					shell
				})),
				source
			});
		}, { order: "declarations" });
	}
	const allDependencies = [];
	const allNodes = [];
	for (const node of httpRequestStructure.walk()) {
		const { dependencies, nodes } = toHttpRequestNode(node, plugin);
		allDependencies.push(...dependencies ?? []);
		allNodes.push(...nodes);
	}
	for (const node of httpResourceStructure.walk()) {
		const { dependencies, nodes } = toHttpResourceNode(node, plugin);
		allDependencies.push(...dependencies ?? []);
		allNodes.push(...nodes);
	}
	const uniqueDependencies = /* @__PURE__ */ new Map();
	for (const dep of allDependencies) if (dep.symbol) uniqueDependencies.set(dep.symbol.id, dep);
	for (const dep of uniqueDependencies.values()) plugin.node(dep);
	for (const node of allNodes) plugin.node(node);
};

//#endregion
//#region src/plugins/@angular/common/config.ts
const defaultConfig$23 = {
	config: { exportFromIndex: false },
	dependencies: ["@hey-api/client-angular", "@hey-api/sdk"],
	handler: handler$11,
	name: "@angular/common",
	resolveConfig: (plugin, context) => {
		plugin.config.httpRequests = resolveHttpRequests(plugin.config, context);
		plugin.config.httpResources = resolveHttpResources(plugin.config, context);
	}
};
/**
* Type helper for `@angular/common` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$23 = definePluginConfig(defaultConfig$23);

//#endregion
//#region src/plugins/@faker-js/faker/api.ts
var Api$4 = class {
	toNode(_schema) {}
	toNodeRef(_schema) {}
};

//#endregion
//#region src/plugins/@faker-js/faker/config.ts
const defaultConfig$22 = {
	api: new Api$4(),
	config: {
		case: "camelCase",
		exportFromIndex: false
	},
	handler: () => {},
	name: "@faker-js/faker",
	resolveConfig: (plugin, context) => {
		plugin.config.definitions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "v{{name}}"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.definitions
		});
	},
	tags: ["mocker"]
};
/**
* Type helper for Faker plugin, returns {@link Plugin.Config} object
*/
const defineConfig$22 = definePluginConfig(defaultConfig$22);

//#endregion
//#region src/plugins/@hey-api/client-core/config.ts
const clientDefaultConfig = {
	baseUrl: true,
	bundle: true,
	exportFromIndex: false
};
const clientDefaultMeta = {
	dependencies: ["@hey-api/typescript"],
	tags: ["client"]
};

//#endregion
//#region src/generate/client.ts
const __filename$1 = (0, node_url.fileURLToPath)(require("url").pathToFileURL(__filename).href);
const __dirname$1 = node_path.default.dirname(__filename$1);
/**
* Returns absolute path to the client folder. This is hard-coded for now.
*/
const clientFolderAbsolutePath = (config) => {
	const client = getClientPlugin(config);
	if ("bundle" in client.config && client.config.bundle) {
		const renamed = config._FRAGILE_CLIENT_BUNDLE_RENAMED;
		return node_path.default.resolve(config.output.path, "client", `${renamed?.get("index") ?? "index"}.ts`);
	}
	return client.name;
};
/**
* Recursively copies files and directories.
* This is a PnP-compatible alternative to fs.cpSync that works with Yarn PnP's
* virtualized filesystem.
*/
const copyRecursivePnP = (src, dest) => {
	if (node_fs.default.statSync(src).isDirectory()) {
		if (!node_fs.default.existsSync(dest)) node_fs.default.mkdirSync(dest, { recursive: true });
		const files = node_fs.default.readdirSync(src);
		for (const file of files) copyRecursivePnP(node_path.default.join(src, file), node_path.default.join(dest, file));
	} else {
		const content = node_fs.default.readFileSync(src);
		node_fs.default.writeFileSync(dest, content);
	}
};
const renameFile = ({ filePath, project, renamed }) => {
	const extension = node_path.default.extname(filePath);
	const name = node_path.default.basename(filePath, extension);
	const renamedName = project.fileName?.(name) || name;
	if (renamedName !== name) {
		const outputPath = node_path.default.dirname(filePath);
		node_fs.default.renameSync(filePath, node_path.default.resolve(outputPath, `${renamedName}${extension}`));
		renamed.set(name, renamedName);
	}
};
const replaceImports = ({ filePath, meta, renamed }) => {
	let content = node_fs.default.readFileSync(filePath, "utf8");
	content = content.replace(/from\s+['"](\.\.?\/[^'"]*?)['"]/g, (match, importPath) => {
		const importIndex = match.indexOf(importPath);
		const extension = node_path.default.extname(importPath);
		const fileName = node_path.default.basename(importPath, extension);
		const importDir = node_path.default.dirname(importPath);
		const replacedName = (renamed.get(fileName) ?? fileName) + (meta.importFileExtension ? meta.importFileExtension : extension);
		return match.slice(0, importIndex) + [importDir, replacedName].filter(Boolean).join("/") + match.slice(importIndex + importPath.length);
	});
	content = `// This file is auto-generated by @hey-api/openapi-ts

${content}`;
	node_fs.default.writeFileSync(filePath, content, "utf8");
};
/**
* Creates a `client` folder containing the same modules as the client package.
*/
const generateClientBundle = ({ meta, outputPath, plugin, project }) => {
	const renamed = /* @__PURE__ */ new Map();
	if (plugin.name.startsWith("@hey-api/client-")) {
		const coreOutputPath = node_path.default.resolve(outputPath, "core");
		ensureDirSync(coreOutputPath);
		copyRecursivePnP(node_path.default.resolve(__dirname$1, "clients", "core"), coreOutputPath);
		const clientOutputPath = node_path.default.resolve(outputPath, "client");
		ensureDirSync(clientOutputPath);
		const clientDistFolderName = plugin.name.slice(16);
		copyRecursivePnP(node_path.default.resolve(__dirname$1, "clients", clientDistFolderName), clientOutputPath);
		if (project) {
			const copiedCoreFiles = node_fs.default.readdirSync(coreOutputPath);
			for (const file of copiedCoreFiles) renameFile({
				filePath: node_path.default.resolve(coreOutputPath, file),
				project,
				renamed
			});
			const copiedClientFiles = node_fs.default.readdirSync(clientOutputPath);
			for (const file of copiedClientFiles) renameFile({
				filePath: node_path.default.resolve(clientOutputPath, file),
				project,
				renamed
			});
		}
		const coreFiles = node_fs.default.readdirSync(coreOutputPath);
		for (const file of coreFiles) replaceImports({
			filePath: node_path.default.resolve(coreOutputPath, file),
			meta,
			renamed
		});
		const clientFiles = node_fs.default.readdirSync(clientOutputPath);
		for (const file of clientFiles) replaceImports({
			filePath: node_path.default.resolve(clientOutputPath, file),
			meta,
			renamed
		});
		return renamed;
	}
	const clientSrcPath = node_path.default.isAbsolute(plugin.name) ? node_path.default.dirname(plugin.name) : void 0;
	if (clientSrcPath) {
		const dirPath$1 = node_path.default.resolve(outputPath, "client");
		ensureDirSync(dirPath$1);
		copyRecursivePnP(clientSrcPath, dirPath$1);
		return;
	}
	const clientModulePathComponents = node_path.default.normalize(require.resolve(plugin.name)).split(node_path.default.sep);
	const clientDistPath = clientModulePathComponents.slice(0, clientModulePathComponents.indexOf("dist") + 1).join(node_path.default.sep);
	const distFiles = [
		clientModulePathComponents[clientModulePathComponents.length - 1],
		"index.d.mts",
		"index.d.cts"
	];
	const dirPath = node_path.default.resolve(outputPath, "client");
	ensureDirSync(dirPath);
	for (const file of distFiles) node_fs.default.copyFileSync(node_path.default.resolve(clientDistPath, file), node_path.default.resolve(dirPath, file));
};

//#endregion
//#region src/utils/url.ts
const parseUrlRegExp = /^(([^:/?#]+):)?((\/\/)?([^:/?#]*)(:?([^/?#]*)))?([^?#]*)(\?([^#]*))?(#(.*))?/;
const parseUrl = (value) => {
	const errorResponse = {
		host: "",
		path: "",
		port: "",
		protocol: ""
	};
	parseUrlRegExp.lastIndex = 0;
	const match = value.match(parseUrlRegExp);
	if (!match) return errorResponse;
	const host = match[5] || "";
	if (host === "." || host === "..") return errorResponse;
	const path$10 = match[8] || "";
	const protocol = match[2] || "";
	if (protocol.length === 1) return errorResponse;
	return {
		host,
		path: path$10 === "/" ? "" : path$10,
		port: match[7] || "",
		protocol
	};
};

//#endregion
//#region src/plugins/@hey-api/client-core/client.ts
const resolveBaseUrlString = ({ plugin }) => {
	const { baseUrl } = plugin.config;
	if (baseUrl === false) return;
	if (typeof baseUrl === "string") return baseUrl;
	const { servers } = plugin.context.ir;
	if (!servers) return;
	return servers[typeof baseUrl === "number" ? baseUrl : 0]?.url;
};
const createClient = ({ plugin }) => {
	const clientModule = clientFolderAbsolutePath(plugin.context.config);
	const symbolCreateClient = plugin.symbol("createClient", { external: clientModule });
	const symbolCreateConfig = plugin.symbol("createConfig", { external: clientModule });
	const symbolClientOptions = plugin.referenceSymbol({
		category: "type",
		resource: "client",
		role: "options"
	});
	const { runtimeConfigPath } = plugin.config;
	const symbolCreateClientConfig = runtimeConfigPath ? plugin.symbol("createClientConfig", { external: runtimeConfigPath }) : void 0;
	const defaultVals = $.object();
	const resolvedBaseUrl = resolveBaseUrlString({ plugin });
	if (resolvedBaseUrl) {
		const url = parseUrl(resolvedBaseUrl);
		if (url.protocol && url.host && !resolvedBaseUrl.includes("{")) defaultVals.prop(getClientBaseUrlKey(plugin.context.config), $.literal(resolvedBaseUrl));
		else if (resolvedBaseUrl !== "/" && resolvedBaseUrl.startsWith("/")) {
			const baseUrl = resolvedBaseUrl.endsWith("/") ? resolvedBaseUrl.slice(0, -1) : resolvedBaseUrl;
			defaultVals.prop(getClientBaseUrlKey(plugin.context.config), $.literal(baseUrl));
		}
	}
	if ("throwOnError" in plugin.config && plugin.config.throwOnError) defaultVals.prop("throwOnError", $.literal(true));
	const createConfigParameters = [$(symbolCreateConfig).call(defaultVals.hasProps() ? defaultVals : void 0).generic(symbolClientOptions)];
	const symbolClient = plugin.symbol("client", { meta: { category: "client" } });
	const statement = $.const(symbolClient).export().assign($(symbolCreateClient).$if(symbolCreateClientConfig, (c, s) => c.call($(s).call(...createConfigParameters)), (c) => c.call(...createConfigParameters)));
	plugin.node(statement);
};

//#endregion
//#region src/plugins/@hey-api/client-core/createClientConfig.ts
const createClientConfigType = ({ plugin }) => {
	const clientModule = clientFolderAbsolutePath(plugin.context.config);
	const symbolClientOptions = plugin.referenceSymbol({
		category: "type",
		resource: "client",
		role: "options"
	});
	const symbolConfig = plugin.symbol("Config", {
		external: clientModule,
		kind: "type"
	});
	const symbolDefaultClientOptions = plugin.symbol("ClientOptions", {
		external: clientModule,
		kind: "type"
	});
	const symbolCreateClientConfig = plugin.symbol("CreateClientConfig");
	const typeCreateClientConfig = $.type.alias(symbolCreateClientConfig).export().doc([
		"The `createClientConfig()` function will be called on client initialization",
		"and the returned object will become the client's initial configuration.",
		"",
		"You may want to initialize your client this way instead of calling",
		"`setConfig()`. This is useful for example if you're using Next.js",
		"to ensure your client always has the correct values."
	]).generic("T", (g) => g.extends(symbolDefaultClientOptions).default(symbolClientOptions)).type($.type.func().param("override", (p) => p.optional().type($.type(symbolConfig).generic($.type.and(symbolDefaultClientOptions, "T")))).returns($.type(symbolConfig).generic($.type.and($.type("Required").generic(symbolDefaultClientOptions), "T"))));
	plugin.node(typeCreateClientConfig);
};

//#endregion
//#region src/plugins/@hey-api/client-core/plugin.ts
const clientPluginHandler = ({ plugin }) => {
	createClientConfigType({ plugin });
	createClient({ plugin });
};

//#endregion
//#region src/plugins/@hey-api/client-angular/config.ts
const defaultConfig$21 = {
	...clientDefaultMeta,
	config: {
		...clientDefaultConfig,
		throwOnError: false
	},
	handler: clientPluginHandler,
	name: "@hey-api/client-angular"
};
/**
* Type helper for `@hey-api/client-angular` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$21 = definePluginConfig(defaultConfig$21);

//#endregion
//#region src/plugins/@hey-api/client-axios/config.ts
const defaultConfig$20 = {
	...clientDefaultMeta,
	config: {
		...clientDefaultConfig,
		throwOnError: false
	},
	handler: clientPluginHandler,
	name: "@hey-api/client-axios"
};
/**
* Type helper for `@hey-api/client-axios` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$20 = definePluginConfig(defaultConfig$20);

//#endregion
//#region src/plugins/@hey-api/client-fetch/config.ts
const defaultConfig$19 = {
	...clientDefaultMeta,
	config: {
		...clientDefaultConfig,
		throwOnError: false
	},
	handler: clientPluginHandler,
	name: "@hey-api/client-fetch"
};
/**
* Type helper for `@hey-api/client-fetch` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$19 = definePluginConfig(defaultConfig$19);

//#endregion
//#region src/plugins/@hey-api/client-ky/config.ts
const defaultConfig$18 = {
	...clientDefaultMeta,
	config: {
		...clientDefaultConfig,
		throwOnError: false
	},
	handler: clientPluginHandler,
	name: "@hey-api/client-ky"
};
/**
* Type helper for `@hey-api/client-ky` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$18 = definePluginConfig(defaultConfig$18);

//#endregion
//#region src/plugins/@hey-api/client-next/config.ts
const defaultConfig$17 = {
	...clientDefaultMeta,
	config: {
		...clientDefaultConfig,
		throwOnError: false
	},
	handler: clientPluginHandler,
	name: "@hey-api/client-next"
};
/**
* Type helper for `@hey-api/client-next` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$17 = definePluginConfig(defaultConfig$17);

//#endregion
//#region src/plugins/@hey-api/client-nuxt/config.ts
const defaultConfig$16 = {
	...clientDefaultMeta,
	config: clientDefaultConfig,
	handler: clientPluginHandler,
	name: "@hey-api/client-nuxt"
};
/**
* Type helper for `@hey-api/client-nuxt` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$16 = definePluginConfig(defaultConfig$16);

//#endregion
//#region src/plugins/@hey-api/client-ofetch/config.ts
const defaultConfig$15 = {
	...clientDefaultMeta,
	config: {
		...clientDefaultConfig,
		throwOnError: false
	},
	handler: clientPluginHandler,
	name: "@hey-api/client-ofetch"
};
/**
* Type helper for `@hey-api/client-ofetch` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$15 = definePluginConfig(defaultConfig$15);

//#endregion
//#region src/config/utils/package.ts
const satisfies = (...args) => semver.satisfies(...args);
const packageFactory = (dependencies) => ({
	getVersion: (name) => {
		const version = dependencies[name];
		if (!version) return;
		try {
			let parsed = semver.parse(version);
			if (parsed) return parsed;
			const min = semver.minVersion(version);
			if (min) return min;
			parsed = semver.coerce(version);
			if (parsed) return parsed;
		} catch {}
	},
	isInstalled: (name) => Boolean(dependencies[name]),
	satisfies: (nameOrVersion, range, optionsOrLoose) => {
		const version = typeof nameOrVersion === "string" ? dependencies[nameOrVersion] : nameOrVersion;
		return version ? satisfies(version, range, optionsOrLoose) : false;
	}
});

//#endregion
//#region src/plugins/@hey-api/schemas/plugin.ts
const stripSchema = ({ plugin, schema }) => {
	if (plugin.config.type === "form") {
		if (schema.description) delete schema.description;
		if (schema["x-enum-descriptions"]) delete schema["x-enum-descriptions"];
		if (schema["x-enum-varnames"]) delete schema["x-enum-varnames"];
		if (schema["x-enumNames"]) delete schema["x-enumNames"];
		if (schema.title) delete schema.title;
	}
};
const schemaToJsonSchemaDraft_04 = ({ context, plugin, schema: _schema }) => {
	if (Array.isArray(_schema)) return _schema.map((item) => schemaToJsonSchemaDraft_04({
		context,
		plugin,
		schema: item
	}));
	const schema = structuredClone(_schema);
	if (schema.$ref) {
		schema.$ref = decodeURI(schema.$ref);
		return schema;
	}
	stripSchema({
		plugin,
		schema
	});
	if (schema.additionalProperties && typeof schema.additionalProperties !== "boolean") schema.additionalProperties = schemaToJsonSchemaDraft_04({
		context,
		plugin,
		schema: schema.additionalProperties
	});
	if (schema.allOf) schema.allOf = schema.allOf.map((item) => schemaToJsonSchemaDraft_04({
		context,
		plugin,
		schema: item
	}));
	if (schema.items) schema.items = schemaToJsonSchemaDraft_04({
		context,
		plugin,
		schema: schema.items
	});
	if (schema.properties) for (const name in schema.properties) {
		const property = schema.properties[name];
		if (typeof property !== "boolean") schema.properties[name] = schemaToJsonSchemaDraft_04({
			context,
			plugin,
			schema: property
		});
	}
	return schema;
};
const schemaToJsonSchemaDraft_05 = ({ context, plugin, schema: _schema }) => {
	if (Array.isArray(_schema)) return _schema.map((item) => schemaToJsonSchemaDraft_05({
		context,
		plugin,
		schema: item
	}));
	const schema = structuredClone(_schema);
	if ("$ref" in schema) {
		schema.$ref = decodeURI(schema.$ref);
		return schema;
	}
	stripSchema({
		plugin,
		schema
	});
	if (schema.additionalProperties && typeof schema.additionalProperties !== "boolean") schema.additionalProperties = schemaToJsonSchemaDraft_05({
		context,
		plugin,
		schema: schema.additionalProperties
	});
	if (schema.allOf) schema.allOf = schema.allOf.map((item) => schemaToJsonSchemaDraft_05({
		context,
		plugin,
		schema: item
	}));
	if (schema.anyOf) schema.anyOf = schema.anyOf.map((item) => schemaToJsonSchemaDraft_05({
		context,
		plugin,
		schema: item
	}));
	if (schema.items) schema.items = schemaToJsonSchemaDraft_05({
		context,
		plugin,
		schema: schema.items
	});
	if (schema.oneOf) schema.oneOf = schema.oneOf.map((item) => schemaToJsonSchemaDraft_05({
		context,
		plugin,
		schema: item
	}));
	if (schema.properties) for (const name in schema.properties) {
		const property = schema.properties[name];
		if (typeof property !== "boolean") schema.properties[name] = schemaToJsonSchemaDraft_05({
			context,
			plugin,
			schema: property
		});
	}
	return schema;
};
const schemaToJsonSchema2020_12 = ({ context, plugin, schema: _schema }) => {
	if (Array.isArray(_schema)) return _schema.map((item) => schemaToJsonSchema2020_12({
		context,
		plugin,
		schema: item
	}));
	const schema = structuredClone(_schema);
	stripSchema({
		plugin,
		schema
	});
	if (schema.$ref) schema.$ref = decodeURI(schema.$ref);
	if (schema.additionalProperties && typeof schema.additionalProperties !== "boolean") schema.additionalProperties = schemaToJsonSchema2020_12({
		context,
		plugin,
		schema: schema.additionalProperties
	});
	if (schema.allOf) schema.allOf = schema.allOf.map((item) => schemaToJsonSchema2020_12({
		context,
		plugin,
		schema: item
	}));
	if (schema.anyOf) schema.anyOf = schema.anyOf.map((item) => schemaToJsonSchema2020_12({
		context,
		plugin,
		schema: item
	}));
	if (schema.items) schema.items = schemaToJsonSchema2020_12({
		context,
		plugin,
		schema: schema.items
	});
	if (schema.oneOf) schema.oneOf = schema.oneOf.map((item) => schemaToJsonSchema2020_12({
		context,
		plugin,
		schema: item
	}));
	if (schema.prefixItems) schema.prefixItems = schema.prefixItems.map((item) => schemaToJsonSchema2020_12({
		context,
		plugin,
		schema: item
	}));
	if (schema.properties) for (const name in schema.properties) {
		const property = schema.properties[name];
		if (typeof property !== "boolean") schema.properties[name] = schemaToJsonSchema2020_12({
			context,
			plugin,
			schema: property
		});
	}
	return schema;
};
const schemaName = ({ name, plugin, schema }) => {
	let customName = "";
	if (plugin.config.nameBuilder) if (typeof plugin.config.nameBuilder === "function") customName = plugin.config.nameBuilder(name, schema);
	else customName = plugin.config.nameBuilder.replace("{{name}}", name);
	if (!customName) customName = `${name}Schema`;
	return customName;
};
const schemasV2_0_X = ({ context, plugin }) => {
	if (!context.spec.definitions) return;
	for (const name in context.spec.definitions) {
		const schema = context.spec.definitions[name];
		const symbol = plugin.symbol(schemaName({
			name,
			plugin,
			schema
		}), { meta: {
			category: "schema",
			resource: "definition",
			resourceId: name,
			tool: "json-schema"
		} });
		const obj = schemaToJsonSchemaDraft_04({
			context,
			plugin,
			schema
		});
		const statement = $.const(symbol).export().assign($($.fromValue(obj, { layout: "pretty" })).as("const"));
		plugin.node(statement);
	}
};
const schemasV3_0_X = ({ context, plugin }) => {
	if (!context.spec.components) return;
	for (const name in context.spec.components.schemas) {
		const schema = context.spec.components.schemas[name];
		const symbol = plugin.symbol(schemaName({
			name,
			plugin,
			schema
		}), { meta: {
			category: "schema",
			resource: "definition",
			resourceId: name,
			tool: "json-schema"
		} });
		const obj = schemaToJsonSchemaDraft_05({
			context,
			plugin,
			schema
		});
		const statement = $.const(symbol).export().assign($($.fromValue(obj, { layout: "pretty" })).as("const"));
		plugin.node(statement);
	}
};
const schemasV3_1_X = ({ context, plugin }) => {
	if (!context.spec.components) return;
	for (const name in context.spec.components.schemas) {
		const schema = context.spec.components.schemas[name];
		const symbol = plugin.symbol(schemaName({
			name,
			plugin,
			schema
		}), { meta: {
			category: "schema",
			resource: "definition",
			resourceId: name,
			tool: "json-schema"
		} });
		const obj = schemaToJsonSchema2020_12({
			context,
			plugin,
			schema
		});
		const statement = $.const(symbol).export().assign($($.fromValue(obj, { layout: "pretty" })).as("const"));
		plugin.node(statement);
	}
};
const handler$10 = ({ plugin }) => {
	if ("swagger" in plugin.context.spec) {
		schemasV2_0_X({
			context: plugin.context,
			plugin
		});
		return;
	}
	if (satisfies(plugin.context.spec.openapi, ">=3.0.0 <3.1.0")) {
		schemasV3_0_X({
			context: plugin.context,
			plugin
		});
		return;
	}
	if (satisfies(plugin.context.spec.openapi, ">=3.1.0")) {
		schemasV3_1_X({
			context: plugin.context,
			plugin
		});
		return;
	}
	throw new Error("Unsupported OpenAPI specification");
};

//#endregion
//#region src/plugins/@hey-api/schemas/config.ts
const defaultConfig$14 = {
	config: {
		exportFromIndex: false,
		nameBuilder: (name) => `${name}Schema`,
		type: "json"
	},
	handler: handler$10,
	name: "@hey-api/schemas"
};
/**
* Type helper for `@hey-api/schemas` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$14 = definePluginConfig(defaultConfig$14);

//#endregion
//#region src/plugins/@hey-api/sdk/examples/config.ts
function resolveExamples(config, context) {
	return context.valueToObject({
		defaultValue: {
			enabled: Boolean(config.examples),
			language: "JavaScript"
		},
		mappers: { boolean: (enabled) => ({ enabled }) },
		value: config.examples
	});
}

//#endregion
//#region src/plugins/@hey-api/sdk/operations/config.ts
function resolveOperations(config, context) {
	if (config.asClass !== void 0) _hey_api_codegen_core.log.warnDeprecated({
		context: "@hey-api/sdk",
		field: "asClass",
		replacement: ["operations: { strategy: \"byTags\" }", "operations: { strategy: \"single\" }"]
	});
	if (config.classNameBuilder !== void 0) _hey_api_codegen_core.log.warnDeprecated({
		context: "@hey-api/sdk",
		field: "classNameBuilder",
		replacement: "operations: { containerName: \"...\" }"
	});
	if (config.classStructure !== void 0) _hey_api_codegen_core.log.warnDeprecated({
		context: "@hey-api/sdk",
		field: "classStructure",
		replacement: ["operations: { nesting: \"operationId\" }", "operations: { nesting: \"id\" }"]
	});
	if (config.instance !== void 0) _hey_api_codegen_core.log.warnDeprecated({
		context: "@hey-api/sdk",
		field: "instance",
		replacement: `operations: { strategy: "single", containerName: "${config.instance || "Name"}", methods: "instance" }`
	});
	if (config.methodNameBuilder !== void 0) _hey_api_codegen_core.log.warnDeprecated({
		context: "@hey-api/sdk",
		field: "methodNameBuilder",
		replacement: "operations: { methodName: \"...\" }"
	});
	if (config.operationId !== void 0) _hey_api_codegen_core.log.warnDeprecated({
		context: "@hey-api/sdk",
		field: "operationId",
		replacement: ["operations: { nesting: \"operationId\" }", "operations: { nesting: \"id\" }"]
	});
	const legacy = mapLegacyToConfig(config);
	return normalizeConfig(config.operations, legacy, context);
}
function normalizeConfig(input, legacy, context) {
	if (!input || typeof input === "string" || typeof input === "function") input = { strategy: input };
	const strategy = legacy.strategy ?? input.strategy ?? "flat";
	const methods = strategy === "single" ? "instance" : "static";
	return context.valueToObject({
		defaultValue: {
			container: "class",
			methods,
			nesting: "operationId",
			nestingDelimiters: /[./]/,
			strategy,
			strategyDefaultTag: "default"
		},
		mappers: { object(value) {
			value.containerName = context.valueToObject({
				defaultValue: strategy === "single" ? {
					casing: "PascalCase",
					name: "Sdk"
				} : { casing: "PascalCase" },
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: value.containerName
			});
			value.methodName = context.valueToObject({
				defaultValue: { casing: "camelCase" },
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: value.methodName
			});
			value.segmentName = context.valueToObject({
				defaultValue: { casing: "PascalCase" },
				mappers: {
					function: (name) => ({ name }),
					string: (name) => ({ name })
				},
				value: value.segmentName
			});
			return value;
		} },
		value: {
			...legacy,
			...input
		}
	});
}
function mapLegacyToConfig(config) {
	let strategy;
	if (config.instance) strategy = "single";
	else if (config.asClass) strategy = "byTags";
	else if (config.instance === false || config.asClass === false) strategy = "flat";
	let containerName;
	let segmentName;
	if (config.instance) {
		let name = typeof config.instance === "string" ? config.instance : "Sdk";
		segmentName = { casing: "PascalCase" };
		if (config.classNameBuilder) {
			segmentName.name = config.classNameBuilder;
			if (typeof config.classNameBuilder === "string") name = config.classNameBuilder.replace("{{name}}", name);
			else name = config.classNameBuilder(name);
		}
		containerName = {
			casing: "PascalCase",
			name
		};
	} else if (config.classNameBuilder) {
		containerName = {
			casing: "PascalCase",
			name: config.classNameBuilder
		};
		segmentName = { ...containerName };
	} else if (config.asClass) {
		containerName = { casing: "PascalCase" };
		segmentName = { ...containerName };
	}
	let methods;
	if (config.instance) methods = "instance";
	else if (config.asClass) methods = "static";
	let nesting;
	if (config.classStructure === "off" || config.operationId === false) nesting = "id";
	else if (config.classStructure === "auto") nesting = "operationId";
	let methodName;
	if (config.methodNameBuilder) methodName = {
		casing: "camelCase",
		name: config.methodNameBuilder
	};
	return {
		containerName,
		methodName,
		methods,
		nesting,
		segmentName,
		strategy
	};
}

//#endregion
//#region src/plugins/@hey-api/sdk/operations/resolve.ts
function resolvePath(plugin) {
	if (plugin.config.operations.nesting === "id") return OperationPath.id();
	if (plugin.config.operations.nesting === "operationId") return OperationPath.fromOperationId({
		delimiters: plugin.config.operations.nestingDelimiters,
		fallback: OperationPath.id()
	});
	return plugin.config.operations.nesting;
}
function resolveStrategy(plugin) {
	if (plugin.config.operations.strategy === "flat") return OperationStrategy.flat({ path: (operation) => [resolvePath(plugin)(operation).join(".")] });
	if (plugin.config.operations.strategy === "single") {
		const root = plugin.config.operations.containerName;
		return OperationStrategy.single({
			path: resolvePath(plugin),
			root: typeof root.name === "string" ? root.name : root.name?.("") ?? ""
		});
	}
	if (plugin.config.operations.strategy === "byTags") return OperationStrategy.byTags({
		fallback: plugin.config.operations.strategyDefaultTag,
		path: resolvePath(plugin)
	});
	return plugin.config.operations.strategy;
}

//#endregion
//#region src/plugins/@hey-api/sdk/shared/typeOptions.ts
const createTypeOptions = ({ plugin }) => {
	const clientModule = clientFolderAbsolutePath(plugin.context.config);
	const client = getClientPlugin(plugin.context.config);
	const isNuxtClient = client.name === "@hey-api/client-nuxt";
	const symbolTDataShape = plugin.symbol("TDataShape", {
		external: clientModule,
		kind: "type"
	});
	const symbolClient = plugin.symbol("Client", {
		external: clientModule,
		kind: "type",
		meta: {
			category: "external",
			resource: "client.Client",
			tool: client.name
		}
	});
	const symbolClientOptions = plugin.symbol("Options", {
		external: clientModule,
		kind: "type"
	});
	const symbolOptions = plugin.symbol("Options", { meta: {
		category: "type",
		resource: "client-options",
		tool: "sdk"
	} });
	const typeOptions = $.type.alias(symbolOptions).export().$if(isNuxtClient, (t) => t.generic("TComposable", (g) => g.extends(plugin.external("client.Composable")).default($.type.literal("$fetch"))).generic("TData", (g) => g.extends(symbolTDataShape).default(symbolTDataShape)).generic(nuxtTypeResponse, (g) => g.default("unknown")).generic(nuxtTypeDefault, (g) => g.default("undefined")), (t) => t.generic("TData", (g) => g.extends(symbolTDataShape).default(symbolTDataShape)).generic("ThrowOnError", (g) => g.extends("boolean").default("boolean"))).type($.type.and($.type(symbolClientOptions).$if(isNuxtClient, (t) => t.generic("TComposable").generic("TData").generic(nuxtTypeResponse).generic(nuxtTypeDefault), (t) => t.generic("TData").generic("ThrowOnError")), $.type.object().prop("client", (p) => p.doc([
		"You can provide a client instance returned by `createClient()` instead of",
		"individual options. This might be also useful if you want to implement a",
		"custom client."
	]).required(!plugin.config.client && !isInstance(plugin)).type(symbolClient)).prop("meta", (p) => p.doc(["You can pass arbitrary values through the `meta` object. This can be", "used to access values that aren't defined as part of the SDK function."]).optional().type($.type("Record").generics("string", "unknown")))));
	plugin.node(typeOptions);
};

//#endregion
//#region src/plugins/@hey-api/sdk/v1/plugin.ts
const handlerV1$2 = ({ plugin }) => {
	const clientModule = clientFolderAbsolutePath(plugin.context.config);
	const client = getClientPlugin(plugin.context.config);
	const isAngularClient = client.name === "@hey-api/client-angular";
	const isNuxtClient = client.name === "@hey-api/client-nuxt";
	plugin.symbol("formDataBodySerializer", {
		external: clientModule,
		meta: {
			category: "external",
			resource: "client.formDataBodySerializer",
			tool: client.name
		}
	});
	plugin.symbol("urlSearchParamsBodySerializer", {
		external: clientModule,
		meta: {
			category: "external",
			resource: "client.urlSearchParamsBodySerializer",
			tool: client.name
		}
	});
	plugin.symbol("buildClientParams", {
		external: clientModule,
		meta: {
			category: "external",
			resource: "client.buildClientParams",
			tool: client.name
		}
	});
	if (isNuxtClient) plugin.symbol("Composable", {
		external: clientModule,
		kind: "type",
		meta: {
			category: "external",
			resource: "client.Composable",
			tool: client.name
		}
	});
	if (isAngularClient) plugin.symbol("Injectable", {
		external: "@angular/core",
		meta: {
			category: "external",
			resource: "@angular/core.Injectable"
		}
	});
	createTypeOptions({ plugin });
	const structure = new _hey_api_codegen_core.StructureModel();
	const shell = createShell(plugin);
	const strategy = resolveStrategy(plugin);
	plugin.forEach("operation", (event) => {
		structure.insert({
			data: {
				operation: event.operation,
				path: event._path,
				tags: event.tags
			},
			locations: strategy(event.operation).map((path$10) => ({
				path: path$10,
				shell
			})),
			source: source$1
		});
	}, { order: "declarations" });
	const allDependencies = [];
	const allNodes = [];
	for (const node of structure.walk()) {
		const { dependencies, nodes } = toNode(node, plugin);
		allDependencies.push(...dependencies ?? []);
		allNodes.push(...nodes);
	}
	const uniqueDependencies = /* @__PURE__ */ new Map();
	for (const dep of allDependencies) if (dep.symbol) uniqueDependencies.set(dep.symbol.id, dep);
	for (const dep of uniqueDependencies.values()) plugin.node(dep);
	for (const node of allNodes) plugin.node(node);
};

//#endregion
//#region src/plugins/@hey-api/sdk/plugin.ts
const handler$9 = (args) => handlerV1$2(args);

//#endregion
//#region src/plugins/@hey-api/sdk/config.ts
const defaultConfig$13 = {
	config: {
		auth: true,
		client: true,
		exportFromIndex: true,
		paramsStructure: "grouped",
		responseStyle: "fields",
		transformer: false,
		validator: false,
		response: "body"
	},
	dependencies: ["@hey-api/typescript"],
	handler: handler$9,
	name: "@hey-api/sdk",
	resolveConfig: (plugin, context) => {
		if (plugin.config.client) {
			if (typeof plugin.config.client === "boolean") plugin.config.client = context.pluginByTag("client", { defaultPlugin: "@hey-api/client-fetch" });
			plugin.dependencies.add(plugin.config.client);
		} else plugin.config.client = false;
		if (plugin.config.transformer) {
			if (typeof plugin.config.transformer === "boolean") plugin.config.transformer = context.pluginByTag("transformer");
			plugin.dependencies.add(plugin.config.transformer);
		} else plugin.config.transformer = false;
		if (typeof plugin.config.validator !== "object") plugin.config.validator = {
			request: plugin.config.validator,
			response: plugin.config.validator
		};
		if (plugin.config.validator.request) {
			if (typeof plugin.config.validator.request === "boolean") plugin.config.validator.request = context.pluginByTag("validator");
			plugin.dependencies.add(plugin.config.validator.request);
		} else plugin.config.validator.request = false;
		if (plugin.config.validator.response) {
			if (typeof plugin.config.validator.response === "boolean") plugin.config.validator.response = context.pluginByTag("validator");
			plugin.dependencies.add(plugin.config.validator.response);
		} else plugin.config.validator.response = false;
		plugin.config.examples = resolveExamples(plugin.config, context);
		plugin.config.operations = resolveOperations(plugin.config, context);
	}
};
/**
* Type helper for `@hey-api/sdk` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$13 = definePluginConfig(defaultConfig$13);

//#endregion
//#region src/plugins/@hey-api/transformers/expressions.ts
const bigIntExpressions = ({ dataExpression, schema }) => {
	if (schema.type !== "integer" || schema.format !== "int64") return;
	const bigIntCallExpression = dataExpression !== void 0 ? $("BigInt").call($.expr(dataExpression).attr("toString").call()) : void 0;
	if (bigIntCallExpression) {
		if (typeof dataExpression === "string") return [bigIntCallExpression];
		if (dataExpression) return [$.expr(dataExpression).assign(bigIntCallExpression)];
	}
};
const dateExpressions = ({ dataExpression, schema }) => {
	if (schema.type !== "string" || !(schema.format === "date" || schema.format === "date-time")) return;
	if (typeof dataExpression === "string") return [$.new("Date").arg(dataExpression)];
	if (dataExpression) return [$.expr(dataExpression).assign($.new("Date").arg(dataExpression))];
};

//#endregion
//#region src/plugins/@hey-api/transformers/plugin.ts
const dataVariableName = "data";
const buildingSymbols = /* @__PURE__ */ new Set();
const isNodeReturnStatement = (node) => node["~dsl"] === "ReturnTsDsl";
const schemaResponseTransformerNodes = ({ plugin, schema }) => {
	const nodes = processSchemaType({
		dataExpression: $(dataVariableName),
		plugin,
		schema
	});
	if (nodes.length) {
		const last = nodes[nodes.length - 1];
		if (!isNodeReturnStatement(last)) nodes.push($.return(dataVariableName));
	}
	return nodes;
};
const processSchemaType = ({ dataExpression, plugin, schema }) => {
	if (schema.$ref) {
		const query = {
			category: "transform",
			resource: "definition",
			resourceId: schema.$ref
		};
		const symbol = plugin.getSymbol(query) ?? plugin.symbol(applyNaming(refToName(schema.$ref), {
			case: "camelCase",
			name: "{{name}}SchemaResponseTransformer"
		}), { meta: query });
		if (!symbol.node && !buildingSymbols.has(symbol.id)) {
			buildingSymbols.add(symbol.id);
			try {
				const nodes = schemaResponseTransformerNodes({
					plugin,
					schema: plugin.context.resolveIrRef(schema.$ref)
				});
				if (nodes.length) {
					const node = $.const(symbol).assign($.func().param(dataVariableName, (p) => p.type("any")).do(...nodes));
					plugin.node(node);
				}
			} finally {
				buildingSymbols.delete(symbol.id);
			}
		}
		if (symbol.node || buildingSymbols.has(symbol.id)) {
			const callExpression = $(plugin.referenceSymbol(query)).call(dataExpression);
			if (dataExpression) {
				if (typeof dataExpression === "string" && dataExpression === "item") return [$.return(callExpression)];
				return [typeof dataExpression === "string" ? callExpression : $(dataExpression).assign(callExpression)];
			}
		}
		return [];
	}
	if (schema.type === "array") {
		if (!dataExpression || typeof dataExpression === "string") return [];
		const nodes = !schema.items ? [] : processSchemaType({
			dataExpression: "item",
			plugin,
			schema: schema.items?.[0] ? schema.items[0] : {
				...schema,
				type: void 0
			}
		});
		if (!nodes.length) return [];
		const mapCallbackStatements = nodes;
		if (!mapCallbackStatements.some((stmt) => isNodeReturnStatement(stmt))) mapCallbackStatements.push($.return("item"));
		return [$(dataExpression).assign($(dataExpression).attr("map").call($.func().param("item", (p) => p.type("any")).do(...mapCallbackStatements)))];
	}
	if (schema.type === "object") {
		let nodes = [];
		const required = schema.required ?? [];
		for (const name in schema.properties) {
			const property = schema.properties[name];
			const propertyAccessExpression = $(dataExpression || dataVariableName).attr(name);
			const propertyNodes = processSchemaType({
				dataExpression: propertyAccessExpression,
				plugin,
				schema: property
			});
			if (!propertyNodes.length) continue;
			const noNullableTypesInSchema = !property.items?.find((x) => x.type === "null");
			if (required.includes(name) && noNullableTypesInSchema) nodes = nodes.concat(propertyNodes);
			else nodes.push($.if(propertyAccessExpression).do(...propertyNodes));
		}
		return nodes;
	}
	if (schema.items) {
		if (schema.items.length === 1) return processSchemaType({
			dataExpression: "item",
			plugin,
			schema: schema.items[0]
		});
		let arrayNodes = [];
		if (schema.logicalOperator === "and" || schema.items.length === 2 && schema.items.find((item) => item.type === "null" || item.type === "void")) {
			for (const item of schema.items) {
				const nodes = processSchemaType({
					dataExpression: dataExpression || "item",
					plugin,
					schema: item
				});
				if (nodes.length) if (dataExpression) arrayNodes = arrayNodes.concat(nodes);
				else arrayNodes.push($.if("item").do(...nodes), $.return("item"));
			}
			return arrayNodes;
		}
		if (schema.type !== "enum") {
			if (!(schema.items ?? []).every((item) => [
				"boolean",
				"integer",
				"null",
				"number",
				"string"
			].includes(item.type))) console.warn(`â—ï¸ Transformers warning: schema ${JSON.stringify(schema)} is too complex and won't be currently processed. This will likely produce an incomplete transformer which is not what you want. Please open an issue if you'd like this improved https://github.com/hey-api/openapi-ts/issues`);
		}
	}
	for (const transformer of plugin.config.transformers) {
		const t = transformer({
			config: plugin.config,
			dataExpression,
			schema
		});
		if (t) return t;
	}
	return [];
};
const handler$8 = ({ plugin }) => {
	plugin.forEach("operation", ({ operation }) => {
		const { response } = operationResponsesMap(operation);
		if (!response) return;
		if (response.items && response.items.length > 1) {
			if (plugin.context.config.logs.level === "debug") console.warn(`â—ï¸ Transformers warning: route ${createOperationKey(operation)} has ${response.items.length} non-void success responses. This is currently not handled and we will not generate a response transformer. Please open an issue if you'd like this feature https://github.com/hey-api/openapi-ts/issues`);
			return;
		}
		const symbolResponse = plugin.querySymbol({
			category: "type",
			resource: "operation",
			resourceId: operation.id,
			role: "response"
		});
		if (!symbolResponse) return;
		const nodes = schemaResponseTransformerNodes({
			plugin,
			schema: response
		});
		if (!nodes.length) return;
		const symbol = plugin.symbol(applyNaming(operation.id, {
			case: "camelCase",
			name: "{{name}}ResponseTransformer"
		}), { meta: {
			category: "transform",
			resource: "operation",
			resourceId: operation.id,
			role: "response"
		} });
		const value = $.const(symbol).export().assign($.func().async().param(dataVariableName, (p) => p.type("any")).returns($.type("Promise").generic(symbolResponse)).do(...nodes));
		plugin.node(value);
	}, { order: "declarations" });
};

//#endregion
//#region src/plugins/@hey-api/transformers/config.ts
const defaultConfig$12 = {
	config: {
		bigInt: true,
		dates: true,
		exportFromIndex: false,
		transformers: [],
		typeTransformers: []
	},
	dependencies: ["@hey-api/typescript"],
	handler: handler$8,
	name: "@hey-api/transformers",
	resolveConfig: (plugin) => {
		if (!plugin.config.transformers) plugin.config.transformers = [];
		if (plugin.config.dates) plugin.config.transformers = [...plugin.config.transformers, dateExpressions];
		if (plugin.config.bigInt) plugin.config.transformers = [...plugin.config.transformers, bigIntExpressions];
	},
	tags: ["transformer"]
};
/**
* Type helper for `@hey-api/transformers`, returns {@link Plugin.Config} object
*/
const defineConfig$12 = definePluginConfig(defaultConfig$12);

//#endregion
//#region src/plugins/@hey-api/typescript/shared/clientOptions.ts
const serverToBaseUrlType = ({ server }) => {
	const url = parseUrl(server.url);
	if (url.protocol && url.host) return $.type.literal(server.url);
	return $.type.template().add(url.protocol || $.type("string")).add("://").add(url.host || $.type("string")).add(url.port ? `:${url.port}` : "").add(url.path || "");
};
const createClientOptions = ({ nodeIndex, plugin, servers }) => {
	const client = getClientPlugin(plugin.context.config);
	const types = servers.map((server) => serverToBaseUrlType({ server }));
	if (!servers.length) types.push($.type("string"));
	else if (!("strictBaseUrl" in client.config && client.config.strictBaseUrl)) types.push($.type.and($.type("string"), $.type.object()));
	const symbol = plugin.symbol(applyNaming("ClientOptions", { case: plugin.config.case }), { meta: {
		category: "type",
		resource: "client",
		role: "options",
		tool: "typescript"
	} });
	const node = $.type.alias(symbol).export().type($.type.object().prop(getClientBaseUrlKey(plugin.context.config), (p) => p.type($.type.or(...types))));
	plugin.node(node, nodeIndex);
};

//#endregion
//#region src/plugins/shared/utils/schema.ts
const createSchemaComment = (schema) => {
	const comments = [];
	if (schema.title) comments.push(escapeComment(schema.title));
	if (schema.description) {
		if (comments.length) comments.push("");
		comments.push(escapeComment(schema.description));
	}
	if (schema.deprecated) {
		if (comments.length) comments.push("");
		comments.push("@deprecated");
	}
	return comments.length ? comments : void 0;
};

//#endregion
//#region src/plugins/@hey-api/typescript/shared/export.ts
const schemaToEnumObject = ({ plugin, schema }) => {
	const typeofItems = [];
	return {
		obj: (schema.items ?? []).map((item, index) => {
			const typeOfItemConst = typeof item.const;
			if (!typeofItems.includes(typeOfItemConst)) typeofItems.push(typeOfItemConst);
			let key;
			if (item.title) key = item.title;
			else if (typeOfItemConst === "number" || typeOfItemConst === "string") key = `${item.const}`;
			else if (typeOfItemConst === "boolean") key = item.const ? "true" : "false";
			else if (item.const === null) key = "null";
			else key = `${index}`;
			if (key) {
				key = toCase(key, plugin.config.enums.case, { stripLeadingSeparators: false });
				regexp.number.lastIndex = 0;
				if (regexp.number.test(key) && plugin.config.enums.enabled && (plugin.config.enums.mode === "typescript" || plugin.config.enums.mode === "typescript-const")) key = `_${key}`;
			}
			return {
				key,
				schema: item
			};
		}),
		typeofItems
	};
};
const exportType = ({ plugin, schema, state, type }) => {
	const $ref = pathToJsonPointer((0, _hey_api_codegen_core.fromRef)(state.path));
	if (schema.type === "enum" && plugin.config.enums.enabled) {
		const enumObject = schemaToEnumObject({
			plugin,
			schema
		});
		if (plugin.config.enums.mode === "javascript") {
			if (plugin.config.enums.constantsIgnoreNull && enumObject.typeofItems.includes("object")) enumObject.obj = enumObject.obj.filter((item) => item.schema.const !== null);
			const symbolObject = plugin.symbol(applyNaming(refToName($ref), plugin.config.definitions), { meta: {
				category: "utility",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "definition",
				resourceId: $ref,
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "typescript"
			} });
			const objectNode = $.const(symbolObject).export().$if(createSchemaComment(schema), (c, v) => c.doc(v)).assign($.object(...enumObject.obj.map((item) => $.prop({
				kind: "prop",
				name: item.key
			}).$if(createSchemaComment(item.schema), (p, v) => p.doc(v)).value($.fromValue(item.schema.const)))).as("const"));
			plugin.node(objectNode);
			const symbol$1 = plugin.symbol(applyNaming(refToName($ref), plugin.config.definitions), { meta: {
				category: "type",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "definition",
				resourceId: $ref,
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "typescript"
			} });
			const node$1 = $.type.alias(symbol$1).export().$if(createSchemaComment(schema), (t, v) => t.doc(v)).type($.type(symbol$1).idx($.type(symbol$1).typeofType().keyof()).typeofType());
			plugin.node(node$1);
			return;
		} else if (plugin.config.enums.mode === "typescript" || plugin.config.enums.mode === "typescript-const") {
			if (!enumObject.typeofItems.some((type$1) => type$1 !== "number" && type$1 !== "string")) {
				const symbol$1 = plugin.symbol(applyNaming(refToName($ref), plugin.config.definitions), { meta: {
					category: "type",
					path: (0, _hey_api_codegen_core.fromRef)(state.path),
					resource: "definition",
					resourceId: $ref,
					tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
					tool: "typescript"
				} });
				const enumNode = $.enum(symbol$1).export().$if(createSchemaComment(schema), (e, v) => e.doc(v)).const(plugin.config.enums.mode === "typescript-const").members(...enumObject.obj.map((item) => $.member(item.key).$if(createSchemaComment(item.schema), (m, v) => m.doc(v)).value($.fromValue(item.schema.const))));
				plugin.node(enumNode);
				return;
			}
		}
	}
	const symbol = plugin.symbol(applyNaming(refToName($ref), plugin.config.definitions), { meta: {
		category: "type",
		path: (0, _hey_api_codegen_core.fromRef)(state.path),
		resource: "definition",
		resourceId: $ref,
		tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
		tool: "typescript"
	} });
	const node = $.type.alias(symbol).export().$if(createSchemaComment(schema), (t, v) => t.doc(v)).type(type);
	plugin.node(node);
};

//#endregion
//#region src/plugins/@hey-api/typescript/shared/operation.ts
const irParametersToIrSchema = ({ parameters }) => {
	const irSchema = { type: "object" };
	if (parameters) {
		const properties = {};
		const required = [];
		for (const key in parameters) {
			const parameter = parameters[key];
			properties[parameter.name] = deduplicateSchema({
				detectFormat: false,
				schema: parameter.schema
			});
			if (parameter.required) required.push(parameter.name);
		}
		irSchema.properties = properties;
		if (required.length) irSchema.required = required;
	}
	return irSchema;
};
const operationToDataType$1 = ({ operation, plugin, state }) => {
	const data = { type: "object" };
	const dataRequired = [];
	if (!data.properties) data.properties = {};
	if (operation.body) {
		data.properties.body = operation.body.schema;
		if (operation.body.required) dataRequired.push("body");
	} else data.properties.body = { type: "never" };
	if (operation.parameters?.header) {
		data.properties.headers = irParametersToIrSchema({ parameters: operation.parameters.header });
		if (data.properties.headers.required) dataRequired.push("headers");
	}
	if (operation.parameters?.path) {
		data.properties.path = irParametersToIrSchema({ parameters: operation.parameters.path });
		if (data.properties.path.required) dataRequired.push("path");
	} else data.properties.path = { type: "never" };
	if (operation.parameters?.query) {
		data.properties.query = irParametersToIrSchema({ parameters: operation.parameters.query });
		if (data.properties.query.required) dataRequired.push("query");
	} else data.properties.query = { type: "never" };
	data.properties.url = {
		const: operation.path,
		type: "string"
	};
	dataRequired.push("url");
	data.required = dataRequired;
	const symbol = plugin.symbol(applyNaming(operation.id, plugin.config.requests), { meta: {
		category: "type",
		path: (0, _hey_api_codegen_core.fromRef)(state.path),
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
		tool: "typescript"
	} });
	const node = $.type.alias(symbol).export().type(irSchemaToAst$5({
		plugin,
		schema: data,
		state
	}));
	plugin.node(node);
};
const operationToType = ({ operation, plugin, state }) => {
	operationToDataType$1({
		operation,
		plugin,
		state
	});
	const { error, errors, response, responses } = operationResponsesMap(operation);
	if (errors) {
		const symbolErrors = plugin.symbol(applyNaming(operation.id, plugin.config.errors), { meta: {
			category: "type",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "operation",
			resourceId: operation.id,
			role: "errors",
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "typescript"
		} });
		const node = $.type.alias(symbolErrors).export().type(irSchemaToAst$5({
			plugin,
			schema: errors,
			state
		}));
		plugin.node(node);
		if (error) {
			const symbol = plugin.symbol(applyNaming(operation.id, {
				case: plugin.config.errors.case,
				name: plugin.config.errors.error
			}), { meta: {
				category: "type",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "operation",
				resourceId: operation.id,
				role: "error",
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "typescript"
			} });
			const node$1 = $.type.alias(symbol).export().type($.type(symbolErrors).idx($.type(symbolErrors).keyof()));
			plugin.node(node$1);
		}
	}
	if (responses) {
		const symbolResponses = plugin.symbol(applyNaming(operation.id, plugin.config.responses), { meta: {
			category: "type",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "operation",
			resourceId: operation.id,
			role: "responses",
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "typescript"
		} });
		const node = $.type.alias(symbolResponses).export().type(irSchemaToAst$5({
			plugin,
			schema: responses,
			state
		}));
		plugin.node(node);
		if (response) {
			const symbol = plugin.symbol(applyNaming(operation.id, {
				case: plugin.config.responses.case,
				name: plugin.config.responses.response
			}), { meta: {
				category: "type",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "operation",
				resourceId: operation.id,
				role: "response",
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "typescript"
			} });
			const node$1 = $.type.alias(symbol).export().type($.type(symbolResponses).idx($.type(symbolResponses).keyof()));
			plugin.node(node$1);
		}
	}
};

//#endregion
//#region src/plugins/@hey-api/typescript/shared/webhook.ts
const operationToDataType = ({ operation, plugin, state }) => {
	const data = { type: "object" };
	const dataRequired = [];
	if (!data.properties) data.properties = {};
	if (operation.body) {
		const symbolWebhookPayload = plugin.symbol(applyNaming(operation.id, {
			case: plugin.config.webhooks.case,
			name: plugin.config.webhooks.payload
		}), { meta: {
			category: "type",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "webhook",
			resourceId: operation.id,
			role: "data",
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "typescript"
		} });
		const node$1 = $.type.alias(symbolWebhookPayload).export().$if(createSchemaComment(operation.body.schema), (t, v) => t.doc(v)).type(irSchemaToAst$5({
			plugin,
			schema: operation.body.schema,
			state
		}));
		plugin.node(node$1);
		data.properties.body = { symbolRef: symbolWebhookPayload };
		dataRequired.push("body");
	} else data.properties.body = { type: "never" };
	data.properties.key = {
		const: operation.path,
		type: "string"
	};
	dataRequired.push("key");
	data.properties.path = { type: "never" };
	data.properties.query = { type: "never" };
	data.required = dataRequired;
	const symbolWebhookRequest = plugin.symbol(applyNaming(operation.id, plugin.config.webhooks), { meta: {
		category: "type",
		path: (0, _hey_api_codegen_core.fromRef)(state.path),
		resource: "webhook",
		resourceId: operation.id,
		role: "data",
		tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
		tool: "typescript"
	} });
	const node = $.type.alias(symbolWebhookRequest).export().type(irSchemaToAst$5({
		plugin,
		schema: data,
		state
	}));
	plugin.node(node);
	return symbolWebhookRequest;
};
const webhookToType = ({ operation, plugin, state }) => {
	return operationToDataType({
		operation,
		plugin,
		state
	});
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/array.ts
const arrayToAst$4 = ({ plugin, schema, state }) => {
	if (!schema.items) return $.type("Array").generic($.type(plugin.config.topType));
	schema = deduplicateSchema({
		detectFormat: true,
		schema
	});
	const itemTypes = [];
	if (schema.items) schema.items.forEach((item, index) => {
		const type = irSchemaToAst$5({
			plugin,
			schema: item,
			state: {
				...state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(state.path),
					"items",
					index
				])
			}
		});
		itemTypes.push(type);
	});
	if (itemTypes.length === 1) return $.type("Array").generic(itemTypes[0]);
	return schema.logicalOperator === "and" ? $.type("Array").generic($.type.and(...itemTypes)) : $.type("Array").generic($.type.or(...itemTypes));
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/boolean.ts
const booleanToAst$4 = ({ schema }) => {
	if (schema.const !== void 0) return $.type.literal(schema.const);
	return $.type("boolean");
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/enum.ts
const enumToAst$4 = ({ plugin, schema, state }) => {
	return irSchemaToAst$5({
		plugin,
		schema: {
			...schema,
			type: void 0
		},
		state
	});
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/never.ts
const neverToAst$4 = (_args) => {
	return $.type("never");
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/null.ts
const nullToAst$5 = (_args) => {
	return $.type.literal(null);
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/number.ts
const numberToAst = ({ plugin, schema }) => {
	if (schema.const !== void 0) return $.type.literal(schema.const);
	if (schema.type === "integer" && schema.format === "int64") {
		if (plugin.getPlugin("@hey-api/transformers")?.config.bigInt) return $.type("bigint");
	}
	return $.type("number");
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/object.ts
const objectToAst$5 = ({ plugin, schema, state }) => {
	const shape = $.type.object();
	const required = schema.required ?? [];
	let indexSchemas = [];
	let hasOptionalProperties = false;
	for (const name in schema.properties) {
		const property = schema.properties[name];
		const propertyType = irSchemaToAst$5({
			plugin,
			schema: property,
			state: {
				...state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(state.path),
					"properties",
					name
				])
			}
		});
		const isRequired = required.includes(name);
		shape.prop(name, (p) => p.$if(createSchemaComment(property), (p$1, v) => p$1.doc(v)).readonly(property.accessScope === "read").required(isRequired).type(propertyType));
		indexSchemas.push(property);
		if (!isRequired) hasOptionalProperties = true;
	}
	if (schema.patternProperties) for (const pattern in schema.patternProperties) {
		const ir = schema.patternProperties[pattern];
		indexSchemas.unshift(ir);
	}
	const hasPatterns = !!schema.patternProperties && Object.keys(schema.patternProperties).length > 0;
	const addPropsRaw = schema.additionalProperties;
	const addPropsObj = addPropsRaw !== false && addPropsRaw ? addPropsRaw : void 0;
	if (hasPatterns || !!addPropsObj && (addPropsObj.type !== "never" || !indexSchemas.length)) {
		const addProps = addPropsObj;
		if (addProps && addProps.type !== "never") indexSchemas.unshift(addProps);
		else if (!hasPatterns && !indexSchemas.length && addProps && addProps.type === "never") indexSchemas = [addProps];
		if (hasOptionalProperties) indexSchemas.push({ type: "undefined" });
		const type = indexSchemas.length === 1 ? irSchemaToAst$5({
			plugin,
			schema: indexSchemas[0],
			state
		}) : irSchemaToAst$5({
			plugin,
			schema: {
				items: indexSchemas,
				logicalOperator: "or"
			},
			state
		});
		if (schema.propertyNames?.$ref) return $.type.mapped("key").key(irSchemaToAst$5({
			plugin,
			schema: { $ref: schema.propertyNames.$ref },
			state
		})).optional().type(type);
		shape.idxSig("key", (i) => i.key("string").type(type));
	}
	return shape;
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/string.ts
const stringToAst$1 = ({ plugin, schema }) => {
	if (schema.const !== void 0) return $.type.literal(schema.const);
	if (schema.format) {
		if (schema.format === "binary") return $.type.or($.type("Blob"), $.type("File"));
		if (schema.format === "date-time" || schema.format === "date") {
			if (plugin.getPlugin("@hey-api/transformers")?.config.dates) return $.type("Date");
		}
		if (schema.format === "typeid" && typeof schema.example === "string") {
			const parts = String(schema.example).split("_");
			parts.pop();
			const type = parts.join("_");
			const query = {
				category: "type",
				resource: "type-id",
				resourceId: type,
				tool: "typescript"
			};
			if (!plugin.getSymbol(query)) {
				const queryTypeId = {
					category: "type",
					resource: "type-id",
					tool: "typescript",
					variant: "container"
				};
				if (!plugin.getSymbol(queryTypeId)) {
					const symbolTypeId$1 = plugin.symbol("TypeID", { meta: queryTypeId });
					const nodeTypeId = $.type.alias(symbolTypeId$1).export().generic("T", (g) => g.extends("string")).type($.type.template().add($.type("T")).add("_").add($.type("string")));
					plugin.node(nodeTypeId);
				}
				const symbolTypeId = plugin.referenceSymbol(queryTypeId);
				const symbolTypeName = plugin.symbol(toCase(`${type}_id`, plugin.config.case), { meta: query });
				const node = $.type.alias(symbolTypeName).export().type($.type(symbolTypeId).generic($.type.literal(type)));
				plugin.node(node);
			}
			const symbol = plugin.referenceSymbol(query);
			return $.type(symbol);
		}
	}
	return $.type("string");
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/tuple.ts
const tupleToAst$4 = ({ plugin, schema, state }) => {
	let itemTypes = [];
	if (schema.const && Array.isArray(schema.const)) itemTypes = schema.const.map((value) => $.type.fromValue(value));
	else if (schema.items) schema.items.forEach((item, index) => {
		const type = irSchemaToAst$5({
			plugin,
			schema: item,
			state: {
				...state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(state.path),
					"items",
					index
				])
			}
		});
		itemTypes.push(type);
	});
	return $.type.tuple(...itemTypes);
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/undefined.ts
const undefinedToAst$4 = (_args) => {
	return $.type("undefined");
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/unknown.ts
const unknownToAst$4 = ({ plugin }) => {
	return $.type(plugin.config.topType);
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/void.ts
const voidToAst$4 = (_args) => {
	return $.type("void");
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/toAst/index.ts
const irSchemaWithTypeToAst$5 = ({ schema, ...args }) => {
	const transformersPlugin = args.plugin.getPlugin("@hey-api/transformers");
	if (transformersPlugin?.config.typeTransformers) for (const typeTransformer of transformersPlugin.config.typeTransformers) {
		const typeNode = typeTransformer({ schema });
		if (typeNode) return typeNode;
	}
	switch (schema.type) {
		case "array": return arrayToAst$4({
			...args,
			schema
		});
		case "boolean": return booleanToAst$4({
			...args,
			schema
		});
		case "enum": return enumToAst$4({
			...args,
			schema
		});
		case "integer":
		case "number": return numberToAst({
			...args,
			schema
		});
		case "never": return neverToAst$4({
			...args,
			schema
		});
		case "null": return nullToAst$5({
			...args,
			schema
		});
		case "object": return objectToAst$5({
			...args,
			schema
		});
		case "string": return stringToAst$1({
			...args,
			schema
		});
		case "tuple": return tupleToAst$4({
			...args,
			schema
		});
		case "undefined": return undefinedToAst$4({
			...args,
			schema
		});
		case "unknown": return unknownToAst$4({
			...args,
			schema
		});
		case "void": return voidToAst$4({
			...args,
			schema
		});
	}
};

//#endregion
//#region src/plugins/@hey-api/typescript/v1/plugin.ts
const irSchemaToAst$5 = ({ plugin, schema, state }) => {
	if (schema.symbolRef) {
		const baseType = $.type(schema.symbolRef);
		if (schema.omit && schema.omit.length > 0) {
			const omittedKeys = schema.omit.length === 1 ? $.type.literal(schema.omit[0]) : $.type.or(...schema.omit.map((key) => $.type.literal(key)));
			return $.type("Omit").generics(baseType, omittedKeys);
		}
		return baseType;
	}
	if (schema.$ref) {
		const symbol = plugin.referenceSymbol({
			category: "type",
			resource: "definition",
			resourceId: schema.$ref
		});
		const baseType = $.type(symbol);
		if (schema.omit && schema.omit.length > 0) {
			const omittedKeys = schema.omit.length === 1 ? $.type.literal(schema.omit[0]) : $.type.or(...schema.omit.map((key) => $.type.literal(key)));
			return $.type("Omit").generics(baseType, omittedKeys);
		}
		return baseType;
	}
	if (schema.type) return irSchemaWithTypeToAst$5({
		plugin,
		schema,
		state
	});
	if (schema.items) {
		schema = deduplicateSchema({
			detectFormat: false,
			schema
		});
		if (schema.items) {
			const itemTypes = schema.items.map((item) => irSchemaToAst$5({
				plugin,
				schema: item,
				state
			}));
			return schema.logicalOperator === "and" ? $.type.and(...itemTypes) : $.type.or(...itemTypes);
		}
		return irSchemaToAst$5({
			plugin,
			schema,
			state
		});
	}
	return irSchemaWithTypeToAst$5({
		plugin,
		schema: { type: "unknown" },
		state
	});
};
const handleComponent$5 = ({ plugin, schema, state }) => {
	exportType({
		plugin,
		schema,
		state,
		type: irSchemaToAst$5({
			plugin,
			schema,
			state
		})
	});
};
const handlerV1$1 = ({ plugin }) => {
	const nodeClientIndex = plugin.node(null);
	const nodeWebhooksIndex = plugin.node(null);
	const servers = [];
	const webhooks = [];
	plugin.forEach("operation", "parameter", "requestBody", "schema", "server", "webhook", (event) => {
		const state = (0, _hey_api_codegen_core.refs)({
			path: event._path,
			tags: event.tags
		});
		switch (event.type) {
			case "operation":
				operationToType({
					operation: event.operation,
					plugin,
					state
				});
				break;
			case "parameter":
				handleComponent$5({
					plugin,
					schema: event.parameter.schema,
					state
				});
				break;
			case "requestBody":
				handleComponent$5({
					plugin,
					schema: event.requestBody.schema,
					state
				});
				break;
			case "schema":
				handleComponent$5({
					plugin,
					schema: event.schema,
					state
				});
				break;
			case "server":
				servers.push(event.server);
				break;
			case "webhook":
				webhooks.push(webhookToType({
					operation: event.operation,
					plugin,
					state
				}));
				break;
		}
	}, { order: "declarations" });
	createClientOptions({
		nodeIndex: nodeClientIndex,
		plugin,
		servers
	});
	if (webhooks.length > 0) {
		const symbol = plugin.symbol(applyNaming("Webhooks", { case: plugin.config.case }), { meta: {
			category: "type",
			resource: "webhook",
			tool: "typescript",
			variant: "container"
		} });
		const node = $.type.alias(symbol).export().type($.type.or(...webhooks));
		plugin.node(node, nodeWebhooksIndex);
	}
};

//#endregion
//#region src/plugins/@hey-api/typescript/api.ts
var Api$3 = class {
	schemaToType(args) {
		return irSchemaToAst$5(args);
	}
};

//#endregion
//#region src/plugins/@hey-api/typescript/plugin.ts
const handler$7 = (args) => handlerV1$1(args);

//#endregion
//#region src/plugins/@hey-api/typescript/config.ts
const defaultConfig$11 = {
	api: new Api$3(),
	config: {
		case: "PascalCase",
		exportFromIndex: true,
		topType: "unknown"
	},
	handler: handler$7,
	name: "@hey-api/typescript",
	resolveConfig: (plugin, context) => {
		plugin.config.definitions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "PascalCase",
				name: "{{name}}"
			},
			mappers: {
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.definitions
		});
		plugin.config.enums = context.valueToObject({
			defaultValue: {
				case: "SCREAMING_SNAKE_CASE",
				constantsIgnoreNull: false,
				enabled: Boolean(plugin.config.enums),
				mode: "javascript"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				string: (mode) => ({ mode })
			},
			value: plugin.config.enums
		});
		plugin.config.errors = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "PascalCase",
				error: "{{name}}Error",
				name: "{{name}}Errors"
			},
			mappers: {
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.errors
		});
		plugin.config.requests = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "PascalCase",
				name: "{{name}}Data"
			},
			mappers: {
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.requests
		});
		plugin.config.responses = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "PascalCase",
				name: "{{name}}Responses",
				response: "{{name}}Response"
			},
			mappers: {
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.responses
		});
		plugin.config.webhooks = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "PascalCase",
				name: "{{name}}WebhookRequest",
				payload: "{{name}}WebhookPayload"
			},
			mappers: {
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.webhooks
		});
	}
};
/**
* Type helper for `@hey-api/typescript` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$11 = definePluginConfig(defaultConfig$11);

//#endregion
//#region src/plugins/@pinia/colada/meta.ts
const handleMeta$1 = (plugin, operation, configPath) => {
	const metaFn = plugin.config[configPath].meta;
	if (!metaFn) return;
	const metaObject = metaFn(operation);
	if (!Object.keys(metaObject).length) return;
	return $.fromValue(metaObject);
};

//#endregion
//#region src/plugins/@pinia/colada/useType.ts
const useTypeData$1 = ({ operation, plugin }) => {
	return operationOptionsType({
		operation,
		plugin: plugin.getPluginOrThrow("@hey-api/sdk")
	});
};
const useTypeError$1 = ({ operation, plugin }) => {
	const client = getClientPlugin(plugin.context.config);
	const symbolError = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "error"
	}) || "Error";
	if (client.name === "@hey-api/client-axios") {
		const symbol = plugin.external("axios.AxiosError");
		return $.type(symbol).generic(symbolError);
	}
	return $.type(symbolError);
};
const useTypeResponse$1 = ({ operation, plugin }) => {
	const symbolResponseType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "response"
	});
	return $.type(symbolResponseType ?? "unknown");
};

//#endregion
//#region src/plugins/@pinia/colada/utils.ts
const getPublicTypeData = ({ isNuxtClient, operation, plugin }) => {
	const typeData = useTypeData$1({
		operation,
		plugin
	});
	return isNuxtClient ? $.type("Omit").generic(typeData).generic("composable") : typeData;
};

//#endregion
//#region src/plugins/@pinia/colada/mutationOptions.ts
const createMutationOptions$1 = ({ operation, plugin }) => {
	const symbolMutationOptionsType = plugin.external(`${plugin.name}.UseMutationOptions`);
	const isNuxtClient = getClientPlugin(plugin.context.config).name === "@hey-api/client-nuxt";
	const typeData = getPublicTypeData({
		isNuxtClient,
		operation,
		plugin
	});
	const options = plugin.symbol("options");
	const fnOptions$1 = plugin.symbol("vars");
	const awaitSdkFn = $.lazy((ctx$1) => ctx$1.access(plugin.referenceSymbol({
		category: "sdk",
		resource: "operation",
		resourceId: operation.id
	})).call($.object().pretty().spread(options).spread(fnOptions$1).prop("throwOnError", $.literal(true))).await());
	const statements = [];
	if (plugin.getPluginOrThrow("@hey-api/sdk").config.responseStyle === "data") statements.push($.return(awaitSdkFn));
	else statements.push($.const().object("data").assign(awaitSdkFn), $.return("data"));
	const mutationOpts = $.object().pretty().prop("mutation", $.func().async().param(fnOptions$1, (p) => p.$if(isNuxtClient, (f$1) => f$1.type($.type("Partial").generic(typeData)))).do(...statements)).$if(handleMeta$1(plugin, operation, "mutationOptions"), (o, v) => o.prop("meta", v));
	const symbolMutationOptions = plugin.symbol(applyNaming(operation.id, plugin.config.mutationOptions));
	const statement = $.const(symbolMutationOptions).export().$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v)).assign($.func().param(options, (p) => p.optional().type($.type("Partial").generic(typeData))).returns($.type(symbolMutationOptionsType).generic(useTypeResponse$1({
		operation,
		plugin
	})).generic(typeData).generic(useTypeError$1({
		operation,
		plugin
	}))).do($.return(mutationOpts)));
	plugin.node(statement);
};

//#endregion
//#region src/plugins/@pinia/colada/queryKey.ts
const TOptionsType$1 = "TOptions";
const createQueryKeyFunction$1 = ({ plugin }) => {
	const symbolCreateQueryKey = plugin.symbol(applyNaming("createQueryKey", { case: plugin.config.case }), { meta: {
		category: "utility",
		resource: "createQueryKey",
		tool: plugin.name
	} });
	const symbolQueryKeyType = plugin.referenceSymbol({
		category: "type",
		resource: "QueryKey",
		tool: plugin.name
	});
	const symbolJsonValue = plugin.external(`${plugin.name}._JSONValue`);
	const returnType = $.type(symbolQueryKeyType).generic(TOptionsType$1).idx(0);
	const baseUrlKey = getClientBaseUrlKey(plugin.context.config);
	const symbolOptions = plugin.referenceSymbol({
		category: "type",
		resource: "client-options",
		tool: "sdk"
	});
	const symbolClient = plugin.getSymbol({ category: "client" });
	const clientModule = clientFolderAbsolutePath(plugin.context.config);
	const symbolSerializeQueryValue = plugin.symbol("serializeQueryKeyValue", {
		external: clientModule,
		meta: {
			category: "external",
			resource: `${clientModule}.serializeQueryKeyValue`
		}
	});
	const fn = $.const(symbolCreateQueryKey).assign($.func().param("id", (p) => p.type("string")).param("options", (p) => p.optional().type(TOptionsType$1)).param("tags", (p) => p.optional().type("ReadonlyArray<string>")).returns($.type.tuple(returnType)).generic(TOptionsType$1, (g) => g.extends(symbolOptions)).do($.const("params").type(returnType).assign($.object().prop("_id", "id").prop(baseUrlKey, $("options").attr(baseUrlKey).optional().or($("options").attr("client").optional().$if(symbolClient, (a, v) => a.coalesce(v)).attr("getConfig").call().attr(baseUrlKey))).as(returnType)), $.if("tags").do($("params").attr("tags").assign($("tags").as("unknown").as(symbolJsonValue))), $.if($("options").attr("body").optional().neq($.id("undefined"))).do($.const("normalizedBody").assign($(symbolSerializeQueryValue).call($("options").attr("body"))), $.if($("normalizedBody").neq($.id("undefined"))).do($("params").attr("body").assign("normalizedBody"))), $.if($("options").attr("path").optional()).do($("params").attr("path").assign($("options").attr("path"))), $.if($("options").attr("query").optional().neq($.id("undefined"))).do($.const("normalizedQuery").assign($(symbolSerializeQueryValue).call($("options").attr("query"))), $.if($("normalizedQuery").neq($.id("undefined"))).do($("params").attr("query").assign("normalizedQuery"))), $.return($.array($("params")))));
	plugin.node(fn);
};
const createQueryKeyLiteral$1 = ({ id, operation, plugin }) => {
	const config = plugin.config.queryKeys;
	let tagsExpression;
	if (config.tags && operation.tags && operation.tags.length > 0) tagsExpression = $.array(...operation.tags.map((tag) => $.literal(tag)));
	return $(plugin.referenceSymbol({
		category: "utility",
		resource: "createQueryKey",
		tool: plugin.name
	})).call($.literal(id), "options", tagsExpression);
};
const createQueryKeyType$1 = ({ plugin }) => {
	const symbolJsonValue = plugin.external(`${plugin.name}._JSONValue`);
	const symbolOptions = plugin.referenceSymbol({
		category: "type",
		resource: "client-options",
		tool: "sdk"
	});
	const symbolQueryKeyType = plugin.symbol("QueryKey", { meta: {
		category: "type",
		resource: "QueryKey",
		tool: plugin.name
	} });
	const queryKeyType = $.type.alias(symbolQueryKeyType).export().generic(TOptionsType$1, (g) => g.extends($.type(symbolOptions))).type($.type.tuple($.type.and($.type(`Pick<${TOptionsType$1}, 'path'>`), $.type.object().prop("_id", (p) => p.type("string")).prop(getClientBaseUrlKey(plugin.context.config), (p) => p.optional().type(symbolJsonValue)).prop("body", (p) => p.optional().type(symbolJsonValue)).prop("query", (p) => p.optional().type(symbolJsonValue)).prop("tags", (p) => p.optional().type(symbolJsonValue)))));
	plugin.node(queryKeyType);
};
const queryKeyStatement$1 = ({ operation, plugin, symbol }) => {
	const isNuxtClient = getClientPlugin(plugin.context.config).name === "@hey-api/client-nuxt";
	return $.const(symbol).export().assign($.func().param("options", (p) => p.required(hasOperationDataRequired(operation)).type(getPublicTypeData({
		isNuxtClient,
		operation,
		plugin
	}))).do(createQueryKeyLiteral$1({
		id: operation.id,
		operation,
		plugin
	}).return()));
};

//#endregion
//#region src/plugins/@pinia/colada/queryOptions.ts
const optionsParamName$2 = "options";
const fnOptions = "context";
const createQueryOptions$1 = ({ operation, plugin }) => {
	if (hasOperationSse({ operation })) return;
	const isRequiredOptions = isOperationOptionsRequired({
		context: plugin.context,
		operation
	});
	if (!plugin.getSymbol({
		category: "utility",
		resource: "createQueryKey",
		tool: plugin.name
	})) {
		createQueryKeyType$1({ plugin });
		createQueryKeyFunction$1({ plugin });
	}
	let keyExpression;
	if (plugin.config.queryKeys.enabled) {
		const symbolQueryKey = plugin.symbol(applyNaming(operation.id, plugin.config.queryKeys));
		const node = queryKeyStatement$1({
			operation,
			plugin,
			symbol: symbolQueryKey
		});
		plugin.node(node);
		keyExpression = $(symbolQueryKey).call(optionsParamName$2);
	} else {
		const symbolCreateQueryKey = plugin.referenceSymbol({
			category: "utility",
			resource: "createQueryKey",
			tool: plugin.name
		});
		let tagsExpr;
		if (plugin.config.queryKeys.tags && operation.tags && operation.tags.length > 0) tagsExpr = $.array(...operation.tags.map((t) => $.literal(t)));
		keyExpression = $(symbolCreateQueryKey).call($.literal(operation.id), optionsParamName$2, tagsExpr);
	}
	const typeData = getPublicTypeData({
		isNuxtClient: getClientPlugin(plugin.context.config).name === "@hey-api/client-nuxt",
		operation,
		plugin
	});
	const awaitSdkFn = $.lazy((ctx$1) => ctx$1.access(plugin.referenceSymbol({
		category: "sdk",
		resource: "operation",
		resourceId: operation.id
	})).call($.object().spread(optionsParamName$2).spread(fnOptions).prop("throwOnError", $.literal(true))).await());
	const statements = [];
	if (plugin.getPluginOrThrow("@hey-api/sdk").config.responseStyle === "data") statements.push($.return(awaitSdkFn));
	else statements.push($.const().object("data").assign(awaitSdkFn), $.return("data"));
	const queryOpts = $.object().pretty().prop("key", keyExpression).prop("query", $.func().async().param(fnOptions).do(...statements)).$if(handleMeta$1(plugin, operation, "queryOptions"), (o, v) => o.prop("meta", v));
	const symbolQueryOptionsFn = plugin.symbol(applyNaming(operation.id, plugin.config.queryOptions), { meta: {
		category: "hook",
		resource: "operation",
		resourceId: operation.id,
		role: "queryOptions",
		tool: plugin.name
	} });
	const symbolDefineQueryOptions = plugin.external(`${plugin.name}.defineQueryOptions`);
	const statement = $.const(symbolQueryOptionsFn).export().$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v)).assign($(symbolDefineQueryOptions).call($.func().param(optionsParamName$2, (p) => p.required(isRequiredOptions).type(typeData)).do($.return(queryOpts))));
	plugin.node(statement);
};

//#endregion
//#region src/plugins/@pinia/colada/v0/plugin.ts
const handlerV0 = ({ plugin }) => {
	plugin.symbol("defineQueryOptions", {
		external: plugin.name,
		meta: {
			category: "external",
			resource: `${plugin.name}.defineQueryOptions`
		}
	});
	plugin.symbol("UseMutationOptions", {
		external: plugin.name,
		kind: "type",
		meta: {
			category: "external",
			resource: `${plugin.name}.UseMutationOptions`
		}
	});
	plugin.symbol("UseQueryOptions", {
		external: plugin.name,
		kind: "type",
		meta: {
			category: "external",
			resource: `${plugin.name}.UseQueryOptions`
		}
	});
	plugin.symbol("_JSONValue", {
		external: plugin.name,
		kind: "type",
		meta: {
			category: "external",
			resource: `${plugin.name}._JSONValue`
		}
	});
	plugin.symbol("AxiosError", {
		external: "axios",
		kind: "type",
		meta: {
			category: "external",
			resource: "axios.AxiosError"
		}
	});
	plugin.forEach("operation", ({ operation }) => {
		if (plugin.hooks.operation.isQuery(operation)) {
			if (plugin.config.queryOptions.enabled) createQueryOptions$1({
				operation,
				plugin
			});
		}
		if (plugin.hooks.operation.isMutation(operation)) {
			if (plugin.config.mutationOptions.enabled) createMutationOptions$1({
				operation,
				plugin
			});
		}
	}, { order: "declarations" });
};

//#endregion
//#region src/plugins/@pinia/colada/plugin.ts
const handler$6 = (args) => handlerV0(args);

//#endregion
//#region src/plugins/@pinia/colada/config.ts
const defaultConfig$10 = {
	config: {
		case: "camelCase",
		comments: true,
		exportFromIndex: false
	},
	dependencies: ["@hey-api/typescript", "@hey-api/sdk"],
	handler: handler$6,
	name: "@pinia/colada",
	resolveConfig: (plugin, context) => {
		plugin.config.mutationOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}Mutation"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.mutationOptions
		});
		plugin.config.queryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}QueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryKeys
		});
		plugin.config.queryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}Query"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryOptions
		});
	}
};
/**
* Type helper for `@pinia/colada` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$10 = definePluginConfig(defaultConfig$10);

//#endregion
//#region src/plugins/@tanstack/query-core/shared/useType.ts
const useTypeData = ({ operation, plugin }) => {
	return operationOptionsType({
		operation,
		plugin: plugin.getPluginOrThrow("@hey-api/sdk")
	});
};
const useTypeError = ({ operation, plugin }) => {
	const client = getClientPlugin(plugin.context.config);
	const symbolError = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "error"
	}) || plugin.external(`${plugin.name}.DefaultError`);
	if (client.name === "@hey-api/client-axios") {
		const symbol = plugin.external("axios.AxiosError");
		return $.type(symbol).generic(symbolError);
	}
	return $.type(symbolError);
};
const useTypeResponse = ({ operation, plugin }) => {
	const symbolResponseType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "response"
	});
	return $.type(symbolResponseType ?? "unknown");
};

//#endregion
//#region src/plugins/@tanstack/query-core/queryKey.ts
const TOptionsType = "TOptions";
const createQueryKeyFunction = ({ plugin }) => {
	const symbolCreateQueryKey = plugin.symbol(applyNaming("createQueryKey", { case: plugin.config.case }), { meta: {
		category: "utility",
		resource: "createQueryKey",
		tool: plugin.name
	} });
	const symbolQueryKeyType = plugin.referenceSymbol({
		category: "type",
		resource: "QueryKey",
		tool: plugin.name
	});
	const baseUrlKey = getClientBaseUrlKey(plugin.context.config);
	const symbolClient = plugin.getSymbol({ category: "client" });
	const symbolOptions = plugin.referenceSymbol({
		category: "type",
		resource: "client-options",
		tool: "sdk"
	});
	const returnType = $.type(symbolQueryKeyType).generic(TOptionsType).idx(0);
	const fn = $.const(symbolCreateQueryKey).assign($.func().param("id", (p) => p.type("string")).param("options", (p) => p.optional().type(TOptionsType)).param("infinite", (p) => p.optional().type("boolean")).param("tags", (p) => p.optional().type("ReadonlyArray<string>")).generic(TOptionsType, (g) => g.extends(symbolOptions)).returns($.type.tuple(returnType)).do($.const("params").type(returnType).assign($.object().prop("_id", "id").prop(baseUrlKey, $("options").attr(baseUrlKey).optional().or($("options").attr("client").optional().$if(symbolClient, (a, v) => a.coalesce(v)).attr("getConfig").call().attr(baseUrlKey))).as(returnType)), $.if("infinite").do($("params").attr("_infinite").assign("infinite")), $.if("tags").do($("params").attr("tags").assign("tags")), $.if($("options").attr("body").optional()).do($("params").attr("body").assign($("options").attr("body"))), $.if($("options").attr("headers").optional()).do($("params").attr("headers").assign($("options").attr("headers"))), $.if($("options").attr("path").optional()).do($("params").attr("path").assign($("options").attr("path"))), $.if($("options").attr("query").optional()).do($("params").attr("query").assign($("options").attr("query"))), $.return($.array().element($("params")))));
	plugin.node(fn);
};
const createQueryKeyLiteral = ({ id, isInfinite, operation, plugin }) => {
	const config = isInfinite ? plugin.config.infiniteQueryKeys : plugin.config.queryKeys;
	let tagsArray;
	if (config.tags && operation.tags && operation.tags.length > 0) tagsArray = $.array().elements(...operation.tags);
	return $(plugin.referenceSymbol({
		category: "utility",
		resource: "createQueryKey",
		tool: plugin.name
	})).call($.literal(id), "options", isInfinite || tagsArray ? $.literal(Boolean(isInfinite)) : void 0, tagsArray);
};
const createQueryKeyType = ({ plugin }) => {
	const symbolOptions = plugin.referenceSymbol({
		category: "type",
		resource: "client-options",
		tool: "sdk"
	});
	const symbolQueryKeyType = plugin.symbol("QueryKey", { meta: {
		category: "type",
		resource: "QueryKey",
		tool: plugin.name
	} });
	const queryKeyType = $.type.alias(symbolQueryKeyType).export().generic(TOptionsType, (g) => g.extends(symbolOptions)).type($.type.tuple($.type.and($.type(`Pick<${TOptionsType}, '${getClientBaseUrlKey(plugin.context.config)}' | 'body' | 'headers' | 'path' | 'query'>`), $.type.object().prop("_id", (p) => p.type("string")).prop("_infinite", (p) => p.optional().type("boolean")).prop("tags", (p) => p.optional().type("ReadonlyArray<string>")))));
	plugin.node(queryKeyType);
};
const queryKeyStatement = ({ isInfinite, operation, plugin, symbol, typeQueryKey }) => {
	const typeData = useTypeData({
		operation,
		plugin
	});
	return $.const(symbol).export().assign($.func().param("options", (p) => p.required(hasOperationDataRequired(operation)).type(typeData)).$if(isInfinite && typeQueryKey, (f$1, v) => f$1.returns(v)).do(createQueryKeyLiteral({
		id: operation.id,
		isInfinite,
		operation,
		plugin
	}).return()));
};

//#endregion
//#region src/plugins/@tanstack/query-core/shared/meta.ts
const handleMeta = (plugin, operation, configPath) => {
	const metaFn = plugin.config[configPath].meta;
	if (!metaFn) return;
	const metaObject = metaFn(operation);
	if (!Object.keys(metaObject).length) return;
	return $.fromValue(metaObject);
};

//#endregion
//#region src/plugins/@tanstack/query-core/v5/infiniteQueryOptions.ts
const createInfiniteParamsFunction = ({ plugin }) => {
	const symbolCreateInfiniteParams = plugin.symbol(applyNaming("createInfiniteParams", { case: plugin.config.case }), { meta: {
		category: "utility",
		resource: "createInfiniteParams",
		tool: plugin.name
	} });
	const fn = $.const(symbolCreateInfiniteParams).assign($.func().generic("K", (g) => g.extends($.type("Pick").generics($.type("QueryKey").generic("Options").idx(0), $.type.or($.type.literal("body"), $.type.literal("headers"), $.type.literal("path"), $.type.literal("query"))))).param("queryKey", (p) => p.type("QueryKey<Options>")).param("page", (p) => p.type("K")).do($.const("params").assign($.object().spread($("queryKey").attr(0))), $.if($("page").attr("body")).do($("params").attr("body").assign($.object().pretty().spread($("queryKey").attr(0).attr("body").as("any")).spread($("page").attr("body").as("any")))), $.if($("page").attr("headers")).do($("params").attr("headers").assign($.object().pretty().spread($("queryKey").attr(0).attr("headers")).spread($("page").attr("headers")))), $.if($("page").attr("path")).do($("params").attr("path").assign($.object().pretty().spread($("queryKey").attr(0).attr("path").as("any")).spread($("page").attr("path").as("any")))), $.if($("page").attr("query")).do($("params").attr("query").assign($.object().pretty().spread($("queryKey").attr(0).attr("query").as("any")).spread($("page").attr("query").as("any")))), $.return($("params").as("unknown").as($("page").typeofType()))));
	plugin.node(fn);
};
const createInfiniteQueryOptions = ({ operation, plugin }) => {
	const pagination = operationPagination({
		context: plugin.context,
		operation
	});
	if (!pagination) return;
	const isRequiredOptions = isOperationOptionsRequired({
		context: plugin.context,
		operation
	});
	if (!plugin.getSymbol({
		category: "utility",
		resource: "createQueryKey",
		tool: plugin.name
	})) {
		createQueryKeyType({ plugin });
		createQueryKeyFunction({ plugin });
	}
	if (!plugin.getSymbol({
		category: "utility",
		resource: "createInfiniteParams",
		tool: plugin.name
	})) createInfiniteParamsFunction({ plugin });
	const symbolInfiniteQueryOptions = plugin.external(`${plugin.name}.infiniteQueryOptions`);
	const symbolInfiniteDataType = plugin.external(`${plugin.name}.InfiniteData`);
	const typeData = useTypeData({
		operation,
		plugin
	});
	const typeResponse = useTypeResponse({
		operation,
		plugin
	});
	const symbolQueryKeyType = plugin.referenceSymbol({
		category: "type",
		resource: "QueryKey",
		tool: plugin.name
	});
	const typeQueryKey = $.type(symbolQueryKeyType).generic(typeData);
	const typePageObjectParam = $.type("Pick").generics(typeQueryKey.idx(0), $.type.or($.type.literal("body"), $.type.literal("headers"), $.type.literal("path"), $.type.literal("query")));
	const pluginTypeScript = plugin.getPluginOrThrow("@hey-api/typescript");
	const type = pluginTypeScript.api.schemaToType({
		plugin: pluginTypeScript,
		schema: pagination.schema,
		state: { path: (0, _hey_api_codegen_core.ref)([]) }
	});
	const symbolInfiniteQueryKey = plugin.symbol(applyNaming(operation.id, plugin.config.infiniteQueryKeys));
	const node = queryKeyStatement({
		isInfinite: true,
		operation,
		plugin,
		symbol: symbolInfiniteQueryKey,
		typeQueryKey
	});
	plugin.node(node);
	const awaitSdkFn = $.lazy((ctx$1) => ctx$1.access(plugin.referenceSymbol({
		category: "sdk",
		resource: "operation",
		resourceId: operation.id
	})).call($.object().spread("options").spread("params").prop("signal", $("signal")).prop("throwOnError", $.literal(true))).await());
	const symbolCreateInfiniteParams = plugin.referenceSymbol({
		category: "utility",
		resource: "createInfiniteParams",
		tool: plugin.name
	});
	const statements = [$.const("page").type(typePageObjectParam).hint("@ts-ignore").assign($.ternary($("pageParam").typeofExpr().eq($.literal("object"))).do("pageParam").otherwise($.object().pretty().prop(pagination.in, $.object().pretty().prop(pagination.name, $("pageParam"))))), $.const("params").assign($(symbolCreateInfiniteParams).call("queryKey", "page"))];
	if (plugin.getPluginOrThrow("@hey-api/sdk").config.responseStyle === "data") statements.push($.return(awaitSdkFn));
	else statements.push($.const().object("data").assign(awaitSdkFn), $.return("data"));
	const symbolInfiniteQueryOptionsFn = plugin.symbol(applyNaming(operation.id, plugin.config.infiniteQueryOptions));
	const statement = $.const(symbolInfiniteQueryOptionsFn).export().$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v)).assign($.func().param("options", (p) => p.required(isRequiredOptions).type(typeData)).do($.return($(symbolInfiniteQueryOptions).call($.object().pretty().hint("@ts-ignore").prop("queryFn", $.func().async().param((p) => p.object("pageParam", "queryKey", "signal")).do(...statements)).prop("queryKey", $(symbolInfiniteQueryKey).call("options")).$if(handleMeta(plugin, operation, "infiniteQueryOptions"), (o, v) => o.prop("meta", v))).generics(typeResponse, useTypeError({
		operation,
		plugin
	}), $.type(symbolInfiniteDataType).generic(typeResponse), typeQueryKey, $.type.or(type, typePageObjectParam)))));
	plugin.node(statement);
};

//#endregion
//#region src/plugins/@tanstack/query-core/v5/mutationOptions.ts
const createMutationOptions = ({ operation, plugin }) => {
	const symbolMutationOptionsType = plugin.external(`${plugin.name}.MutationOptions`);
	const typeData = useTypeData({
		operation,
		plugin
	});
	const mutationType = $.type(symbolMutationOptionsType).generic(useTypeResponse({
		operation,
		plugin
	})).generic(useTypeError({
		operation,
		plugin
	})).generic(typeData);
	const fnOptions$1 = "fnOptions";
	const awaitSdkFn = $.lazy((ctx$1) => ctx$1.access(plugin.referenceSymbol({
		category: "sdk",
		resource: "operation",
		resourceId: operation.id
	})).call($.object().spread("options").spread(fnOptions$1).prop("throwOnError", $.literal(true))).await());
	const statements = [];
	if (plugin.getPluginOrThrow("@hey-api/sdk").config.responseStyle === "data") statements.push($.return(awaitSdkFn));
	else statements.push($.const().object("data").assign(awaitSdkFn), $.return("data"));
	const mutationOptionsFn = "mutationOptions";
	const symbolMutationOptions = plugin.symbol(applyNaming(operation.id, plugin.config.mutationOptions), { meta: {
		category: "hook",
		resource: "operation",
		resourceId: operation.id,
		role: "mutationOptions",
		tool: plugin.name
	} });
	const statement = $.const(symbolMutationOptions).export().$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v)).assign($.func().param("options", (p) => p.optional().type($.type("Partial").generic(typeData))).returns(mutationType).do($.const(mutationOptionsFn).type(mutationType).assign($.object().pretty().prop("mutationFn", $.func().async().param(fnOptions$1).do(...statements)).$if(handleMeta(plugin, operation, "mutationOptions"), (c, v) => c.prop("meta", v))), $(mutationOptionsFn).return()));
	plugin.node(statement);
};

//#endregion
//#region src/plugins/@tanstack/query-core/v5/queryOptions.ts
const optionsParamName$1 = "options";
const createQueryOptions = ({ operation, plugin }) => {
	if (hasOperationSse({ operation })) return;
	const isRequiredOptions = isOperationOptionsRequired({
		context: plugin.context,
		operation
	});
	if (!plugin.getSymbol({
		category: "utility",
		resource: "createQueryKey",
		tool: plugin.name
	})) {
		createQueryKeyType({ plugin });
		createQueryKeyFunction({ plugin });
	}
	const symbolQueryOptions = plugin.external(`${plugin.name}.queryOptions`);
	const symbolQueryKey = plugin.symbol(applyNaming(operation.id, plugin.config.queryKeys));
	const node = queryKeyStatement({
		isInfinite: false,
		operation,
		plugin,
		symbol: symbolQueryKey
	});
	plugin.node(node);
	const typeResponse = useTypeResponse({
		operation,
		plugin
	});
	const awaitSdkFn = $.lazy((ctx$1) => ctx$1.access(plugin.referenceSymbol({
		category: "sdk",
		resource: "operation",
		resourceId: operation.id
	})).call($.object().spread(optionsParamName$1).spread($("queryKey").attr(0)).prop("signal", $("signal")).prop("throwOnError", $.literal(true))).await());
	const statements = [];
	if (plugin.getPluginOrThrow("@hey-api/sdk").config.responseStyle === "data") statements.push($.return(awaitSdkFn));
	else statements.push($.const().object("data").assign(awaitSdkFn), $.return("data"));
	const queryOptionsObj = $.object().pretty().prop("queryFn", $.func().async().param((p) => p.object("queryKey", "signal")).do(...statements)).prop("queryKey", $(symbolQueryKey).call(optionsParamName$1)).$if(handleMeta(plugin, operation, "queryOptions"), (o, v) => o.prop("meta", v));
	const symbolQueryOptionsFn = plugin.symbol(applyNaming(operation.id, plugin.config.queryOptions), { meta: {
		category: "hook",
		resource: "operation",
		resourceId: operation.id,
		role: "queryOptions",
		tool: plugin.name
	} });
	const statement = $.const(symbolQueryOptionsFn).export(plugin.config.queryOptions.exported).$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v)).assign($.func().param(optionsParamName$1, (p) => p.required(isRequiredOptions).type(useTypeData({
		operation,
		plugin
	}))).do($(symbolQueryOptions).call(queryOptionsObj).generics(typeResponse, useTypeError({
		operation,
		plugin
	}), typeResponse, $(symbolQueryKey).returnType()).return()));
	plugin.node(statement);
};

//#endregion
//#region src/plugins/@tanstack/query-core/v5/useQuery.ts
const optionsParamName = "options";
const createUseQuery = ({ operation, plugin }) => {
	if (hasOperationSse({ operation })) return;
	if (!("useQuery" in plugin.config)) return;
	const symbolUseQueryFn = plugin.symbol(applyNaming(operation.id, plugin.config.useQuery));
	const symbolUseQuery = plugin.external(`${plugin.name}.useQuery`);
	const isRequiredOptions = isOperationOptionsRequired({
		context: plugin.context,
		operation
	});
	const typeData = useTypeData({
		operation,
		plugin
	});
	const symbolQueryOptionsFn = plugin.referenceSymbol({
		category: "hook",
		resource: "operation",
		resourceId: operation.id,
		role: "queryOptions",
		tool: plugin.name
	});
	const statement = $.const(symbolUseQueryFn).export().$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v)).assign($.func().param(optionsParamName, (p) => p.required(isRequiredOptions).type(typeData)).do($(symbolUseQuery).call($(symbolQueryOptionsFn).call(optionsParamName)).return()));
	plugin.node(statement);
};

//#endregion
//#region src/plugins/@tanstack/query-core/v5/plugin.ts
const handlerV5 = ({ plugin }) => {
	plugin.symbol("DefaultError", {
		external: plugin.name,
		kind: "type",
		meta: {
			category: "external",
			resource: `${plugin.name}.DefaultError`
		}
	});
	plugin.symbol("InfiniteData", {
		external: plugin.name,
		kind: "type",
		meta: {
			category: "external",
			resource: `${plugin.name}.InfiniteData`
		}
	});
	const mutationsType = plugin.name === "@tanstack/angular-query-experimental" || plugin.name === "@tanstack/svelte-query" || plugin.name === "@tanstack/solid-query" ? "MutationOptions" : "UseMutationOptions";
	plugin.symbol(mutationsType, {
		external: plugin.name,
		kind: "type",
		meta: {
			category: "external",
			resource: `${plugin.name}.MutationOptions`
		}
	});
	plugin.symbol("infiniteQueryOptions", {
		external: plugin.name,
		meta: {
			category: "external",
			resource: `${plugin.name}.infiniteQueryOptions`
		}
	});
	plugin.symbol("queryOptions", {
		external: plugin.name,
		meta: {
			category: "external",
			resource: `${plugin.name}.queryOptions`
		}
	});
	plugin.symbol("useQuery", {
		external: plugin.name,
		meta: {
			category: "external",
			resource: `${plugin.name}.useQuery`
		}
	});
	plugin.symbol("AxiosError", {
		external: "axios",
		kind: "type",
		meta: {
			category: "external",
			resource: "axios.AxiosError"
		}
	});
	plugin.forEach("operation", ({ operation }) => {
		if (plugin.hooks.operation.isQuery(operation)) {
			if (plugin.config.queryOptions.enabled) createQueryOptions({
				operation,
				plugin
			});
			if (plugin.config.infiniteQueryOptions.enabled) createInfiniteQueryOptions({
				operation,
				plugin
			});
			if ("useQuery" in plugin.config && plugin.config.useQuery.enabled) createUseQuery({
				operation,
				plugin
			});
		}
		if (plugin.hooks.operation.isMutation(operation)) {
			if (plugin.config.mutationOptions.enabled) createMutationOptions({
				operation,
				plugin
			});
		}
	}, { order: "declarations" });
};

//#endregion
//#region src/plugins/@tanstack/query-core/plugin.ts
const handler$5 = (args) => handlerV5(args);

//#endregion
//#region src/plugins/@tanstack/angular-query-experimental/config.ts
const defaultConfig$9 = {
	config: {
		case: "camelCase",
		comments: true,
		exportFromIndex: false
	},
	dependencies: ["@hey-api/sdk", "@hey-api/typescript"],
	handler: handler$5,
	name: "@tanstack/angular-query-experimental",
	resolveConfig: (plugin, context) => {
		plugin.config.infiniteQueryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteQueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryKeys
		});
		plugin.config.infiniteQueryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteOptions"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryOptions
		});
		plugin.config.mutationOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}Mutation"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.mutationOptions
		});
		plugin.config.queryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}QueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryKeys
		});
		plugin.config.queryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				exported: true,
				name: "{{name}}Options"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryOptions
		});
	}
};
/**
* Type helper for `@tanstack/angular-query-experimental` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$9 = definePluginConfig(defaultConfig$9);

//#endregion
//#region src/plugins/@tanstack/react-query/config.ts
const defaultConfig$8 = {
	config: {
		case: "camelCase",
		comments: true,
		exportFromIndex: false
	},
	dependencies: ["@hey-api/sdk", "@hey-api/typescript"],
	handler: handler$5,
	name: "@tanstack/react-query",
	resolveConfig: (plugin, context) => {
		plugin.config.infiniteQueryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteQueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryKeys
		});
		plugin.config.infiniteQueryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteOptions"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryOptions
		});
		plugin.config.mutationOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}Mutation"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.mutationOptions
		});
		plugin.config.queryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}QueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryKeys
		});
		plugin.config.queryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				exported: true,
				name: "{{name}}Options"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryOptions
		});
		plugin.config.useQuery = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: false,
				name: "use{{name}}Query"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({
					enabled: true,
					name
				}),
				object: (fields) => ({
					enabled: true,
					...fields
				}),
				string: (name) => ({
					enabled: true,
					name
				})
			},
			value: plugin.config.useQuery
		});
		if (plugin.config.useQuery.enabled) {
			if (!plugin.config.queryOptions.enabled) {
				plugin.config.queryOptions.enabled = true;
				plugin.config.queryOptions.exported = false;
			}
		}
	}
};
/**
* Type helper for `@tanstack/react-query` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$8 = definePluginConfig(defaultConfig$8);

//#endregion
//#region src/plugins/@tanstack/solid-query/config.ts
const defaultConfig$7 = {
	config: {
		case: "camelCase",
		comments: true,
		exportFromIndex: false
	},
	dependencies: ["@hey-api/sdk", "@hey-api/typescript"],
	handler: handler$5,
	name: "@tanstack/solid-query",
	resolveConfig: (plugin, context) => {
		plugin.config.infiniteQueryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteQueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryKeys
		});
		plugin.config.infiniteQueryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteOptions"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryOptions
		});
		plugin.config.mutationOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}Mutation"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.mutationOptions
		});
		plugin.config.queryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}QueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryKeys
		});
		plugin.config.queryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				exported: true,
				name: "{{name}}Options"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryOptions
		});
	}
};
/**
* Type helper for `@tanstack/solid-query` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$7 = definePluginConfig(defaultConfig$7);

//#endregion
//#region src/plugins/@tanstack/svelte-query/config.ts
const defaultConfig$6 = {
	config: {
		case: "camelCase",
		comments: true,
		exportFromIndex: false
	},
	dependencies: ["@hey-api/sdk", "@hey-api/typescript"],
	handler: handler$5,
	name: "@tanstack/svelte-query",
	resolveConfig: (plugin, context) => {
		plugin.config.infiniteQueryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteQueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryKeys
		});
		plugin.config.infiniteQueryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteOptions"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryOptions
		});
		plugin.config.mutationOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}Mutation"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.mutationOptions
		});
		plugin.config.queryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}QueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryKeys
		});
		plugin.config.queryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				exported: true,
				name: "{{name}}Options"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryOptions
		});
	}
};
/**
* Type helper for `@tanstack/svelte-query` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$6 = definePluginConfig(defaultConfig$6);

//#endregion
//#region src/plugins/@tanstack/vue-query/config.ts
const defaultConfig$5 = {
	config: {
		case: "camelCase",
		comments: true,
		exportFromIndex: false
	},
	dependencies: ["@hey-api/sdk", "@hey-api/typescript"],
	handler: handler$5,
	name: "@tanstack/vue-query",
	resolveConfig: (plugin, context) => {
		plugin.config.infiniteQueryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteQueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryKeys
		});
		plugin.config.infiniteQueryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteOptions"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryOptions
		});
		plugin.config.mutationOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}Mutation"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.mutationOptions
		});
		plugin.config.queryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}QueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryKeys
		});
		plugin.config.queryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				exported: true,
				name: "{{name}}Options"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryOptions
		});
	}
};
/**
* Type helper for `@tanstack/vue-query` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$5 = definePluginConfig(defaultConfig$5);

//#endregion
//#region src/plugins/arktype/v2/api.ts
const createRequestValidatorV2 = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tool: "arktype"
	});
	if (!symbol) return;
	const dataParameterName = "data";
	return $.func().async().param(dataParameterName).do($(symbol).attr("parseAsync").call(dataParameterName).await().return());
};
const createResponseValidatorV2 = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "responses",
		tool: "arktype"
	});
	if (!symbol) return;
	const dataParameterName = "data";
	return $.func().async().param(dataParameterName).do($(symbol).attr("parseAsync").call(dataParameterName).await().return());
};

//#endregion
//#region src/plugins/arktype/api.ts
var Api$2 = class {
	createRequestValidator(args) {
		return createRequestValidatorV2(args);
	}
	createResponseValidator(args) {
		return createResponseValidatorV2(args);
	}
};

//#endregion
//#region src/plugins/arktype/constants.ts
const identifiers$2 = {
	keywords: {
		false: "false",
		true: "true"
	},
	number: {
		Infinity: "Infinity",
		NaN: "NaN",
		NegativeInfinity: "NegativeInfinity",
		epoch: "epoch",
		integer: "integer",
		safe: "safe"
	},
	primitives: {
		bigint: "bigint",
		boolean: "boolean",
		keywords: "keywords",
		null: "null",
		number: "number",
		string: "string",
		symbol: "symbol",
		undefined: "undefined",
		unit: "unit"
	},
	string: {
		NFC: "NFC",
		NFD: "NFD",
		NFKC: "NFKC",
		NFKD: "NFKD",
		alpha: "alpha",
		alphanumeric: "alphanumeric",
		base64: "base64",
		capitalize: "capitalize",
		creditCard: "creditCard",
		date: "date",
		digits: "digits",
		email: "email",
		epoch: "epoch",
		hex: "hex",
		integer: "integer",
		ip: "ip",
		iso: "iso",
		json: "json",
		lower: "lower",
		normalize: "normalize",
		numeric: "numeric",
		parse: "parse",
		preformatted: "preformatted",
		regex: "regex",
		semver: "semver",
		trim: "trim",
		upper: "upper",
		url: "url",
		uuid: "uuid",
		v1: "v1",
		v2: "v2",
		v3: "v3",
		v4: "v4",
		v5: "v5",
		v6: "v6",
		v7: "v7",
		v8: "v8"
	},
	type: {
		$: "$",
		allows: "allows",
		and: "and",
		array: "array",
		as: "as",
		assert: "assert",
		brand: "brand",
		configure: "configure",
		default: "default",
		describe: "describe",
		description: "description",
		equals: "equals",
		exclude: "exclude",
		expression: "expression",
		extends: "extends",
		extract: "extract",
		filter: "filter",
		from: "from",
		ifEquals: "ifEquals",
		ifExtends: "ifExtends",
		infer: "infer",
		inferIn: "inferIn",
		intersect: "intersect",
		json: "json",
		meta: "meta",
		narrow: "narrow",
		onDeepUndeclaredKey: "onDeepUndeclaredKey",
		onUndeclaredKey: "onUndeclaredKey",
		optional: "optional",
		or: "or",
		overlaps: "overlaps",
		pipe: "pipe",
		select: "select",
		to: "to",
		toJsonSchema: "toJsonSchema"
	}
};

//#endregion
//#region src/plugins/arktype/shared/export.ts
const exportAst$2 = ({ ast, plugin, schema, symbol, typeInferSymbol }) => {
	const type = plugin.external("arktype.type");
	const statement = $.const(symbol).export().$if(plugin.config.comments && createSchemaComment(schema), (c, v) => c.doc(v)).assign($(type).call(ast.def ? $.literal(ast.def) : ast.expression));
	plugin.node(statement);
	if (typeInferSymbol) {
		const inferType = $.type.alias(typeInferSymbol).export().type($.type(symbol).attr(identifiers$2.type.infer).typeofType());
		plugin.node(inferType);
	}
};

//#endregion
//#region src/plugins/arktype/v2/toAst/null.ts
const nullToAst$4 = (_args) => {
	const result = {};
	result.def = identifiers$2.primitives.null;
	return result;
};

//#endregion
//#region src/plugins/arktype/v2/toAst/object.ts
const objectToAst$4 = ({ plugin, schema, state }) => {
	const result = {};
	const shape = $.object().pretty();
	const required = schema.required ?? [];
	for (const name in schema.properties) {
		const property = schema.properties[name];
		const isRequired = required.includes(name);
		const propertyAst = irSchemaToAst$4({
			optional: !isRequired,
			plugin,
			schema: property,
			state: {
				...state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(state.path),
					"properties",
					name
				])
			}
		});
		if (propertyAst.hasLazyExpression) result.hasLazyExpression = true;
		shape.prop(isRequired ? name : `${name}?`, propertyAst.expression);
	}
	if (schema.additionalProperties && (!schema.properties || !Object.keys(schema.properties).length)) {
		const additionalAst = irSchemaToAst$4({
			plugin,
			schema: schema.additionalProperties,
			state: {
				...state,
				path: (0, _hey_api_codegen_core.ref)([...(0, _hey_api_codegen_core.fromRef)(state.path), "additionalProperties"])
			}
		});
		result.expression = $("TODO").attr("record").call($("TODO").attr("string").call(), additionalAst.expression);
		if (additionalAst.hasLazyExpression) result.hasLazyExpression = true;
		return result;
	}
	result.expression = shape;
	if (result.hasLazyExpression) return {
		...result,
		typeName: "TODO"
	};
	return result;
};

//#endregion
//#region src/plugins/arktype/v2/toAst/string.ts
const stringToAst = ({ schema }) => {
	const result = {};
	if (typeof schema.const === "string") {
		result.def = schema.const;
		return result;
	}
	let def = identifiers$2.primitives.string;
	if (schema.format) switch (schema.format) {
		case "date":
		case "date-time":
		case "time":
			def = `${def}.${identifiers$2.string.date}.${identifiers$2.string.iso}`;
			break;
		case "email":
			def = `${def}.${identifiers$2.string.email}`;
			break;
		case "ipv4":
			def = `${def}.${identifiers$2.string.ip}.${identifiers$2.string.v4}`;
			break;
		case "ipv6":
			def = `${def}.${identifiers$2.string.ip}.${identifiers$2.string.v6}`;
			break;
		case "uri":
			def = `${def}.${identifiers$2.string.url}`;
			break;
		case "uuid":
			def = `${def}.${identifiers$2.string.uuid}`;
			break;
	}
	if (schema.minLength === schema.maxLength && schema.minLength !== void 0) def = `${schema.minLength} <= ${def} <= ${schema.maxLength}`;
	else if (schema.maxLength !== void 0) {
		def = `${def} <= ${schema.maxLength}`;
		if (schema.minLength !== void 0) def = `${schema.minLength} <= ${def}`;
	} else if (schema.minLength !== void 0) def = `${def} >= ${schema.minLength}`;
	if (schema.pattern) def = `/${schema.pattern}/`;
	result.def = def;
	return result;
};

//#endregion
//#region src/plugins/arktype/v2/toAst/index.ts
const irSchemaWithTypeToAst$4 = ({ schema, ...args }) => {
	switch (schema.type) {
		case "null": return nullToAst$4({
			...args,
			schema
		});
		case "object": return objectToAst$4({
			...args,
			schema
		});
		case "string": return stringToAst({
			...args,
			schema
		});
	}
	return {
		def: "",
		expression: $(args.plugin.external("arktype.type")).call($.object().prop("name", $.literal("string")).prop("platform", $.literal("'android' | 'ios'")).prop("versions?", $.literal("(number | string)[]"))),
		hasLazyExpression: false
	};
};

//#endregion
//#region src/plugins/arktype/v2/plugin.ts
const irSchemaToAst$4 = ({ plugin, schema, state }) => {
	let ast = {};
	if (schema.$ref) {
		const query = {
			category: "schema",
			resource: "definition",
			resourceId: schema.$ref,
			tool: "arktype"
		};
		const refSymbol = plugin.referenceSymbol(query);
		if (plugin.isSymbolRegistered(query)) {
			const ref$41 = $(refSymbol);
			ast.expression = ref$41;
		} else {
			const lazyExpression = $("TODO").attr("TODO").call($.func().returns("any").do($.return(refSymbol)));
			ast.expression = lazyExpression;
			ast.hasLazyExpression = true;
			state.hasLazyExpression["~ref"] = true;
		}
	} else if (schema.type) {
		const typeAst = irSchemaWithTypeToAst$4({
			plugin,
			schema,
			state
		});
		ast.def = typeAst.def;
		ast.expression = typeAst.expression;
		ast.hasLazyExpression = typeAst.hasLazyExpression;
		if (plugin.config.metadata && schema.description) {}
	} else if (schema.items) {
		schema = deduplicateSchema({ schema });
		if (schema.items) {} else ast = irSchemaToAst$4({
			plugin,
			schema,
			state
		});
	} else {
		const typeAst = irSchemaWithTypeToAst$4({
			plugin,
			schema: { type: "unknown" },
			state
		});
		ast.def = typeAst.def;
		ast.expression = typeAst.expression;
	}
	if (!ast.expression) {
		const typeAst = irSchemaWithTypeToAst$4({
			plugin,
			schema: { type: "unknown" },
			state
		});
		ast.expression = typeAst.expression;
	}
	return ast;
};
const handleComponent$4 = ({ plugin, schema, state }) => {
	const $ref = pathToJsonPointer((0, _hey_api_codegen_core.fromRef)(state.path));
	const ast = irSchemaToAst$4({
		plugin,
		schema,
		state
	});
	const baseName = refToName($ref);
	exportAst$2({
		ast,
		plugin,
		schema,
		symbol: plugin.symbol(applyNaming(baseName, plugin.config.definitions), { meta: {
			category: "schema",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "definition",
			resourceId: $ref,
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "arktype"
		} }),
		typeInferSymbol: plugin.config.definitions.types.infer.enabled ? plugin.symbol(applyNaming(baseName, plugin.config.definitions.types.infer), { meta: {
			category: "type",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "definition",
			resourceId: $ref,
			tool: "arktype",
			variant: "infer"
		} }) : void 0
	});
};
const handlerV2$1 = ({ plugin }) => {
	plugin.symbol("type", {
		external: "arktype",
		meta: {
			category: "external",
			resource: "arktype.type"
		}
	});
	plugin.forEach("operation", "parameter", "requestBody", "schema", "webhook", (event) => {
		const state = (0, _hey_api_codegen_core.refs)({
			hasLazyExpression: false,
			path: event._path,
			tags: event.tags
		});
		switch (event.type) {
			case "parameter":
				handleComponent$4({
					plugin,
					schema: event.parameter.schema,
					state
				});
				break;
			case "requestBody":
				handleComponent$4({
					plugin,
					schema: event.requestBody.schema,
					state
				});
				break;
			case "schema":
				handleComponent$4({
					plugin,
					schema: event.schema,
					state
				});
				break;
		}
	});
};

//#endregion
//#region src/plugins/arktype/plugin.ts
const handler$4 = (args) => handlerV2$1(args);

//#endregion
//#region src/plugins/arktype/config.ts
const defaultConfig$4 = {
	api: new Api$2(),
	config: {
		case: "PascalCase",
		comments: true,
		exportFromIndex: false,
		metadata: false
	},
	handler: handler$4,
	name: "arktype",
	resolveConfig: (plugin, context) => {
		plugin.config.types = context.valueToObject({
			defaultValue: { infer: {
				case: "PascalCase",
				enabled: false
			} },
			mappers: { object: (fields, defaultValue) => ({
				...fields,
				infer: context.valueToObject({
					defaultValue: {
						...defaultValue.infer,
						enabled: fields.infer !== void 0 ? Boolean(fields.infer) : defaultValue.infer.enabled
					},
					mappers,
					value: fields.infer
				})
			}) },
			value: plugin.config.types
		});
		plugin.config.definitions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "PascalCase",
				enabled: true,
				name: "{{name}}",
				types: {
					...plugin.config.types,
					infer: {
						...plugin.config.types.infer,
						name: "{{name}}"
					}
				}
			},
			mappers: {
				...mappers,
				object: (fields, defaultValue) => ({
					...fields,
					types: context.valueToObject({
						defaultValue: defaultValue.types,
						mappers: { object: (fields$1, defaultValue$1) => ({
							...fields$1,
							infer: context.valueToObject({
								defaultValue: {
									...defaultValue$1.infer,
									enabled: fields$1.infer !== void 0 ? Boolean(fields$1.infer) : defaultValue$1.infer.enabled
								},
								mappers,
								value: fields$1.infer
							})
						}) },
						value: fields.types
					})
				})
			},
			value: plugin.config.definitions
		});
		plugin.config.requests = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "PascalCase",
				enabled: true,
				name: "{{name}}Data",
				types: {
					...plugin.config.types,
					infer: {
						...plugin.config.types.infer,
						name: "{{name}}Data"
					}
				}
			},
			mappers: {
				...mappers,
				object: (fields, defaultValue) => ({
					...fields,
					types: context.valueToObject({
						defaultValue: defaultValue.types,
						mappers: { object: (fields$1, defaultValue$1) => ({
							...fields$1,
							infer: context.valueToObject({
								defaultValue: {
									...defaultValue$1.infer,
									enabled: fields$1.infer !== void 0 ? Boolean(fields$1.infer) : defaultValue$1.infer.enabled
								},
								mappers,
								value: fields$1.infer
							})
						}) },
						value: fields.types
					})
				})
			},
			value: plugin.config.requests
		});
		plugin.config.responses = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "PascalCase",
				enabled: true,
				name: "{{name}}Response",
				types: {
					...plugin.config.types,
					infer: {
						...plugin.config.types.infer,
						name: "{{name}}Response"
					}
				}
			},
			mappers: {
				...mappers,
				object: (fields, defaultValue) => ({
					...fields,
					types: context.valueToObject({
						defaultValue: defaultValue.types,
						mappers: { object: (fields$1, defaultValue$1) => ({
							...fields$1,
							infer: context.valueToObject({
								defaultValue: {
									...defaultValue$1.infer,
									enabled: fields$1.infer !== void 0 ? Boolean(fields$1.infer) : defaultValue$1.infer.enabled
								},
								mappers,
								value: fields$1.infer
							})
						}) },
						value: fields.types
					})
				})
			},
			value: plugin.config.responses
		});
		plugin.config.webhooks = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "PascalCase",
				enabled: true,
				name: "{{name}}WebhookRequest",
				types: {
					...plugin.config.types,
					infer: {
						...plugin.config.types.infer,
						name: "{{name}}WebhookRequest"
					}
				}
			},
			mappers: {
				...mappers,
				object: (fields, defaultValue) => ({
					...fields,
					types: context.valueToObject({
						defaultValue: defaultValue.types,
						mappers: { object: (fields$1, defaultValue$1) => ({
							...fields$1,
							infer: context.valueToObject({
								defaultValue: {
									...defaultValue$1.infer,
									enabled: fields$1.infer !== void 0 ? Boolean(fields$1.infer) : defaultValue$1.infer.enabled
								},
								mappers,
								value: fields$1.infer
							})
						}) },
						value: fields.types
					})
				})
			},
			value: plugin.config.webhooks
		});
	},
	tags: ["validator"]
};
/**
* Type helper for Arktype plugin, returns {@link Plugin.Config} object
*/
const defineConfig$4 = definePluginConfig(defaultConfig$4);

//#endregion
//#region src/plugins/fastify/plugin.ts
const operationToRouteHandler = ({ operation, plugin }) => {
	const type = $.type.object();
	const symbolDataType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tool: "typescript"
	});
	if (symbolDataType) {
		if (operation.body) type.prop("Body", (p) => p.required(operation.body.required).type($.type(symbolDataType).idx($.type.literal("body"))));
		if (operation.parameters) {
			if (operation.parameters.header) type.prop("Headers", (p) => p.required(hasParameterGroupObjectRequired(operation.parameters.header)).type($.type(symbolDataType).idx($.type.literal("headers"))));
			if (operation.parameters.path) type.prop("Params", (p) => p.required(hasParameterGroupObjectRequired(operation.parameters.path)).type($.type(symbolDataType).idx($.type.literal("path"))));
			if (operation.parameters.query) type.prop("Querystring", (p) => p.required(hasParameterGroupObjectRequired(operation.parameters.query)).type($.type(symbolDataType).idx($.type.literal("query"))));
		}
	}
	const { errors, responses } = operationResponsesMap(operation);
	let errorsTypeReference;
	const symbolErrorType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "errors"
	});
	if (symbolErrorType && errors && errors.properties) {
		const keys = Object.keys(errors.properties);
		if (keys.length) {
			if (!keys.includes("default")) errorsTypeReference = $.type(symbolErrorType);
			else if (keys.length > 1) errorsTypeReference = $.type("Omit", (t) => t.generics($.type(symbolErrorType), $.type.literal("default")));
		}
	}
	let responsesTypeReference = void 0;
	const symbolResponseType = plugin.querySymbol({
		category: "type",
		resource: "operation",
		resourceId: operation.id,
		role: "responses"
	});
	if (symbolResponseType && responses && responses.properties) {
		const keys = Object.keys(responses.properties);
		if (keys.length) {
			if (!keys.includes("default")) responsesTypeReference = $.type(symbolResponseType);
			else if (keys.length > 1) responsesTypeReference = $.type("Omit", (t) => t.generics($.type(symbolResponseType), $.type.literal("default")));
		}
	}
	const replyTypes = [errorsTypeReference, responsesTypeReference].filter((t) => t !== void 0);
	if (replyTypes.length) type.prop("Reply", (p) => p.type($.type.and(...replyTypes)));
	if (type.isEmpty) return;
	const symbolRouteHandler = plugin.referenceSymbol({
		category: "type",
		resource: "route-handler",
		tool: "fastify"
	});
	return {
		name: operation.id,
		type: $.type(symbolRouteHandler, (t) => t.generic(type))
	};
};
const handler$3 = ({ plugin }) => {
	plugin.symbol("RouteHandler", {
		external: "fastify",
		kind: "type",
		meta: {
			category: "type",
			resource: "route-handler",
			tool: "fastify"
		}
	});
	const symbolRouteHandlers = plugin.symbol("RouteHandlers");
	const type = $.type.object();
	plugin.forEach("operation", ({ operation }) => {
		const routeHandler = operationToRouteHandler({
			operation,
			plugin
		});
		if (routeHandler) type.prop(routeHandler.name, (p) => p.type(routeHandler.type));
	}, { order: "declarations" });
	const node = $.type.alias(symbolRouteHandlers).export().type(type);
	plugin.node(node);
};

//#endregion
//#region src/plugins/fastify/config.ts
const defaultConfig$3 = {
	config: { exportFromIndex: false },
	dependencies: ["@hey-api/typescript"],
	handler: handler$3,
	name: "fastify"
};
/**
* Type helper for `fastify` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$3 = definePluginConfig(defaultConfig$3);

//#endregion
//#region src/plugins/swr/v2/useSwr.ts
const createUseSwr = ({ operation, plugin }) => {
	if (hasOperationSse({ operation })) return;
	const symbolUseSwr = plugin.external("swr");
	const symbolUseQueryFn = plugin.symbol(applyNaming(operation.id, plugin.config.useSwr));
	const awaitSdkFn = $.lazy((ctx$1) => ctx$1.access(plugin.referenceSymbol({
		category: "sdk",
		resource: "operation",
		resourceId: operation.id
	})).call($.object().prop("throwOnError", $.literal(true))).await());
	const statements = [];
	if (plugin.getPluginOrThrow("@hey-api/sdk").config.responseStyle === "data") statements.push($.return(awaitSdkFn));
	else statements.push($.const().object("data").assign(awaitSdkFn), $.return("data"));
	const statement = $.const(symbolUseQueryFn).export().$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v)).assign($.func().do($(symbolUseSwr).call($.literal(operation.path), $.func().async().do(...statements)).return()));
	plugin.node(statement);
};

//#endregion
//#region src/plugins/swr/v2/plugin.ts
const handlerV2 = ({ plugin }) => {
	plugin.symbol("useSWR", {
		external: "swr",
		importKind: "default",
		kind: "function",
		meta: {
			category: "external",
			resource: "swr"
		}
	});
	plugin.forEach("operation", ({ operation }) => {
		if (plugin.hooks.operation.isQuery(operation)) {
			if (plugin.config.useSwr.enabled) createUseSwr({
				operation,
				plugin
			});
		}
	}, { order: "declarations" });
};

//#endregion
//#region src/plugins/swr/plugin.ts
const handler$2 = (args) => handlerV2(args);

//#endregion
//#region src/plugins/swr/config.ts
const defaultConfig$2 = {
	config: {
		case: "camelCase",
		comments: true,
		exportFromIndex: false
	},
	dependencies: ["@hey-api/sdk", "@hey-api/typescript"],
	handler: handler$2,
	name: "swr",
	resolveConfig: (plugin, context) => {
		plugin.config.infiniteQueryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteQueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryKeys
		});
		plugin.config.infiniteQueryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}InfiniteOptions"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.infiniteQueryOptions
		});
		plugin.config.mutationOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}Mutation"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.mutationOptions
		});
		plugin.config.queryKeys = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "{{name}}QueryKey",
				tags: false
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryKeys
		});
		plugin.config.queryOptions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				exported: true,
				name: "{{name}}Options"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.queryOptions
		});
		plugin.config.useSwr = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "use{{name}}"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({
					enabled: true,
					name
				}),
				object: (fields) => ({
					enabled: true,
					...fields
				}),
				string: (name) => ({
					enabled: true,
					name
				})
			},
			value: plugin.config.useSwr
		});
		if (plugin.config.useSwr.enabled) {
			if (!plugin.config.queryOptions.enabled) {
				plugin.config.queryOptions.enabled = true;
				plugin.config.queryOptions.exported = false;
			}
		}
	}
};
/**
* Type helper for `swr` plugin, returns {@link Plugin.Config} object
*/
const defineConfig$2 = definePluginConfig(defaultConfig$2);

//#endregion
//#region src/plugins/valibot/v1/constants.ts
const identifiers$1 = {
	actions: {
		args: "args",
		base64: "base64",
		bic: "bic",
		brand: "brand",
		bytes: "bytes",
		check: "check",
		checkItems: "checkItems",
		creditCard: "creditCard",
		cuid2: "cuid2",
		decimal: "decimal",
		description: "description",
		digits: "digits",
		email: "email",
		emoji: "emoji",
		empty: "empty",
		endsWith: "endsWith",
		entries: "entries",
		everyItem: "everyItem",
		excludes: "excludes",
		filterItems: "filterItems",
		findItem: "findItem",
		finite: "finite",
		flavor: "flavor",
		graphemes: "graphemes",
		gtValue: "gtValue",
		hash: "hash",
		hexColor: "hexColor",
		hexadecimal: "hexadecimal",
		imei: "imei",
		includes: "includes",
		integer: "integer",
		ip: "ip",
		ipv4: "ipv4",
		ipv6: "ipv6",
		isoDate: "isoDate",
		isoDateTime: "isoDateTime",
		isoTime: "isoTime",
		isoTimeSecond: "isoTimeSecond",
		isoTimestamp: "isoTimestamp",
		isoWeek: "isoWeek",
		length: "length",
		ltValue: "ltValue",
		mac: "mac",
		mac48: "mac48",
		mac64: "mac64",
		mapItems: "mapItems",
		maxBytes: "maxBytes",
		maxEntries: "maxEntries",
		maxGraphemes: "maxGraphemes",
		maxLength: "maxLength",
		maxSize: "maxSize",
		maxValue: "maxValue",
		maxWords: "maxWords",
		metadata: "metadata",
		mimeType: "mimeType",
		minBytes: "minBytes",
		minEntries: "minEntries",
		minGraphemes: "minGraphemes",
		minLength: "minLength",
		minSize: "minSize",
		minValue: "minValue",
		minWords: "minWords",
		multipleOf: "multipleOf",
		nanoid: "nanoid",
		nonEmpty: "nonEmpty",
		normalize: "normalize",
		notBytes: "notBytes",
		notEntries: "notEntries",
		notGraphemes: "notGraphemes",
		notLength: "notLength",
		notSize: "notSize",
		notValue: "notValue",
		notValues: "notValues",
		notWords: "notWords",
		octal: "octal",
		parseJson: "parseJson",
		partialCheck: "partialCheck",
		rawCheck: "rawCheck",
		rawTransform: "rawTransform",
		readonly: "readonly",
		reduceItems: "reduceItems",
		regex: "regex",
		returns: "returns",
		rfcEmail: "rfcEmail",
		safeInteger: "safeInteger",
		size: "size",
		slug: "slug",
		someItem: "someItem",
		sortItems: "sortItems",
		startsWith: "startsWith",
		stringifyJson: "stringifyJson",
		title: "title",
		toLowerCase: "toLowerCase",
		toMaxValue: "toMaxValue",
		toMinValue: "toMinValue",
		toUpperCase: "toUpperCase",
		transform: "transform",
		trim: "trim",
		trimEnd: "trimEnd",
		trimStart: "trimStart",
		ulid: "ulid",
		url: "url",
		uuid: "uuid",
		value: "value",
		values: "values",
		words: "words"
	},
	async: {
		argsAsync: "argsAsync",
		arrayAsync: "arrayAsync",
		awaitAsync: "awaitAsync",
		checkAsync: "checkAsync",
		checkItemsAsync: "checkItemsAsync",
		customAsync: "customAsync",
		exactOptionalAsync: "exactOptionalAsync",
		fallbackAsync: "fallbackAsync",
		forwardAsync: "forwardAsync",
		getDefaultsAsync: "getDefaultsAsync",
		getFallbacksAsync: "getFallbacksAsync",
		intersectAsync: "intersectAsync",
		lazyAsync: "lazyAsync",
		looseObjectAsync: "looseObjectAsync",
		looseTupleAsync: "looseTupleAsync",
		mapAsync: "mapAsync",
		nonNullableAsync: "nonNullableAsync",
		nonNullishAsync: "nonNullishAsync",
		nonOptionalAsync: "nonOptionalAsync",
		nullableAsync: "nullableAsync",
		nullishAsync: "nullishAsync",
		objectAsync: "objectAsync",
		objectWithRestAsync: "objectWithRestAsync",
		optionalAsync: "optionalAsync",
		parseAsync: "parseAsync",
		parserAsync: "parserAsync",
		partialAsync: "partialAsync",
		partialCheckAsync: "partialCheckAsync",
		pipeAsync: "pipeAsync",
		rawCheckAsync: "rawCheckAsync",
		rawTransformAsync: "rawTransformAsync",
		recordAsync: "recordAsync",
		requiredAsync: "requiredAsync",
		returnsAsync: "returnsAsync",
		safeParseAsync: "safeParseAsync",
		safeParserAsync: "safeParserAsync",
		setAsync: "setAsync",
		strictObjectAsync: "strictObjectAsync",
		strictTupleAsync: "strictTupleAsync",
		transformAsync: "transformAsync",
		tupleAsync: "tupleAsync",
		tupleWithRestAsync: "tupleWithRestAsync",
		undefinedableAsync: "undefinedableAsync",
		unionAsync: "unionAsync",
		variantAsync: "variantAsync"
	},
	methods: {
		assert: "assert",
		config: "config",
		fallback: "fallback",
		flatten: "flatten",
		forward: "forward",
		getDefault: "getDefault",
		getDefaults: "getDefaults",
		getDescription: "getDescription",
		getFallback: "getFallback",
		getFallbacks: "getFallbacks",
		getMetadata: "getMetadata",
		getTitle: "getTitle",
		is: "is",
		keyof: "keyof",
		message: "message",
		omit: "omit",
		parse: "parse",
		parser: "parser",
		partial: "partial",
		pick: "pick",
		pipe: "pipe",
		required: "required",
		safeParse: "safeParse",
		safeParser: "safeParser",
		summarize: "summarize",
		unwrap: "unwrap"
	},
	schemas: {
		any: "any",
		array: "array",
		bigInt: "bigint",
		blob: "blob",
		boolean: "boolean",
		custom: "custom",
		date: "date",
		enum: "enum",
		exactOptional: "exactOptional",
		file: "file",
		function: "function",
		instance: "instance",
		intersect: "intersect",
		lazy: "lazy",
		literal: "literal",
		looseObject: "looseObject",
		looseTuple: "looseTuple",
		map: "map",
		nan: "nan",
		never: "never",
		nonNullable: "nonNullable",
		nonNullish: "nonNullish",
		nonOptional: "nonOptional",
		null: "null",
		nullable: "nullable",
		nullish: "nullish",
		number: "number",
		object: "object",
		objectWithRest: "objectWithRest",
		optional: "optional",
		picklist: "picklist",
		promise: "promise",
		record: "record",
		set: "set",
		strictObject: "strictObject",
		strictTuple: "strictTuple",
		string: "string",
		symbol: "symbol",
		tuple: "tuple",
		tupleWithRest: "tupleWithRest",
		undefined: "undefined",
		undefinedable: "undefinedable",
		union: "union",
		unknown: "unknown",
		variant: "variant",
		void: "void"
	},
	storages: {},
	types: { GenericSchema: "GenericSchema" },
	utils: {}
};

//#endregion
//#region src/plugins/valibot/shared/pipes.ts
const pipesToNode = (pipes$1, plugin) => {
	if (!(pipes$1 instanceof Array)) return pipes$1;
	if (pipes$1.length === 1) return pipes$1[0];
	return $(plugin.external("valibot.v")).attr(identifiers$1.methods.pipe).call(...pipes$1);
};
const pushPipes = (target, pipes$1) => {
	if (pipes$1 instanceof Array) target.push(...pipes$1);
	else target.push(pipes$1);
	return target;
};
/**
* Functions for working with pipes.
*/
const pipes = {
	push: pushPipes,
	toNode: pipesToNode
};

//#endregion
//#region src/plugins/valibot/v1/api.ts
const validatorResolver$3 = (ctx$1) => {
	const { schema, v } = ctx$1.symbols;
	return $(v).attr(identifiers$1.async.parseAsync).call(schema, "data").await().return();
};
const createRequestValidatorV1 = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tool: "valibot"
	});
	if (!symbol) return;
	const ctx$1 = {
		$,
		operation,
		pipes: {
			...pipes,
			current: []
		},
		plugin,
		symbols: {
			schema: symbol,
			v: plugin.external("valibot.v")
		}
	};
	const validator = plugin.config["~resolvers"]?.validator;
	const candidates = [typeof validator === "function" ? validator : validator?.request, validatorResolver$3];
	for (const candidate of candidates) {
		const statements = candidate?.(ctx$1);
		if (statements === null) return;
		if (statements !== void 0) return $.func().async().param("data").do(...statements instanceof Array ? statements : [statements]);
	}
};
const createResponseValidatorV1 = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "responses",
		tool: "valibot"
	});
	if (!symbol) return;
	const ctx$1 = {
		$,
		operation,
		pipes: {
			...pipes,
			current: []
		},
		plugin,
		symbols: {
			schema: symbol,
			v: plugin.external("valibot.v")
		}
	};
	const validator = plugin.config["~resolvers"]?.validator;
	const candidates = [typeof validator === "function" ? validator : validator?.response, validatorResolver$3];
	for (const candidate of candidates) {
		const statements = candidate?.(ctx$1);
		if (statements === null) return;
		if (statements !== void 0) return $.func().async().param("data").do(...statements instanceof Array ? statements : [statements]);
	}
};

//#endregion
//#region src/plugins/valibot/api.ts
var Api$1 = class {
	createRequestValidator(args) {
		return createRequestValidatorV1(args);
	}
	createResponseValidator(args) {
		return createResponseValidatorV1(args);
	}
};

//#endregion
//#region src/plugins/shared/utils/coerce.ts
const shouldCoerceToBigInt = (format) => format === "int64" || format === "uint64";
const maybeBigInt = (value, format) => {
	if (!shouldCoerceToBigInt(format)) return $.fromValue(value);
	if (typeof value === "string") {
		if (value.endsWith("n")) value = value.slice(0, -1);
		return $("BigInt").call($.fromValue(value));
	}
	if (typeof value === "number") return $("BigInt").call($.fromValue(value));
	return $.fromValue(value);
};

//#endregion
//#region src/plugins/valibot/shared/export.ts
const exportAst$1 = ({ ast, plugin, schema, state, symbol }) => {
	const v = plugin.external("valibot.v");
	const statement = $.const(symbol).export().$if(plugin.config.comments && createSchemaComment(schema), (c, v$1) => c.doc(v$1)).$if(state.hasLazyExpression["~ref"], (c) => c.type($.type(v).attr(ast.typeName || identifiers$1.types.GenericSchema))).assign(pipesToNode(ast.pipes, plugin));
	plugin.node(statement);
};

//#endregion
//#region src/plugins/valibot/shared/operation.ts
const irOperationToAst$1 = ({ getAst, operation, plugin, state }) => {
	if (plugin.config.requests.enabled) {
		const requiredProperties = /* @__PURE__ */ new Set();
		const schemaData = {
			properties: {
				body: { type: "never" },
				path: { type: "never" },
				query: { type: "never" }
			},
			type: "object"
		};
		if (operation.parameters) {
			if (operation.parameters.header) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.header) {
					const parameter = operation.parameters.header[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("headers");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.headers = {
					properties,
					required,
					type: "object"
				};
			}
			if (operation.parameters.path) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.path) {
					const parameter = operation.parameters.path[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("path");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.path = {
					properties,
					required,
					type: "object"
				};
			}
			if (operation.parameters.query) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.query) {
					const parameter = operation.parameters.query[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("query");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.query = {
					properties,
					required,
					type: "object"
				};
			}
		}
		if (operation.body) {
			schemaData.properties.body = operation.body.schema;
			if (operation.body.required) requiredProperties.add("body");
		}
		schemaData.required = [...requiredProperties];
		exportAst$1({
			ast: getAst(schemaData, (0, _hey_api_codegen_core.fromRef)(state.path)),
			plugin,
			schema: schemaData,
			state,
			symbol: plugin.symbol(applyNaming(operation.id, plugin.config.requests), { meta: {
				category: "schema",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "operation",
				resourceId: operation.id,
				role: "data",
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "valibot"
			} })
		});
	}
	if (plugin.config.responses.enabled) {
		if (operation.responses) {
			const { response } = operationResponsesMap(operation);
			if (response) {
				const path$10 = [...(0, _hey_api_codegen_core.fromRef)(state.path), "responses"];
				exportAst$1({
					ast: getAst(response, path$10),
					plugin,
					schema: response,
					state,
					symbol: plugin.symbol(applyNaming(operation.id, plugin.config.responses), { meta: {
						category: "schema",
						path: path$10,
						resource: "operation",
						resourceId: operation.id,
						role: "responses",
						tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
						tool: "valibot"
					} })
				});
			}
		}
	}
};

//#endregion
//#region src/plugins/valibot/shared/webhook.ts
const irWebhookToAst$1 = ({ getAst, operation, plugin, state }) => {
	if (plugin.config.webhooks.enabled) {
		const requiredProperties = /* @__PURE__ */ new Set();
		const schemaData = {
			properties: {
				body: { type: "never" },
				path: { type: "never" },
				query: { type: "never" }
			},
			type: "object"
		};
		if (operation.parameters) {
			if (operation.parameters.header) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.header) {
					const parameter = operation.parameters.header[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("headers");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.headers = {
					properties,
					required,
					type: "object"
				};
			}
			if (operation.parameters.path) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.path) {
					const parameter = operation.parameters.path[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("path");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.path = {
					properties,
					required,
					type: "object"
				};
			}
			if (operation.parameters.query) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.query) {
					const parameter = operation.parameters.query[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("query");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.query = {
					properties,
					required,
					type: "object"
				};
			}
		}
		if (operation.body) {
			schemaData.properties.body = operation.body.schema;
			if (operation.body.required) requiredProperties.add("body");
		}
		schemaData.required = [...requiredProperties];
		exportAst$1({
			ast: getAst(schemaData, (0, _hey_api_codegen_core.fromRef)(state.path)),
			plugin,
			schema: schemaData,
			state,
			symbol: plugin.symbol(applyNaming(operation.id, plugin.config.webhooks), { meta: {
				category: "schema",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "webhook",
				resourceId: operation.id,
				role: "data",
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "valibot"
			} })
		});
	}
};

//#endregion
//#region src/plugins/valibot/v1/toAst/unknown.ts
const unknownToAst$3 = ({ plugin }) => {
	return $(plugin.external("valibot.v")).attr(identifiers$1.schemas.unknown).call();
};

//#endregion
//#region src/plugins/valibot/v1/toAst/array.ts
const arrayToAst$3 = ({ plugin, schema, state }) => {
	const result = { pipes: [] };
	const v = plugin.external("valibot.v");
	const functionName = $(v).attr(identifiers$1.schemas.array);
	if (!schema.items) {
		const expression = functionName.call(unknownToAst$3({
			plugin,
			schema: { type: "unknown" },
			state
		}));
		result.pipes.push(expression);
	} else {
		schema = deduplicateSchema({ schema });
		const itemExpressions = schema.items.map((item, index) => {
			const itemAst = irSchemaToAst$3({
				plugin,
				schema: item,
				state: {
					...state,
					path: (0, _hey_api_codegen_core.ref)([
						...(0, _hey_api_codegen_core.fromRef)(state.path),
						"items",
						index
					])
				}
			});
			if (itemAst.hasLazyExpression) result.hasLazyExpression = true;
			return pipesToNode(itemAst.pipes, plugin);
		});
		if (itemExpressions.length === 1) {
			const expression = functionName.call(...itemExpressions);
			result.pipes.push(expression);
		} else {
			if (schema.logicalOperator === "and") {}
			const expression = functionName.call(unknownToAst$3({
				plugin,
				schema: { type: "unknown" },
				state
			}));
			result.pipes.push(expression);
		}
	}
	if (schema.minItems === schema.maxItems && schema.minItems !== void 0) {
		const expression = $(v).attr(identifiers$1.actions.length).call($.fromValue(schema.minItems));
		result.pipes.push(expression);
	} else {
		if (schema.minItems !== void 0) {
			const expression = $(v).attr(identifiers$1.actions.minLength).call($.fromValue(schema.minItems));
			result.pipes.push(expression);
		}
		if (schema.maxItems !== void 0) {
			const expression = $(v).attr(identifiers$1.actions.maxLength).call($.fromValue(schema.maxItems));
			result.pipes.push(expression);
		}
	}
	return result;
};

//#endregion
//#region src/plugins/valibot/v1/toAst/boolean.ts
const booleanToAst$3 = ({ plugin, schema }) => {
	const pipes$1 = [];
	const v = plugin.external("valibot.v");
	if (typeof schema.const === "boolean") {
		pipes$1.push($(v).attr(identifiers$1.schemas.literal).call($.literal(schema.const)));
		return pipesToNode(pipes$1, plugin);
	}
	pipes$1.push($(v).attr(identifiers$1.schemas.boolean).call());
	return pipesToNode(pipes$1, plugin);
};

//#endregion
//#region src/plugins/valibot/v1/toAst/enum.ts
function itemsNode$3(ctx$1) {
	const { schema } = ctx$1;
	const enumMembers = [];
	let isNullable = false;
	for (const item of schema.items ?? []) if (item.type === "string" && typeof item.const === "string") enumMembers.push($.literal(item.const));
	else if (item.type === "null" || item.const === null) isNullable = true;
	return {
		enumMembers,
		isNullable
	};
}
function baseNode$15(ctx$1) {
	const { symbols } = ctx$1;
	const { v } = symbols;
	const { enumMembers } = ctx$1.nodes.items(ctx$1);
	return $(v).attr(identifiers$1.schemas.picklist).call($.array(...enumMembers));
}
function nullableNode$3(ctx$1) {
	const { symbols } = ctx$1;
	const { v } = symbols;
	const { isNullable } = ctx$1.nodes.items(ctx$1);
	if (!isNullable) return;
	const currentNode = ctx$1.pipes.toNode(ctx$1.pipes.current, ctx$1.plugin);
	return $(v).attr(identifiers$1.schemas.nullable).call(currentNode);
}
function enumResolver$3(ctx$1) {
	const { enumMembers } = ctx$1.nodes.items(ctx$1);
	if (!enumMembers.length) return ctx$1.pipes.current;
	const baseExpression = ctx$1.nodes.base(ctx$1);
	ctx$1.pipes.push(ctx$1.pipes.current, baseExpression);
	const nullableExpression = ctx$1.nodes.nullable(ctx$1);
	if (nullableExpression) return nullableExpression;
	return ctx$1.pipes.current;
}
const enumToAst$3 = ({ plugin, schema, state }) => {
	const v = plugin.external("valibot.v");
	const { enumMembers } = itemsNode$3({
		$,
		nodes: {
			base: baseNode$15,
			items: itemsNode$3,
			nullable: nullableNode$3
		},
		pipes: {
			...pipes,
			current: []
		},
		plugin,
		schema,
		symbols: { v },
		utils: { state }
	});
	if (!enumMembers.length) return unknownToAst$3({
		plugin,
		schema: { type: "unknown" },
		state
	});
	const ctx$1 = {
		$,
		nodes: {
			base: baseNode$15,
			items: itemsNode$3,
			nullable: nullableNode$3
		},
		pipes: {
			...pipes,
			current: []
		},
		plugin,
		schema,
		symbols: { v },
		utils: { state }
	};
	const resolver = plugin.config["~resolvers"]?.enum;
	const node = resolver?.(ctx$1) ?? enumResolver$3(ctx$1);
	return ctx$1.pipes.toNode(node, plugin);
};

//#endregion
//#region src/plugins/valibot/v1/toAst/never.ts
const neverToAst$3 = ({ plugin }) => {
	return $(plugin.external("valibot.v")).attr(identifiers$1.schemas.never).call();
};

//#endregion
//#region src/plugins/valibot/v1/toAst/null.ts
const nullToAst$3 = ({ plugin }) => {
	return $(plugin.external("valibot.v")).attr(identifiers$1.schemas.null).call();
};

//#endregion
//#region src/plugins/shared/utils/formats.ts
const rangeErrors = (format, range) => ({
	maxError: `Invalid value: Expected ${format} to be <= ${range[1]}`,
	minError: `Invalid value: Expected ${format} to be >= ${range[0]}`
});
const integerRange = {
	int16: [-32768, 32767],
	int32: [-2147483648, 2147483647],
	int64: ["-9223372036854775808", "9223372036854775807"],
	int8: [-128, 127],
	uint16: [0, 65535],
	uint32: [0, 4294967295],
	uint64: ["0", "18446744073709551615"],
	uint8: [0, 255]
};
const getIntegerLimit = (format) => {
	if (!format) return;
	const range = integerRange[format];
	if (!range) return;
	const errors = rangeErrors(format, range);
	return {
		maxValue: range[1],
		minValue: range[0],
		...errors
	};
};

//#endregion
//#region src/plugins/valibot/v1/toAst/number.ts
function baseNode$14(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	if (ctx$1.utils.shouldCoerceToBigInt(schema.format)) return [$(v).attr(identifiers$1.schemas.union).call($.array($(v).attr(identifiers$1.schemas.number).call(), $(v).attr(identifiers$1.schemas.string).call(), $(v).attr(identifiers$1.schemas.bigInt).call())), $(v).attr(identifiers$1.actions.transform).call($.func().param("x").do($("BigInt").call("x").return()))];
	const pipes$1 = [];
	pipes$1.push($(v).attr(identifiers$1.schemas.number).call());
	if (schema.type === "integer") pipes$1.push($(v).attr(identifiers$1.actions.integer).call());
	return pipes$1;
}
function constNode$7(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	if (schema.const === void 0) return;
	return $(v).attr(identifiers$1.schemas.literal).call(ctx$1.utils.maybeBigInt(schema.const, schema.format));
}
function maxNode$3(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	if (schema.exclusiveMaximum !== void 0) return $(v).attr(identifiers$1.actions.ltValue).call(ctx$1.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));
	if (schema.maximum !== void 0) return $(v).attr(identifiers$1.actions.maxValue).call(ctx$1.utils.maybeBigInt(schema.maximum, schema.format));
	const limit = ctx$1.utils.getIntegerLimit(schema.format);
	if (limit) return $(v).attr(identifiers$1.actions.maxValue).call(ctx$1.utils.maybeBigInt(limit.maxValue, schema.format), $.literal(limit.maxError));
}
function minNode$3(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	if (schema.exclusiveMinimum !== void 0) return $(v).attr(identifiers$1.actions.gtValue).call(ctx$1.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));
	if (schema.minimum !== void 0) return $(v).attr(identifiers$1.actions.minValue).call(ctx$1.utils.maybeBigInt(schema.minimum, schema.format));
	const limit = ctx$1.utils.getIntegerLimit(schema.format);
	if (limit) return $(v).attr(identifiers$1.actions.minValue).call(ctx$1.utils.maybeBigInt(limit.minValue, schema.format), $.literal(limit.minError));
}
function numberResolver$3(ctx$1) {
	const constNode$8 = ctx$1.nodes.const(ctx$1);
	if (constNode$8) return ctx$1.pipes.push(ctx$1.pipes.current, constNode$8);
	const baseNode$16 = ctx$1.nodes.base(ctx$1);
	if (baseNode$16) ctx$1.pipes.push(ctx$1.pipes.current, baseNode$16);
	const minNode$4 = ctx$1.nodes.min(ctx$1);
	if (minNode$4) ctx$1.pipes.push(ctx$1.pipes.current, minNode$4);
	const maxNode$4 = ctx$1.nodes.max(ctx$1);
	if (maxNode$4) ctx$1.pipes.push(ctx$1.pipes.current, maxNode$4);
	return ctx$1.pipes.current;
}
const numberToNode$3 = ({ plugin, schema }) => {
	const ctx$1 = {
		$,
		nodes: {
			base: baseNode$14,
			const: constNode$7,
			max: maxNode$3,
			min: minNode$3
		},
		pipes: {
			...pipes,
			current: []
		},
		plugin,
		schema,
		symbols: { v: plugin.external("valibot.v") },
		utils: {
			getIntegerLimit,
			maybeBigInt,
			shouldCoerceToBigInt
		}
	};
	const resolver = plugin.config["~resolvers"]?.number;
	const node = resolver?.(ctx$1) ?? numberResolver$3(ctx$1);
	return ctx$1.pipes.toNode(node, plugin);
};

//#endregion
//#region src/plugins/valibot/v1/toAst/object.ts
function additionalPropertiesNode$3(ctx$1) {
	const { plugin, schema } = ctx$1;
	if (!schema.additionalProperties || !schema.additionalProperties.type) return;
	if (schema.additionalProperties.type === "never") return null;
	const additionalAst = irSchemaToAst$3({
		plugin,
		schema: schema.additionalProperties,
		state: {
			...ctx$1.utils.state,
			path: (0, _hey_api_codegen_core.ref)([...(0, _hey_api_codegen_core.fromRef)(ctx$1.utils.state.path), "additionalProperties"])
		}
	});
	if (additionalAst.hasLazyExpression) ctx$1.utils.ast.hasLazyExpression = true;
	return pipes.toNode(additionalAst.pipes, plugin);
}
function baseNode$13(ctx$1) {
	const { nodes, symbols } = ctx$1;
	const { v } = symbols;
	const additional = nodes.additionalProperties(ctx$1);
	const shape = nodes.shape(ctx$1);
	if (additional === null) return $(v).attr(identifiers$1.schemas.strictObject).call(shape);
	if (additional) {
		if (shape.isEmpty) return $(v).attr(identifiers$1.schemas.record).call($(v).attr(identifiers$1.schemas.string).call(), additional);
		return $(v).attr(identifiers$1.schemas.objectWithRest).call(shape, additional);
	}
	return $(v).attr(identifiers$1.schemas.object).call(shape);
}
function objectResolver$3(ctx$1) {
	return ctx$1.nodes.base(ctx$1);
}
function shapeNode$3(ctx$1) {
	const { plugin, schema } = ctx$1;
	const shape = $.object().pretty();
	for (const name in schema.properties) {
		const property = schema.properties[name];
		const propertyAst = irSchemaToAst$3({
			optional: !schema.required?.includes(name),
			plugin,
			schema: property,
			state: {
				...ctx$1.utils.state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(ctx$1.utils.state.path),
					"properties",
					name
				])
			}
		});
		if (propertyAst.hasLazyExpression) ctx$1.utils.ast.hasLazyExpression = true;
		shape.prop(name, pipes.toNode(propertyAst.pipes, plugin));
	}
	return shape;
}
const objectToAst$3 = ({ plugin, schema, state }) => {
	const ctx$1 = {
		$,
		nodes: {
			additionalProperties: additionalPropertiesNode$3,
			base: baseNode$13,
			shape: shapeNode$3
		},
		pipes: {
			...pipes,
			current: []
		},
		plugin,
		schema,
		symbols: { v: plugin.external("valibot.v") },
		utils: {
			ast: {},
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.object;
	const node = resolver?.(ctx$1) ?? objectResolver$3(ctx$1);
	ctx$1.utils.ast.pipes = [ctx$1.pipes.toNode(node, plugin)];
	return ctx$1.utils.ast;
};

//#endregion
//#region src/plugins/valibot/v1/toAst/string.ts
function baseNode$12(ctx$1) {
	const { v } = ctx$1.symbols;
	return $(v).attr(identifiers$1.schemas.string).call();
}
function constNode$6(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	if (typeof schema.const !== "string") return;
	return $(v).attr(identifiers$1.schemas.literal).call($.literal(schema.const));
}
function formatNode$3(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	switch (schema.format) {
		case "date": return $(v).attr(identifiers$1.actions.isoDate).call();
		case "date-time": return $(v).attr(identifiers$1.actions.isoTimestamp).call();
		case "email": return $(v).attr(identifiers$1.actions.email).call();
		case "ipv4":
		case "ipv6": return $(v).attr(identifiers$1.actions.ip).call();
		case "time": return $(v).attr(identifiers$1.actions.isoTimeSecond).call();
		case "uri": return $(v).attr(identifiers$1.actions.url).call();
		case "uuid": return $(v).attr(identifiers$1.actions.uuid).call();
	}
}
function lengthNode$3(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	if (schema.minLength === void 0 || schema.minLength !== schema.maxLength) return;
	return $(v).attr(identifiers$1.actions.length).call($.literal(schema.minLength));
}
function maxLengthNode$3(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	if (schema.maxLength === void 0) return;
	return $(v).attr(identifiers$1.actions.maxLength).call($.literal(schema.maxLength));
}
function minLengthNode$3(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	if (schema.minLength === void 0) return;
	return $(v).attr(identifiers$1.actions.minLength).call($.literal(schema.minLength));
}
function patternNode$3(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { v } = symbols;
	if (!schema.pattern) return;
	return $(v).attr(identifiers$1.actions.regex).call($.regexp(schema.pattern));
}
function stringResolver$3(ctx$1) {
	const constNode$8 = ctx$1.nodes.const(ctx$1);
	if (constNode$8) return ctx$1.pipes.push(ctx$1.pipes.current, constNode$8);
	const baseNode$16 = ctx$1.nodes.base(ctx$1);
	if (baseNode$16) ctx$1.pipes.push(ctx$1.pipes.current, baseNode$16);
	const formatNode$4 = ctx$1.nodes.format(ctx$1);
	if (formatNode$4) ctx$1.pipes.push(ctx$1.pipes.current, formatNode$4);
	const lengthNode$4 = ctx$1.nodes.length(ctx$1);
	if (lengthNode$4) ctx$1.pipes.push(ctx$1.pipes.current, lengthNode$4);
	else {
		const minLengthNode$4 = ctx$1.nodes.minLength(ctx$1);
		if (minLengthNode$4) ctx$1.pipes.push(ctx$1.pipes.current, minLengthNode$4);
		const maxLengthNode$4 = ctx$1.nodes.maxLength(ctx$1);
		if (maxLengthNode$4) ctx$1.pipes.push(ctx$1.pipes.current, maxLengthNode$4);
	}
	const patternNode$4 = ctx$1.nodes.pattern(ctx$1);
	if (patternNode$4) ctx$1.pipes.push(ctx$1.pipes.current, patternNode$4);
	return ctx$1.pipes.current;
}
const stringToNode$3 = ({ plugin, schema }) => {
	const ctx$1 = {
		$,
		nodes: {
			base: baseNode$12,
			const: constNode$6,
			format: formatNode$3,
			length: lengthNode$3,
			maxLength: maxLengthNode$3,
			minLength: minLengthNode$3,
			pattern: patternNode$3
		},
		pipes: {
			...pipes,
			current: []
		},
		plugin,
		schema,
		symbols: { v: plugin.external("valibot.v") }
	};
	const resolver = plugin.config["~resolvers"]?.string;
	const node = resolver?.(ctx$1) ?? stringResolver$3(ctx$1);
	return ctx$1.pipes.toNode(node, plugin);
};

//#endregion
//#region src/plugins/valibot/v1/toAst/tuple.ts
const tupleToAst$3 = ({ plugin, schema, state }) => {
	const result = {};
	const v = plugin.external("valibot.v");
	if (schema.const && Array.isArray(schema.const)) {
		const tupleElements = schema.const.map((value) => $(v).attr(identifiers$1.schemas.literal).call($.fromValue(value)));
		result.pipes = [$(v).attr(identifiers$1.schemas.tuple).call($.array(...tupleElements))];
		return result;
	}
	if (schema.items) {
		const tupleElements = schema.items.map((item, index) => {
			const schemaPipes = irSchemaToAst$3({
				plugin,
				schema: item,
				state: {
					...state,
					path: (0, _hey_api_codegen_core.ref)([
						...(0, _hey_api_codegen_core.fromRef)(state.path),
						"items",
						index
					])
				}
			});
			if (schemaPipes.hasLazyExpression) result.hasLazyExpression = true;
			return pipesToNode(schemaPipes.pipes, plugin);
		});
		result.pipes = [$(v).attr(identifiers$1.schemas.tuple).call($.array(...tupleElements))];
		return result;
	}
	return { pipes: [unknownToAst$3({
		plugin,
		schema: { type: "unknown" },
		state
	})] };
};

//#endregion
//#region src/plugins/valibot/v1/toAst/undefined.ts
const undefinedToAst$3 = ({ plugin }) => {
	return $(plugin.external("valibot.v")).attr(identifiers$1.schemas.undefined).call();
};

//#endregion
//#region src/plugins/valibot/v1/toAst/void.ts
const voidToAst$3 = ({ plugin }) => {
	return $(plugin.external("valibot.v")).attr(identifiers$1.schemas.void).call();
};

//#endregion
//#region src/plugins/valibot/v1/toAst/index.ts
const irSchemaWithTypeToAst$3 = ({ schema, ...args }) => {
	switch (schema.type) {
		case "array": return { expression: pipesToNode(arrayToAst$3({
			...args,
			schema
		}).pipes, args.plugin) };
		case "boolean": return { expression: booleanToAst$3({
			...args,
			schema
		}) };
		case "enum": return { expression: enumToAst$3({
			...args,
			schema
		}) };
		case "integer":
		case "number": return { expression: numberToNode$3({
			...args,
			schema
		}) };
		case "never": return { expression: neverToAst$3({
			...args,
			schema
		}) };
		case "null": return { expression: nullToAst$3({
			...args,
			schema
		}) };
		case "object": return { expression: pipesToNode(objectToAst$3({
			...args,
			schema
		}).pipes, args.plugin) };
		case "string": return { expression: shouldCoerceToBigInt(schema.format) ? numberToNode$3({
			...args,
			schema: {
				...schema,
				type: "number"
			}
		}) : stringToNode$3({
			...args,
			schema
		}) };
		case "tuple": return { expression: pipesToNode(tupleToAst$3({
			...args,
			schema
		}).pipes, args.plugin) };
		case "undefined": return { expression: undefinedToAst$3({
			...args,
			schema
		}) };
		case "unknown": return { expression: unknownToAst$3({
			...args,
			schema
		}) };
		case "void": return { expression: voidToAst$3({
			...args,
			schema
		}) };
	}
};

//#endregion
//#region src/plugins/valibot/v1/plugin.ts
const irSchemaToAst$3 = ({ optional, plugin, schema, state }) => {
	const ast = { pipes: [] };
	const v = plugin.external("valibot.v");
	if (schema.$ref) {
		const query = {
			category: "schema",
			resource: "definition",
			resourceId: schema.$ref,
			tool: "valibot"
		};
		const refSymbol = plugin.referenceSymbol(query);
		if (plugin.isSymbolRegistered(query)) {
			const ref$41 = $(refSymbol);
			ast.pipes.push(ref$41);
		} else {
			const lazyExpression = $(v).attr(identifiers$1.schemas.lazy).call($.func().do($(refSymbol).return()));
			ast.pipes.push(lazyExpression);
			state.hasLazyExpression["~ref"] = true;
		}
	} else if (schema.type) {
		const typeAst = irSchemaWithTypeToAst$3({
			plugin,
			schema,
			state
		});
		ast.typeName = typeAst.anyType;
		ast.pipes.push(typeAst.expression);
		if (plugin.config.metadata && schema.description) {
			const expression = $(v).attr(identifiers$1.actions.metadata).call($.object().prop("description", $.literal(schema.description)));
			ast.pipes.push(expression);
		}
	} else if (schema.items) {
		schema = deduplicateSchema({ schema });
		if (schema.items) {
			const itemsAst = schema.items.map((item, index) => {
				return pipesToNode(irSchemaToAst$3({
					plugin,
					schema: item,
					state: {
						...state,
						path: (0, _hey_api_codegen_core.ref)([
							...(0, _hey_api_codegen_core.fromRef)(state.path),
							"items",
							index
						])
					}
				}).pipes, plugin);
			});
			if (schema.logicalOperator === "and") {
				const intersectExpression = $(v).attr(identifiers$1.schemas.intersect).call($.array(...itemsAst));
				ast.pipes.push(intersectExpression);
			} else {
				const unionExpression = $(v).attr(identifiers$1.schemas.union).call($.array(...itemsAst));
				ast.pipes.push(unionExpression);
			}
		} else {
			const schemaPipes = irSchemaToAst$3({
				plugin,
				schema,
				state
			});
			ast.pipes.push(...schemaPipes.pipes);
		}
	} else {
		const typeAst = irSchemaWithTypeToAst$3({
			plugin,
			schema: { type: "unknown" },
			state
		});
		ast.typeName = typeAst.anyType;
		ast.pipes.push(typeAst.expression);
	}
	if (ast.pipes.length) {
		if (schema.accessScope === "read") {
			const readonlyExpression = $(v).attr(identifiers$1.actions.readonly).call();
			ast.pipes.push(readonlyExpression);
		}
		if (schema.default !== void 0) ast.pipes = [$(v).attr(identifiers$1.schemas.optional).call(pipesToNode(ast.pipes, plugin), schema.type === "integer" || schema.type === "number" ? maybeBigInt(schema.default, schema.format) : $.fromValue(schema.default))];
		else if (optional) ast.pipes = [$(v).attr(identifiers$1.schemas.optional).call(pipesToNode(ast.pipes, plugin))];
	}
	return ast;
};
const handleComponent$3 = ({ plugin, schema, state }) => {
	const $ref = pathToJsonPointer((0, _hey_api_codegen_core.fromRef)(state.path));
	const ast = irSchemaToAst$3({
		plugin,
		schema,
		state
	});
	const baseName = refToName($ref);
	exportAst$1({
		ast,
		plugin,
		schema,
		state,
		symbol: plugin.symbol(applyNaming(baseName, plugin.config.definitions), { meta: {
			category: "schema",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "definition",
			resourceId: $ref,
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "valibot"
		} })
	});
};
const handlerV1 = ({ plugin }) => {
	plugin.symbol("v", {
		external: "valibot",
		importKind: "namespace",
		meta: {
			category: "external",
			resource: "valibot.v"
		}
	});
	plugin.forEach("operation", "parameter", "requestBody", "schema", "webhook", (event) => {
		const state = (0, _hey_api_codegen_core.refs)({
			hasLazyExpression: false,
			path: event._path,
			tags: event.tags
		});
		switch (event.type) {
			case "operation":
				irOperationToAst$1({
					getAst: (schema, path$10) => {
						return irSchemaToAst$3({
							plugin,
							schema,
							state: (0, _hey_api_codegen_core.refs)({
								hasLazyExpression: false,
								path: path$10,
								tags: event.tags
							})
						});
					},
					operation: event.operation,
					plugin,
					state
				});
				break;
			case "parameter":
				handleComponent$3({
					plugin,
					schema: event.parameter.schema,
					state
				});
				break;
			case "requestBody":
				handleComponent$3({
					plugin,
					schema: event.requestBody.schema,
					state
				});
				break;
			case "schema":
				handleComponent$3({
					plugin,
					schema: event.schema,
					state
				});
				break;
			case "webhook":
				irWebhookToAst$1({
					getAst: (schema, path$10) => {
						return irSchemaToAst$3({
							plugin,
							schema,
							state: (0, _hey_api_codegen_core.refs)({
								hasLazyExpression: false,
								path: path$10,
								tags: event.tags
							})
						});
					},
					operation: event.operation,
					plugin,
					state
				});
				break;
		}
	});
};

//#endregion
//#region src/plugins/valibot/plugin.ts
const handler$1 = (args) => handlerV1(args);

//#endregion
//#region src/plugins/valibot/config.ts
const defaultConfig$1 = {
	api: new Api$1(),
	config: {
		case: "camelCase",
		comments: true,
		exportFromIndex: false,
		metadata: false
	},
	handler: handler$1,
	name: "valibot",
	resolveConfig: (plugin, context) => {
		plugin.config.definitions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "v{{name}}"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.definitions
		});
		plugin.config.requests = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "v{{name}}Data"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.requests
		});
		plugin.config.responses = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "v{{name}}Response"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.responses
		});
		plugin.config.webhooks = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "v{{name}}WebhookRequest"
			},
			mappers: {
				boolean: (enabled) => ({ enabled }),
				function: (name) => ({ name }),
				string: (name) => ({ name })
			},
			value: plugin.config.webhooks
		});
	},
	tags: ["validator"]
};
/**
* Type helper for Valibot plugin, returns {@link Plugin.Config} object
*/
const defineConfig$1 = definePluginConfig(defaultConfig$1);

//#endregion
//#region src/plugins/zod/constants.ts
const identifiers = {
	ZodMiniOptional: "ZodMiniOptional",
	ZodOptional: "ZodOptional",
	_default: "_default",
	and: "and",
	array: "array",
	bigint: "bigint",
	boolean: "boolean",
	check: "check",
	coerce: "coerce",
	date: "date",
	datetime: "datetime",
	default: "default",
	describe: "describe",
	email: "email",
	enum: "enum",
	globalRegistry: "globalRegistry",
	gt: "gt",
	gte: "gte",
	infer: "infer",
	int: "int",
	intersection: "intersection",
	ip: "ip",
	ipv4: "ipv4",
	ipv6: "ipv6",
	iso: "iso",
	lazy: "lazy",
	length: "length",
	literal: "literal",
	lt: "lt",
	lte: "lte",
	max: "max",
	maxLength: "maxLength",
	maximum: "maximum",
	min: "min",
	minLength: "minLength",
	minimum: "minimum",
	never: "never",
	null: "null",
	nullable: "nullable",
	number: "number",
	object: "object",
	optional: "optional",
	parseAsync: "parseAsync",
	readonly: "readonly",
	record: "record",
	regex: "regex",
	register: "register",
	string: "string",
	time: "time",
	tuple: "tuple",
	undefined: "undefined",
	union: "union",
	unknown: "unknown",
	url: "url",
	uuid: "uuid",
	void: "void"
};

//#endregion
//#region src/plugins/zod/mini/api.ts
const validatorResolver$2 = (ctx$1) => {
	const { schema } = ctx$1.symbols;
	return $(schema).attr(identifiers.parseAsync).call("data").await().return();
};
const createRequestValidatorMini = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tool: "zod"
	});
	if (!symbol) return;
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		operation,
		plugin,
		symbols: {
			schema: symbol,
			z
		}
	};
	const validator = plugin.config["~resolvers"]?.validator;
	const candidates = [typeof validator === "function" ? validator : validator?.request, validatorResolver$2];
	for (const candidate of candidates) {
		const statements = candidate?.(ctx$1);
		if (statements === null) return;
		if (statements !== void 0) return $.func().async().param("data").do(...statements instanceof Array ? statements : [statements]);
	}
};
const createResponseValidatorMini = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "responses",
		tool: "zod"
	});
	if (!symbol) return;
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		operation,
		plugin,
		symbols: {
			schema: symbol,
			z
		}
	};
	const validator = plugin.config["~resolvers"]?.validator;
	const candidates = [typeof validator === "function" ? validator : validator?.response, validatorResolver$2];
	for (const candidate of candidates) {
		const statements = candidate?.(ctx$1);
		if (statements === null) return;
		if (statements !== void 0) return $.func().async().param("data").do(...statements instanceof Array ? statements : [statements]);
	}
};

//#endregion
//#region src/plugins/zod/v3/api.ts
const validatorResolver$1 = (ctx$1) => {
	const { schema } = ctx$1.symbols;
	return $(schema).attr(identifiers.parseAsync).call("data").await().return();
};
const createRequestValidatorV3 = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tool: "zod"
	});
	if (!symbol) return;
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		operation,
		plugin,
		symbols: {
			schema: symbol,
			z
		}
	};
	const validator = plugin.config["~resolvers"]?.validator;
	const candidates = [typeof validator === "function" ? validator : validator?.request, validatorResolver$1];
	for (const candidate of candidates) {
		const statements = candidate?.(ctx$1);
		if (statements === null) return;
		if (statements !== void 0) return $.func().async().param("data").do(...statements instanceof Array ? statements : [statements]);
	}
};
const createResponseValidatorV3 = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "responses",
		tool: "zod"
	});
	if (!symbol) return;
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		operation,
		plugin,
		symbols: {
			schema: symbol,
			z
		}
	};
	const validator = plugin.config["~resolvers"]?.validator;
	const candidates = [typeof validator === "function" ? validator : validator?.response, validatorResolver$1];
	for (const candidate of candidates) {
		const statements = candidate?.(ctx$1);
		if (statements === null) return;
		if (statements !== void 0) return $.func().async().param("data").do(...statements instanceof Array ? statements : [statements]);
	}
};

//#endregion
//#region src/plugins/zod/v4/api.ts
const validatorResolver = (ctx$1) => {
	const { schema } = ctx$1.symbols;
	return $(schema).attr(identifiers.parseAsync).call("data").await().return();
};
const createRequestValidatorV4 = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "data",
		tool: "zod"
	});
	if (!symbol) return;
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		operation,
		plugin,
		symbols: {
			schema: symbol,
			z
		}
	};
	const validator = plugin.config["~resolvers"]?.validator;
	const candidates = [typeof validator === "function" ? validator : validator?.request, validatorResolver];
	for (const candidate of candidates) {
		const statements = candidate?.(ctx$1);
		if (statements === null) return;
		if (statements !== void 0) return $.func().async().param("data").do(...statements instanceof Array ? statements : [statements]);
	}
};
const createResponseValidatorV4 = ({ operation, plugin }) => {
	const symbol = plugin.getSymbol({
		category: "schema",
		resource: "operation",
		resourceId: operation.id,
		role: "responses",
		tool: "zod"
	});
	if (!symbol) return;
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		operation,
		plugin,
		symbols: {
			schema: symbol,
			z
		}
	};
	const validator = plugin.config["~resolvers"]?.validator;
	const candidates = [typeof validator === "function" ? validator : validator?.response, validatorResolver];
	for (const candidate of candidates) {
		const statements = candidate?.(ctx$1);
		if (statements === null) return;
		if (statements !== void 0) return $.func().async().param("data").do(...statements instanceof Array ? statements : [statements]);
	}
};

//#endregion
//#region src/plugins/zod/api.ts
var Api = class {
	createRequestValidator(args) {
		const { plugin } = args;
		switch (plugin.config.compatibilityVersion) {
			case 3: return createRequestValidatorV3(args);
			case "mini": return createRequestValidatorMini(args);
			case 4:
			default: return createRequestValidatorV4(args);
		}
	}
	createResponseValidator(args) {
		const { plugin } = args;
		switch (plugin.config.compatibilityVersion) {
			case 3: return createResponseValidatorV3(args);
			case "mini": return createResponseValidatorMini(args);
			case 4:
			default: return createResponseValidatorV4(args);
		}
	}
};

//#endregion
//#region src/plugins/zod/shared/export.ts
const exportAst = ({ ast, plugin, schema, symbol, typeInferSymbol }) => {
	const z = plugin.external("zod.z");
	const statement = $.const(symbol).export().$if(plugin.config.comments && createSchemaComment(schema), (c, v) => c.doc(v)).$if(ast.typeName, (c, v) => c.type($.type(z).attr(v))).assign(ast.expression);
	plugin.node(statement);
	if (typeInferSymbol) {
		const inferType = $.type.alias(typeInferSymbol).export().type($.type(z).attr(identifiers.infer).generic($(symbol).typeofType()));
		plugin.node(inferType);
	}
};

//#endregion
//#region src/plugins/zod/shared/module.ts
const getZodModule = ({ plugin }) => {
	const version = plugin.package.getVersion("zod");
	if (version) {
		if (plugin.package.satisfies(version, "<4.0.0")) switch (plugin.config.compatibilityVersion) {
			case 3:
			default: return "zod";
			case 4: return "zod/v4";
			case "mini": return "zod/v4-mini";
		}
	}
	switch (plugin.config.compatibilityVersion) {
		case 3: return "zod/v3";
		case 4:
		default: return "zod";
		case "mini": return "zod/mini";
	}
};

//#endregion
//#region src/plugins/zod/shared/operation.ts
const irOperationToAst = ({ getAst, operation, plugin, state }) => {
	if (plugin.config.requests.enabled) {
		const requiredProperties = /* @__PURE__ */ new Set();
		const schemaData = {
			properties: {
				body: { type: "never" },
				path: { type: "never" },
				query: { type: "never" }
			},
			type: "object"
		};
		if (operation.parameters) {
			if (operation.parameters.header) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.header) {
					const parameter = operation.parameters.header[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("headers");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.headers = {
					properties,
					required,
					type: "object"
				};
			}
			if (operation.parameters.path) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.path) {
					const parameter = operation.parameters.path[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("path");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.path = {
					properties,
					required,
					type: "object"
				};
			}
			if (operation.parameters.query) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.query) {
					const parameter = operation.parameters.query[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("query");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.query = {
					properties,
					required,
					type: "object"
				};
			}
		}
		if (operation.body) {
			schemaData.properties.body = operation.body.schema;
			if (operation.body.required) requiredProperties.add("body");
		}
		schemaData.required = [...requiredProperties];
		exportAst({
			ast: getAst(schemaData, (0, _hey_api_codegen_core.fromRef)(state.path)),
			plugin,
			schema: schemaData,
			symbol: plugin.symbol(applyNaming(operation.id, plugin.config.requests), { meta: {
				category: "schema",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "operation",
				resourceId: operation.id,
				role: "data",
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "zod"
			} }),
			typeInferSymbol: plugin.config.requests.types.infer.enabled ? plugin.symbol(applyNaming(operation.id, plugin.config.requests.types.infer), { meta: {
				category: "type",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "operation",
				resourceId: operation.id,
				role: "data",
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "zod",
				variant: "infer"
			} }) : void 0
		});
	}
	if (plugin.config.responses.enabled) {
		if (operation.responses) {
			const { response } = operationResponsesMap(operation);
			if (response) {
				const path$10 = [...(0, _hey_api_codegen_core.fromRef)(state.path), "responses"];
				exportAst({
					ast: getAst(response, path$10),
					plugin,
					schema: response,
					symbol: plugin.symbol(applyNaming(operation.id, plugin.config.responses), { meta: {
						category: "schema",
						path: path$10,
						resource: "operation",
						resourceId: operation.id,
						role: "responses",
						tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
						tool: "zod"
					} }),
					typeInferSymbol: plugin.config.responses.types.infer.enabled ? plugin.symbol(applyNaming(operation.id, plugin.config.responses.types.infer), { meta: {
						category: "type",
						path: path$10,
						resource: "operation",
						resourceId: operation.id,
						role: "responses",
						tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
						tool: "zod",
						variant: "infer"
					} }) : void 0
				});
			}
		}
	}
};

//#endregion
//#region src/plugins/zod/shared/webhook.ts
const irWebhookToAst = ({ getAst, operation, plugin, state }) => {
	if (plugin.config.webhooks.enabled) {
		const requiredProperties = /* @__PURE__ */ new Set();
		const schemaData = {
			properties: {
				body: { type: "never" },
				path: { type: "never" },
				query: { type: "never" }
			},
			type: "object"
		};
		if (operation.parameters) {
			if (operation.parameters.header) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.header) {
					const parameter = operation.parameters.header[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("headers");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.headers = {
					properties,
					required,
					type: "object"
				};
			}
			if (operation.parameters.path) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.path) {
					const parameter = operation.parameters.path[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("path");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.path = {
					properties,
					required,
					type: "object"
				};
			}
			if (operation.parameters.query) {
				const properties = {};
				const required = [];
				for (const key in operation.parameters.query) {
					const parameter = operation.parameters.query[key];
					properties[parameter.name] = parameter.schema;
					if (parameter.required) {
						required.push(parameter.name);
						requiredProperties.add("query");
					}
				}
				if (Object.keys(properties).length) schemaData.properties.query = {
					properties,
					required,
					type: "object"
				};
			}
		}
		if (operation.body) {
			schemaData.properties.body = operation.body.schema;
			if (operation.body.required) requiredProperties.add("body");
		}
		schemaData.required = [...requiredProperties];
		exportAst({
			ast: getAst(schemaData, (0, _hey_api_codegen_core.fromRef)(state.path)),
			plugin,
			schema: schemaData,
			symbol: plugin.symbol(applyNaming(operation.id, plugin.config.webhooks), { meta: {
				category: "schema",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "webhook",
				resourceId: operation.id,
				role: "data",
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "zod"
			} }),
			typeInferSymbol: plugin.config.webhooks.types.infer.enabled ? plugin.symbol(applyNaming(operation.id, plugin.config.webhooks.types.infer), { meta: {
				category: "type",
				path: (0, _hey_api_codegen_core.fromRef)(state.path),
				resource: "webhook",
				resourceId: operation.id,
				role: "data",
				tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
				tool: "zod",
				variant: "infer"
			} }) : void 0
		});
	}
};

//#endregion
//#region src/plugins/zod/mini/toAst/unknown.ts
const unknownToAst$2 = ({ plugin }) => {
	const z = plugin.external("zod.z");
	const result = {};
	result.expression = $(z).attr(identifiers.unknown).call();
	return result;
};

//#endregion
//#region src/plugins/zod/mini/toAst/array.ts
const arrayToAst$2 = ({ plugin, schema, state }) => {
	const z = plugin.external("zod.z");
	const result = {};
	const functionName = $(z).attr(identifiers.array);
	if (!schema.items) result.expression = functionName.call(unknownToAst$2({
		plugin,
		schema: { type: "unknown" },
		state
	}).expression);
	else {
		schema = deduplicateSchema({ schema });
		const itemExpressions = schema.items.map((item, index) => {
			const itemAst = irSchemaToAst$2({
				plugin,
				schema: item,
				state: {
					...state,
					path: (0, _hey_api_codegen_core.ref)([
						...(0, _hey_api_codegen_core.fromRef)(state.path),
						"items",
						index
					])
				}
			});
			if (itemAst.hasLazyExpression) result.hasLazyExpression = true;
			return itemAst.expression;
		});
		if (itemExpressions.length === 1) result.expression = functionName.call(...itemExpressions);
		else if (schema.logicalOperator === "and") {
			const firstSchema = schema.items[0];
			let intersectionExpression;
			if (firstSchema.logicalOperator === "or" || firstSchema.type && firstSchema.type !== "object") intersectionExpression = $(z).attr(identifiers.intersection).call(...itemExpressions);
			else {
				intersectionExpression = itemExpressions[0];
				for (let i = 1; i < itemExpressions.length; i++) intersectionExpression = $(z).attr(identifiers.intersection).call(intersectionExpression, itemExpressions[i]);
			}
			result.expression = functionName.call(intersectionExpression);
		} else result.expression = $(z).attr(identifiers.array).call($(z).attr(identifiers.union).call($.array(...itemExpressions)));
	}
	const checks = [];
	if (schema.minItems === schema.maxItems && schema.minItems !== void 0) checks.push($(z).attr(identifiers.length).call($.fromValue(schema.minItems)));
	else {
		if (schema.minItems !== void 0) checks.push($(z).attr(identifiers.minLength).call($.fromValue(schema.minItems)));
		if (schema.maxItems !== void 0) checks.push($(z).attr(identifiers.maxLength).call($.fromValue(schema.maxItems)));
	}
	if (checks.length > 0) result.expression = result.expression.attr(identifiers.check).call(...checks);
	return result;
};

//#endregion
//#region src/plugins/zod/mini/toAst/boolean.ts
const booleanToAst$2 = ({ plugin, schema }) => {
	const result = {};
	let chain;
	const z = plugin.external("zod.z");
	if (typeof schema.const === "boolean") {
		chain = $(z).attr(identifiers.literal).call($.literal(schema.const));
		result.expression = chain;
		return result;
	}
	chain = $(z).attr(identifiers.boolean).call();
	result.expression = chain;
	return result;
};

//#endregion
//#region src/plugins/zod/mini/toAst/enum.ts
function itemsNode$2(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	const enumMembers = [];
	const literalMembers = [];
	let isNullable = false;
	let allStrings = true;
	for (const item of schema.items ?? []) if (item.type === "string" && typeof item.const === "string") {
		const literal = $.literal(item.const);
		enumMembers.push(literal);
		literalMembers.push($(z).attr(identifiers.literal).call(literal));
	} else if ((item.type === "number" || item.type === "integer") && typeof item.const === "number") {
		allStrings = false;
		const literal = $.literal(item.const);
		literalMembers.push($(z).attr(identifiers.literal).call(literal));
	} else if (item.type === "boolean" && typeof item.const === "boolean") {
		allStrings = false;
		const literal = $.literal(item.const);
		literalMembers.push($(z).attr(identifiers.literal).call(literal));
	} else if (item.type === "null" || item.const === null) isNullable = true;
	return {
		allStrings,
		enumMembers,
		isNullable,
		literalMembers
	};
}
function baseNode$11(ctx$1) {
	const { symbols } = ctx$1;
	const { z } = symbols;
	const { allStrings, enumMembers, literalMembers } = ctx$1.nodes.items(ctx$1);
	if (allStrings && enumMembers.length > 0) return $(z).attr(identifiers.enum).call($.array(...enumMembers));
	else if (literalMembers.length === 1) return literalMembers[0];
	else return $(z).attr(identifiers.union).call($.array(...literalMembers));
}
function nullableNode$2(ctx$1) {
	const { chain, symbols } = ctx$1;
	const { z } = symbols;
	const { isNullable } = ctx$1.nodes.items(ctx$1);
	if (!isNullable) return;
	return $(z).attr(identifiers.nullable).call(chain.current);
}
function enumResolver$2(ctx$1) {
	const { literalMembers } = ctx$1.nodes.items(ctx$1);
	if (!literalMembers.length) return ctx$1.chain.current;
	const baseExpression = ctx$1.nodes.base(ctx$1);
	ctx$1.chain.current = baseExpression;
	const nullableExpression = ctx$1.nodes.nullable(ctx$1);
	if (nullableExpression) ctx$1.chain.current = nullableExpression;
	return ctx$1.chain.current;
}
const enumToAst$2 = ({ plugin, schema, state }) => {
	const z = plugin.external("zod.z");
	const { literalMembers } = itemsNode$2({
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$11,
			items: itemsNode$2,
			nullable: nullableNode$2
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast: {},
			state
		}
	});
	if (!literalMembers.length) return unknownToAst$2({
		plugin,
		schema: { type: "unknown" },
		state
	});
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$11,
			items: itemsNode$2,
			nullable: nullableNode$2
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast: {},
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.enum;
	return { expression: resolver?.(ctx$1) ?? enumResolver$2(ctx$1) };
};

//#endregion
//#region src/plugins/zod/mini/toAst/never.ts
const neverToAst$2 = ({ plugin }) => {
	const z = plugin.external("zod.z");
	const result = {};
	result.expression = $(z).attr(identifiers.never).call();
	return result;
};

//#endregion
//#region src/plugins/zod/mini/toAst/null.ts
const nullToAst$2 = ({ plugin }) => {
	const z = plugin.external("zod.z");
	const result = {};
	result.expression = $(z).attr(identifiers.null).call();
	return result;
};

//#endregion
//#region src/plugins/zod/mini/toAst/number.ts
function baseNode$10(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (ctx$1.utils.shouldCoerceToBigInt(schema.format)) return $(z).attr(identifiers.coerce).attr(identifiers.bigint).call();
	let chain = $(z).attr(identifiers.number).call();
	if (schema.type === "integer") chain = $(z).attr(identifiers.int).call();
	return chain;
}
function constNode$5(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (schema.const === void 0) return;
	return $(z).attr(identifiers.literal).call(ctx$1.utils.maybeBigInt(schema.const, schema.format));
}
function maxNode$2(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (schema.exclusiveMaximum !== void 0) return $(z).attr(identifiers.lt).call(ctx$1.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));
	if (schema.maximum !== void 0) return $(z).attr(identifiers.lte).call(ctx$1.utils.maybeBigInt(schema.maximum, schema.format));
	const limit = ctx$1.utils.getIntegerLimit(schema.format);
	if (limit) return $(z).attr(identifiers.maximum).call(ctx$1.utils.maybeBigInt(limit.maxValue, schema.format), $.object().prop("error", $.literal(limit.maxError)));
}
function minNode$2(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (schema.exclusiveMinimum !== void 0) return $(z).attr(identifiers.gt).call(ctx$1.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));
	if (schema.minimum !== void 0) return $(z).attr(identifiers.gte).call(ctx$1.utils.maybeBigInt(schema.minimum, schema.format));
	const limit = ctx$1.utils.getIntegerLimit(schema.format);
	if (limit) return $(z).attr(identifiers.minimum).call(ctx$1.utils.maybeBigInt(limit.minValue, schema.format), $.object().prop("error", $.literal(limit.minError)));
}
function numberResolver$2(ctx$1) {
	const constNode$8 = ctx$1.nodes.const(ctx$1);
	if (constNode$8) {
		ctx$1.chain.current = constNode$8;
		return ctx$1.chain.current;
	}
	const baseNode$16 = ctx$1.nodes.base(ctx$1);
	if (baseNode$16) ctx$1.chain.current = baseNode$16;
	const checks = [];
	const minNode$4 = ctx$1.nodes.min(ctx$1);
	if (minNode$4) checks.push(minNode$4);
	const maxNode$4 = ctx$1.nodes.max(ctx$1);
	if (maxNode$4) checks.push(maxNode$4);
	if (checks.length > 0) ctx$1.chain.current = ctx$1.chain.current.attr(identifiers.check).call(...checks);
	return ctx$1.chain.current;
}
const numberToNode$2 = ({ plugin, schema, state }) => {
	const ast = {};
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$10,
			const: constNode$5,
			max: maxNode$2,
			min: minNode$2
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast,
			getIntegerLimit,
			maybeBigInt,
			shouldCoerceToBigInt,
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.number;
	ast.expression = resolver?.(ctx$1) ?? numberResolver$2(ctx$1);
	return ast;
};

//#endregion
//#region src/plugins/zod/mini/toAst/object.ts
function additionalPropertiesNode$2(ctx$1) {
	const { plugin, schema } = ctx$1;
	if (!schema.additionalProperties || schema.properties && Object.keys(schema.properties).length > 0) return;
	const additionalAst = irSchemaToAst$2({
		plugin,
		schema: schema.additionalProperties,
		state: {
			...ctx$1.utils.state,
			path: (0, _hey_api_codegen_core.ref)([...(0, _hey_api_codegen_core.fromRef)(ctx$1.utils.state.path), "additionalProperties"])
		}
	});
	if (additionalAst.hasLazyExpression) ctx$1.utils.ast.hasLazyExpression = true;
	return additionalAst.expression;
}
function baseNode$9(ctx$1) {
	const { nodes, symbols } = ctx$1;
	const { z } = symbols;
	const additional = nodes.additionalProperties(ctx$1);
	const shape = nodes.shape(ctx$1);
	if (additional) return $(z).attr(identifiers.record).call($(z).attr(identifiers.string).call(), additional);
	return $(z).attr(identifiers.object).call(shape);
}
function objectResolver$2(ctx$1) {
	return ctx$1.nodes.base(ctx$1);
}
function shapeNode$2(ctx$1) {
	const { plugin, schema } = ctx$1;
	const shape = $.object().pretty();
	for (const name in schema.properties) {
		const property = schema.properties[name];
		const propertyAst = irSchemaToAst$2({
			optional: !schema.required?.includes(name),
			plugin,
			schema: property,
			state: {
				...ctx$1.utils.state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(ctx$1.utils.state.path),
					"properties",
					name
				])
			}
		});
		if (propertyAst.hasLazyExpression) {
			ctx$1.utils.ast.hasLazyExpression = true;
			shape.getter(name, propertyAst.expression.return());
		} else shape.prop(name, propertyAst.expression);
	}
	return shape;
}
const objectToAst$2 = ({ plugin, schema, state }) => {
	const ast = {};
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			additionalProperties: additionalPropertiesNode$2,
			base: baseNode$9,
			shape: shapeNode$2
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast,
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.object;
	ast.expression = resolver?.(ctx$1) ?? objectResolver$2(ctx$1);
	return ast;
};

//#endregion
//#region src/plugins/zod/mini/toAst/string.ts
function baseNode$8(ctx$1) {
	const { z } = ctx$1.symbols;
	return $(z).attr(identifiers.string).call();
}
function constNode$4(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (typeof schema.const !== "string") return;
	return $(z).attr(identifiers.literal).call($.literal(schema.const));
}
function formatNode$2(ctx$1) {
	const { plugin, schema, symbols } = ctx$1;
	const { z } = symbols;
	switch (schema.format) {
		case "date": return $(z).attr(identifiers.iso).attr(identifiers.date).call();
		case "date-time": {
			const obj = $.object().$if(plugin.config.dates.offset, (o) => o.prop("offset", $.literal(true))).$if(plugin.config.dates.local, (o) => o.prop("local", $.literal(true)));
			return $(z).attr(identifiers.iso).attr(identifiers.datetime).call(obj.hasProps() ? obj : void 0);
		}
		case "email": return $(z).attr(identifiers.email).call();
		case "ipv4": return $(z).attr(identifiers.ipv4).call();
		case "ipv6": return $(z).attr(identifiers.ipv6).call();
		case "time": return $(z).attr(identifiers.iso).attr(identifiers.time).call();
		case "uri": return $(z).attr(identifiers.url).call();
		case "uuid": return $(z).attr(identifiers.uuid).call();
	}
}
function lengthNode$2(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (schema.minLength === void 0 || schema.minLength !== schema.maxLength) return;
	return $(z).attr(identifiers.length).call($.literal(schema.minLength));
}
function maxLengthNode$2(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (schema.maxLength === void 0) return;
	return $(z).attr(identifiers.maxLength).call($.literal(schema.maxLength));
}
function minLengthNode$2(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (schema.minLength === void 0) return;
	return $(z).attr(identifiers.minLength).call($.literal(schema.minLength));
}
function patternNode$2(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (!schema.pattern) return;
	return $(z).attr(identifiers.regex).call($.regexp(schema.pattern));
}
function stringResolver$2(ctx$1) {
	const constNode$8 = ctx$1.nodes.const(ctx$1);
	if (constNode$8) {
		ctx$1.chain.current = constNode$8;
		return ctx$1.chain.current;
	}
	const baseNode$16 = ctx$1.nodes.base(ctx$1);
	if (baseNode$16) ctx$1.chain.current = baseNode$16;
	const formatNode$4 = ctx$1.nodes.format(ctx$1);
	if (formatNode$4) ctx$1.chain.current = formatNode$4;
	const checks = [];
	const lengthNode$4 = ctx$1.nodes.length(ctx$1);
	if (lengthNode$4) checks.push(lengthNode$4);
	else {
		const minLengthNode$4 = ctx$1.nodes.minLength(ctx$1);
		if (minLengthNode$4) checks.push(minLengthNode$4);
		const maxLengthNode$4 = ctx$1.nodes.maxLength(ctx$1);
		if (maxLengthNode$4) checks.push(maxLengthNode$4);
	}
	const patternNode$4 = ctx$1.nodes.pattern(ctx$1);
	if (patternNode$4) checks.push(patternNode$4);
	if (checks.length > 0) ctx$1.chain.current = ctx$1.chain.current.attr(identifiers.check).call(...checks);
	return ctx$1.chain.current;
}
const stringToNode$2 = ({ plugin, schema }) => {
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$8,
			const: constNode$4,
			format: formatNode$2,
			length: lengthNode$2,
			maxLength: maxLengthNode$2,
			minLength: minLengthNode$2,
			pattern: patternNode$2
		},
		plugin,
		schema,
		symbols: { z }
	};
	const resolver = plugin.config["~resolvers"]?.string;
	return { expression: resolver?.(ctx$1) ?? stringResolver$2(ctx$1) };
};

//#endregion
//#region src/plugins/zod/mini/toAst/tuple.ts
const tupleToAst$2 = ({ plugin, schema, state }) => {
	const z = plugin.external("zod.z");
	const result = {};
	if (schema.const && Array.isArray(schema.const)) {
		const tupleElements$1 = schema.const.map((value) => $(z).attr(identifiers.literal).call($.fromValue(value)));
		result.expression = $(z).attr(identifiers.tuple).call($.array(...tupleElements$1));
		return result;
	}
	const tupleElements = [];
	if (schema.items) schema.items.forEach((item, index) => {
		const itemSchema = irSchemaToAst$2({
			plugin,
			schema: item,
			state: {
				...state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(state.path),
					"items",
					index
				])
			}
		});
		tupleElements.push(itemSchema.expression);
		if (itemSchema.hasLazyExpression) result.hasLazyExpression = true;
	});
	result.expression = $(z).attr(identifiers.tuple).call($.array(...tupleElements));
	return result;
};

//#endregion
//#region src/plugins/zod/mini/toAst/undefined.ts
const undefinedToAst$2 = ({ plugin }) => {
	const z = plugin.external("zod.z");
	const result = {};
	result.expression = $(z).attr(identifiers.undefined).call();
	return result;
};

//#endregion
//#region src/plugins/zod/mini/toAst/void.ts
const voidToAst$2 = ({ plugin }) => {
	const z = plugin.external("zod.z");
	const result = {};
	result.expression = $(z).attr(identifiers.void).call();
	return result;
};

//#endregion
//#region src/plugins/zod/mini/toAst/index.ts
const irSchemaWithTypeToAst$2 = ({ schema, ...args }) => {
	switch (schema.type) {
		case "array": return arrayToAst$2({
			...args,
			schema
		});
		case "boolean": return booleanToAst$2({
			...args,
			schema
		});
		case "enum": return enumToAst$2({
			...args,
			schema
		});
		case "integer":
		case "number": return numberToNode$2({
			...args,
			schema
		});
		case "never": return neverToAst$2({
			...args,
			schema
		});
		case "null": return nullToAst$2({
			...args,
			schema
		});
		case "object": return objectToAst$2({
			...args,
			schema
		});
		case "string": return shouldCoerceToBigInt(schema.format) ? numberToNode$2({
			...args,
			schema: {
				...schema,
				type: "number"
			}
		}) : stringToNode$2({
			...args,
			schema
		});
		case "tuple": return tupleToAst$2({
			...args,
			schema
		});
		case "undefined": return undefinedToAst$2({
			...args,
			schema
		});
		case "unknown": return unknownToAst$2({
			...args,
			schema
		});
		case "void": return voidToAst$2({
			...args,
			schema
		});
	}
};

//#endregion
//#region src/plugins/zod/mini/plugin.ts
const irSchemaToAst$2 = ({ optional, plugin, schema, state }) => {
	let ast = {};
	const z = plugin.external("zod.z");
	if (schema.$ref) {
		const query = {
			category: "schema",
			resource: "definition",
			resourceId: schema.$ref,
			tool: "zod"
		};
		const refSymbol = plugin.referenceSymbol(query);
		if (plugin.isSymbolRegistered(query)) ast.expression = $(refSymbol);
		else {
			ast.expression = $(z).attr(identifiers.lazy).call($.func().returns("any").do($(refSymbol).return()));
			ast.hasLazyExpression = true;
			state.hasLazyExpression["~ref"] = true;
		}
	} else if (schema.type) {
		const typeAst = irSchemaWithTypeToAst$2({
			plugin,
			schema,
			state
		});
		ast.expression = typeAst.expression;
		ast.hasLazyExpression = typeAst.hasLazyExpression;
		if (plugin.config.metadata && schema.description) ast.expression = ast.expression.attr(identifiers.register).call($(z).attr(identifiers.globalRegistry), $.object().pretty().prop("description", $.literal(schema.description)));
	} else if (schema.items) {
		schema = deduplicateSchema({ schema });
		if (schema.items) {
			const itemSchemas = schema.items.map((item, index) => irSchemaToAst$2({
				plugin,
				schema: item,
				state: {
					...state,
					path: (0, _hey_api_codegen_core.ref)([
						...(0, _hey_api_codegen_core.fromRef)(state.path),
						"items",
						index
					])
				}
			}));
			if (schema.logicalOperator === "and") {
				const firstSchema = schema.items[0];
				if (firstSchema.logicalOperator === "or" || firstSchema.type && firstSchema.type !== "object") ast.expression = $(z).attr(identifiers.intersection).call(...itemSchemas.map((schema$1) => schema$1.expression));
				else {
					ast.expression = itemSchemas[0].expression;
					itemSchemas.slice(1).forEach((schema$1) => {
						ast.expression = $(z).attr(identifiers.intersection).call(ast.expression, schema$1.hasLazyExpression ? $(z).attr(identifiers.lazy).call($.func().do(schema$1.expression.return())) : schema$1.expression);
					});
				}
			} else ast.expression = $(z).attr(identifiers.union).call($.array().pretty().elements(...itemSchemas.map((schema$1) => schema$1.expression)));
		} else ast = irSchemaToAst$2({
			plugin,
			schema,
			state
		});
	} else {
		const typeAst = irSchemaWithTypeToAst$2({
			plugin,
			schema: { type: "unknown" },
			state
		});
		ast.expression = typeAst.expression;
	}
	if (ast.expression) {
		if (schema.accessScope === "read") ast.expression = $(z).attr(identifiers.readonly).call(ast.expression);
		if (optional) {
			ast.expression = $(z).attr(identifiers.optional).call(ast.expression);
			ast.typeName = identifiers.ZodMiniOptional;
		}
		if (schema.default !== void 0) ast.expression = $(z).attr(identifiers._default).call(ast.expression, schema.type === "integer" || schema.type === "number" ? maybeBigInt(schema.default, schema.format) : $.fromValue(schema.default));
	}
	return ast;
};
const handleComponent$2 = ({ plugin, schema, state }) => {
	const $ref = pathToJsonPointer((0, _hey_api_codegen_core.fromRef)(state.path));
	const ast = irSchemaToAst$2({
		plugin,
		schema,
		state
	});
	const baseName = refToName($ref);
	exportAst({
		ast,
		plugin,
		schema,
		symbol: plugin.symbol(applyNaming(baseName, plugin.config.definitions), { meta: {
			category: "schema",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "definition",
			resourceId: $ref,
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "zod"
		} }),
		typeInferSymbol: plugin.config.definitions.types.infer.enabled ? plugin.symbol(applyNaming(baseName, plugin.config.definitions.types.infer), { meta: {
			category: "type",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "definition",
			resourceId: $ref,
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "zod",
			variant: "infer"
		} }) : void 0
	});
};
const handlerMini = ({ plugin }) => {
	plugin.symbol("z", {
		external: getZodModule({ plugin }),
		importKind: "namespace",
		meta: {
			category: "external",
			resource: "zod.z"
		}
	});
	plugin.forEach("operation", "parameter", "requestBody", "schema", "webhook", (event) => {
		const state = (0, _hey_api_codegen_core.refs)({
			hasLazyExpression: false,
			path: event._path,
			tags: event.tags
		});
		switch (event.type) {
			case "operation":
				irOperationToAst({
					getAst: (schema, path$10) => {
						return irSchemaToAst$2({
							plugin,
							schema,
							state: (0, _hey_api_codegen_core.refs)({
								hasLazyExpression: false,
								path: path$10,
								tags: event.tags
							})
						});
					},
					operation: event.operation,
					plugin,
					state
				});
				break;
			case "parameter":
				handleComponent$2({
					plugin,
					schema: event.parameter.schema,
					state
				});
				break;
			case "requestBody":
				handleComponent$2({
					plugin,
					schema: event.requestBody.schema,
					state
				});
				break;
			case "schema":
				handleComponent$2({
					plugin,
					schema: event.schema,
					state
				});
				break;
			case "webhook":
				irWebhookToAst({
					getAst: (schema, path$10) => {
						return irSchemaToAst$2({
							plugin,
							schema,
							state: (0, _hey_api_codegen_core.refs)({
								hasLazyExpression: false,
								path: path$10,
								tags: event.tags
							})
						});
					},
					operation: event.operation,
					plugin,
					state
				});
				break;
		}
	});
};

//#endregion
//#region src/plugins/zod/v3/toAst/unknown.ts
const unknownToAst$1 = ({ plugin }) => {
	return $(plugin.external("zod.z")).attr(identifiers.unknown).call();
};

//#endregion
//#region src/plugins/zod/v3/toAst/array.ts
const arrayToAst$1 = ({ plugin, schema, state }) => {
	const z = plugin.external("zod.z");
	const functionName = $(z).attr(identifiers.array);
	let arrayExpression;
	let hasLazyExpression = false;
	if (!schema.items) arrayExpression = functionName.call(unknownToAst$1({
		plugin,
		schema: { type: "unknown" },
		state
	}));
	else {
		schema = deduplicateSchema({ schema });
		const itemExpressions = schema.items.map((item, index) => {
			const itemAst = irSchemaToAst$1({
				plugin,
				schema: item,
				state: {
					...state,
					path: (0, _hey_api_codegen_core.ref)([
						...(0, _hey_api_codegen_core.fromRef)(state.path),
						"items",
						index
					])
				}
			});
			if (itemAst.hasLazyExpression) hasLazyExpression = true;
			return itemAst.expression;
		});
		if (itemExpressions.length === 1) arrayExpression = functionName.call(...itemExpressions);
		else if (schema.logicalOperator === "and") {
			const firstSchema = schema.items[0];
			let intersectionExpression;
			if (firstSchema.logicalOperator === "or" || firstSchema.type && firstSchema.type !== "object") intersectionExpression = $(z).attr(identifiers.intersection).call(...itemExpressions);
			else {
				intersectionExpression = itemExpressions[0];
				for (let i = 1; i < itemExpressions.length; i++) intersectionExpression = intersectionExpression.attr(identifiers.and).call(itemExpressions[i]);
			}
			arrayExpression = functionName.call(intersectionExpression);
		} else arrayExpression = $(z).attr(identifiers.array).call($(z).attr(identifiers.union).call($.array(...itemExpressions)));
	}
	if (schema.minItems === schema.maxItems && schema.minItems !== void 0) arrayExpression = arrayExpression.attr(identifiers.length).call($.fromValue(schema.minItems));
	else {
		if (schema.minItems !== void 0) arrayExpression = arrayExpression.attr(identifiers.min).call($.fromValue(schema.minItems));
		if (schema.maxItems !== void 0) arrayExpression = arrayExpression.attr(identifiers.max).call($.fromValue(schema.maxItems));
	}
	return {
		expression: arrayExpression,
		hasLazyExpression
	};
};

//#endregion
//#region src/plugins/zod/v3/toAst/boolean.ts
const booleanToAst$1 = ({ plugin, schema }) => {
	let chain;
	const z = plugin.external("zod.z");
	if (typeof schema.const === "boolean") {
		chain = $(z).attr(identifiers.literal).call($.literal(schema.const));
		return chain;
	}
	chain = $(z).attr(identifiers.boolean).call();
	return chain;
};

//#endregion
//#region src/plugins/zod/v3/toAst/enum.ts
function itemsNode$1(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	const enumMembers = [];
	const literalMembers = [];
	let isNullable = false;
	let allStrings = true;
	for (const item of schema.items ?? []) if (item.type === "string" && typeof item.const === "string") {
		const literal = $.literal(item.const);
		enumMembers.push(literal);
		literalMembers.push($(z).attr(identifiers.literal).call(literal));
	} else if ((item.type === "number" || item.type === "integer") && typeof item.const === "number") {
		allStrings = false;
		const literal = $.literal(item.const);
		literalMembers.push($(z).attr(identifiers.literal).call(literal));
	} else if (item.type === "boolean" && typeof item.const === "boolean") {
		allStrings = false;
		const literal = $.literal(item.const);
		literalMembers.push($(z).attr(identifiers.literal).call(literal));
	} else if (item.type === "null" || item.const === null) isNullable = true;
	return {
		allStrings,
		enumMembers,
		isNullable,
		literalMembers
	};
}
function baseNode$7(ctx$1) {
	const { symbols } = ctx$1;
	const { z } = symbols;
	const { allStrings, enumMembers, literalMembers } = ctx$1.nodes.items(ctx$1);
	if (allStrings && enumMembers.length > 0) return $(z).attr(identifiers.enum).call($.array(...enumMembers));
	else if (literalMembers.length === 1) return literalMembers[0];
	else return $(z).attr(identifiers.union).call($.array(...literalMembers));
}
function nullableNode$1(ctx$1) {
	const { chain } = ctx$1;
	const { isNullable } = ctx$1.nodes.items(ctx$1);
	if (!isNullable) return;
	return chain.current.attr(identifiers.nullable).call();
}
function enumResolver$1(ctx$1) {
	const { literalMembers } = ctx$1.nodes.items(ctx$1);
	if (!literalMembers.length) return ctx$1.chain.current;
	const baseExpression = ctx$1.nodes.base(ctx$1);
	ctx$1.chain.current = baseExpression;
	const nullableExpression = ctx$1.nodes.nullable(ctx$1);
	if (nullableExpression) ctx$1.chain.current = nullableExpression;
	return ctx$1.chain.current;
}
const enumToAst$1 = ({ plugin, schema, state }) => {
	const z = plugin.external("zod.z");
	const { literalMembers } = itemsNode$1({
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$7,
			items: itemsNode$1,
			nullable: nullableNode$1
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast: {},
			state
		}
	});
	if (!literalMembers.length) return unknownToAst$1({
		plugin,
		schema: { type: "unknown" },
		state
	});
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$7,
			items: itemsNode$1,
			nullable: nullableNode$1
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast: {},
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.enum;
	return resolver?.(ctx$1) ?? enumResolver$1(ctx$1);
};

//#endregion
//#region src/plugins/zod/v3/toAst/never.ts
const neverToAst$1 = ({ plugin }) => {
	return $(plugin.external("zod.z")).attr(identifiers.never).call();
};

//#endregion
//#region src/plugins/zod/v3/toAst/null.ts
const nullToAst$1 = ({ plugin }) => {
	return $(plugin.external("zod.z")).attr(identifiers.null).call();
};

//#endregion
//#region src/plugins/zod/v3/toAst/number.ts
function baseNode$6(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (ctx$1.utils.shouldCoerceToBigInt(schema.format)) return $(z).attr(identifiers.coerce).attr(identifiers.bigint).call();
	let chain = $(z).attr(identifiers.number).call();
	if (schema.type === "integer") chain = chain.attr(identifiers.int).call();
	return chain;
}
function constNode$3(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (schema.const === void 0) return;
	return $(z).attr(identifiers.literal).call(ctx$1.utils.maybeBigInt(schema.const, schema.format));
}
function maxNode$1(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.exclusiveMaximum !== void 0) return chain.current.attr(identifiers.lt).call(ctx$1.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));
	if (schema.maximum !== void 0) return chain.current.attr(identifiers.lte).call(ctx$1.utils.maybeBigInt(schema.maximum, schema.format));
	const limit = ctx$1.utils.getIntegerLimit(schema.format);
	if (limit) return chain.current.attr(identifiers.max).call(ctx$1.utils.maybeBigInt(limit.maxValue, schema.format), $.object().prop("message", $.literal(limit.maxError)));
}
function minNode$1(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.exclusiveMinimum !== void 0) return chain.current.attr(identifiers.gt).call(ctx$1.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));
	if (schema.minimum !== void 0) return chain.current.attr(identifiers.gte).call(ctx$1.utils.maybeBigInt(schema.minimum, schema.format));
	const limit = ctx$1.utils.getIntegerLimit(schema.format);
	if (limit) return chain.current.attr(identifiers.min).call(ctx$1.utils.maybeBigInt(limit.minValue, schema.format), $.object().prop("message", $.literal(limit.minError)));
}
function numberResolver$1(ctx$1) {
	const constNode$8 = ctx$1.nodes.const(ctx$1);
	if (constNode$8) {
		ctx$1.chain.current = constNode$8;
		return ctx$1.chain.current;
	}
	const baseNode$16 = ctx$1.nodes.base(ctx$1);
	if (baseNode$16) ctx$1.chain.current = baseNode$16;
	const minNode$4 = ctx$1.nodes.min(ctx$1);
	if (minNode$4) ctx$1.chain.current = minNode$4;
	const maxNode$4 = ctx$1.nodes.max(ctx$1);
	if (maxNode$4) ctx$1.chain.current = maxNode$4;
	return ctx$1.chain.current;
}
const numberToNode$1 = ({ plugin, schema, state }) => {
	const ast = {};
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$6,
			const: constNode$3,
			max: maxNode$1,
			min: minNode$1
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast,
			getIntegerLimit,
			maybeBigInt,
			shouldCoerceToBigInt,
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.number;
	return resolver?.(ctx$1) ?? numberResolver$1(ctx$1);
};

//#endregion
//#region src/plugins/zod/v3/toAst/object.ts
function additionalPropertiesNode$1(ctx$1) {
	const { plugin, schema } = ctx$1;
	if (!schema.additionalProperties || schema.properties && Object.keys(schema.properties).length > 0) return;
	const additionalAst = irSchemaToAst$1({
		plugin,
		schema: schema.additionalProperties,
		state: {
			...ctx$1.utils.state,
			path: (0, _hey_api_codegen_core.ref)([...(0, _hey_api_codegen_core.fromRef)(ctx$1.utils.state.path), "additionalProperties"])
		}
	});
	if (additionalAst.hasLazyExpression) ctx$1.utils.ast.hasLazyExpression = true;
	return additionalAst.expression;
}
function baseNode$5(ctx$1) {
	const { nodes, symbols } = ctx$1;
	const { z } = symbols;
	const additional = nodes.additionalProperties(ctx$1);
	const shape = nodes.shape(ctx$1);
	if (additional) return $(z).attr(identifiers.record).call(additional);
	return $(z).attr(identifiers.object).call(shape);
}
function objectResolver$1(ctx$1) {
	return ctx$1.nodes.base(ctx$1);
}
function shapeNode$1(ctx$1) {
	const { plugin, schema } = ctx$1;
	const shape = $.object().pretty();
	for (const name in schema.properties) {
		const property = schema.properties[name];
		const propertyAst = irSchemaToAst$1({
			optional: !schema.required?.includes(name),
			plugin,
			schema: property,
			state: {
				...ctx$1.utils.state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(ctx$1.utils.state.path),
					"properties",
					name
				])
			}
		});
		if (propertyAst.hasLazyExpression) ctx$1.utils.ast.hasLazyExpression = true;
		shape.prop(name, propertyAst.expression);
	}
	return shape;
}
const objectToAst$1 = ({ plugin, schema, state }) => {
	const ast = {};
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			additionalProperties: additionalPropertiesNode$1,
			base: baseNode$5,
			shape: shapeNode$1
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast,
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.object;
	ast.expression = resolver?.(ctx$1) ?? objectResolver$1(ctx$1);
	return {
		...ast,
		anyType: "AnyZodObject"
	};
};

//#endregion
//#region src/plugins/zod/v3/toAst/string.ts
function baseNode$4(ctx$1) {
	const { z } = ctx$1.symbols;
	return $(z).attr(identifiers.string).call();
}
function constNode$2(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (typeof schema.const !== "string") return;
	return $(z).attr(identifiers.literal).call($.literal(schema.const));
}
function formatNode$1(ctx$1) {
	const { chain, plugin, schema } = ctx$1;
	switch (schema.format) {
		case "date": return chain.current.attr(identifiers.date).call();
		case "date-time": {
			const obj = $.object().$if(plugin.config.dates.offset, (o) => o.prop("offset", $.literal(true))).$if(plugin.config.dates.local, (o) => o.prop("local", $.literal(true)));
			return chain.current.attr(identifiers.datetime).call(obj.hasProps() ? obj : void 0);
		}
		case "email": return chain.current.attr(identifiers.email).call();
		case "ipv4":
		case "ipv6": return chain.current.attr(identifiers.ip).call();
		case "time": return chain.current.attr(identifiers.time).call();
		case "uri": return chain.current.attr(identifiers.url).call();
		case "uuid": return chain.current.attr(identifiers.uuid).call();
	}
}
function lengthNode$1(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.minLength === void 0 || schema.minLength !== schema.maxLength) return;
	return chain.current.attr(identifiers.length).call($.literal(schema.minLength));
}
function maxLengthNode$1(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.maxLength === void 0) return;
	return chain.current.attr(identifiers.max).call($.literal(schema.maxLength));
}
function minLengthNode$1(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.minLength === void 0) return;
	return chain.current.attr(identifiers.min).call($.literal(schema.minLength));
}
function patternNode$1(ctx$1) {
	const { chain, schema } = ctx$1;
	if (!schema.pattern) return;
	return chain.current.attr(identifiers.regex).call($.regexp(schema.pattern));
}
function stringResolver$1(ctx$1) {
	const constNode$8 = ctx$1.nodes.const(ctx$1);
	if (constNode$8) {
		ctx$1.chain.current = constNode$8;
		return ctx$1.chain.current;
	}
	const baseNode$16 = ctx$1.nodes.base(ctx$1);
	if (baseNode$16) ctx$1.chain.current = baseNode$16;
	const formatNode$4 = ctx$1.nodes.format(ctx$1);
	if (formatNode$4) ctx$1.chain.current = formatNode$4;
	const lengthNode$4 = ctx$1.nodes.length(ctx$1);
	if (lengthNode$4) ctx$1.chain.current = lengthNode$4;
	else {
		const minLengthNode$4 = ctx$1.nodes.minLength(ctx$1);
		if (minLengthNode$4) ctx$1.chain.current = minLengthNode$4;
		const maxLengthNode$4 = ctx$1.nodes.maxLength(ctx$1);
		if (maxLengthNode$4) ctx$1.chain.current = maxLengthNode$4;
	}
	const patternNode$4 = ctx$1.nodes.pattern(ctx$1);
	if (patternNode$4) ctx$1.chain.current = patternNode$4;
	return ctx$1.chain.current;
}
const stringToNode$1 = ({ plugin, schema }) => {
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$4,
			const: constNode$2,
			format: formatNode$1,
			length: lengthNode$1,
			maxLength: maxLengthNode$1,
			minLength: minLengthNode$1,
			pattern: patternNode$1
		},
		plugin,
		schema,
		symbols: { z }
	};
	const resolver = plugin.config["~resolvers"]?.string;
	return resolver?.(ctx$1) ?? stringResolver$1(ctx$1);
};

//#endregion
//#region src/plugins/zod/v3/toAst/tuple.ts
const tupleToAst$1 = ({ plugin, schema, state }) => {
	const z = plugin.external("zod.z");
	let hasLazyExpression = false;
	if (schema.const && Array.isArray(schema.const)) {
		const tupleElements$1 = schema.const.map((value) => $(z).attr(identifiers.literal).call($.fromValue(value)));
		return {
			expression: $(z).attr(identifiers.tuple).call($.array(...tupleElements$1)),
			hasLazyExpression
		};
	}
	const tupleElements = [];
	if (schema.items) schema.items.forEach((item, index) => {
		const itemSchema = irSchemaToAst$1({
			plugin,
			schema: item,
			state: {
				...state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(state.path),
					"items",
					index
				])
			}
		});
		tupleElements.push(itemSchema.expression);
		if (itemSchema.hasLazyExpression) hasLazyExpression = true;
	});
	return {
		expression: $(z).attr(identifiers.tuple).call($.array(...tupleElements)),
		hasLazyExpression
	};
};

//#endregion
//#region src/plugins/zod/v3/toAst/undefined.ts
const undefinedToAst$1 = ({ plugin }) => {
	return $(plugin.external("zod.z")).attr(identifiers.undefined).call();
};

//#endregion
//#region src/plugins/zod/v3/toAst/void.ts
const voidToAst$1 = ({ plugin }) => {
	return $(plugin.external("zod.z")).attr(identifiers.void).call();
};

//#endregion
//#region src/plugins/zod/v3/toAst/index.ts
const irSchemaWithTypeToAst$1 = ({ schema, ...args }) => {
	switch (schema.type) {
		case "array": return arrayToAst$1({
			...args,
			schema
		});
		case "boolean": return { expression: booleanToAst$1({
			...args,
			schema
		}) };
		case "enum": return { expression: enumToAst$1({
			...args,
			schema
		}) };
		case "integer":
		case "number": return { expression: numberToNode$1({
			...args,
			schema
		}) };
		case "never": return { expression: neverToAst$1({
			...args,
			schema
		}) };
		case "null": return { expression: nullToAst$1({
			...args,
			schema
		}) };
		case "object": return objectToAst$1({
			...args,
			schema
		});
		case "string": return { expression: shouldCoerceToBigInt(schema.format) ? numberToNode$1({
			...args,
			schema: {
				...schema,
				type: "number"
			}
		}) : stringToNode$1({
			...args,
			schema
		}) };
		case "tuple": return tupleToAst$1({
			...args,
			schema
		});
		case "undefined": return { expression: undefinedToAst$1({
			...args,
			schema
		}) };
		case "unknown": return { expression: unknownToAst$1({
			...args,
			schema
		}) };
		case "void": return { expression: voidToAst$1({
			...args,
			schema
		}) };
	}
};

//#endregion
//#region src/plugins/zod/v3/plugin.ts
const irSchemaToAst$1 = ({ optional, plugin, schema, state }) => {
	let ast = {};
	const z = plugin.external("zod.z");
	if (schema.$ref) {
		const query = {
			category: "schema",
			resource: "definition",
			resourceId: schema.$ref,
			tool: "zod"
		};
		const refSymbol = plugin.referenceSymbol(query);
		if (plugin.isSymbolRegistered(query)) ast.expression = $(refSymbol);
		else {
			ast.expression = $(z).attr(identifiers.lazy).call($.func().do($(refSymbol).return()));
			ast.hasLazyExpression = true;
			state.hasLazyExpression["~ref"] = true;
		}
	} else if (schema.type) {
		const typeAst = irSchemaWithTypeToAst$1({
			plugin,
			schema,
			state
		});
		ast.expression = typeAst.expression;
		ast.typeName = typeAst.anyType;
		if (plugin.config.metadata && schema.description) ast.expression = ast.expression.attr(identifiers.describe).call($.literal(schema.description));
	} else if (schema.items) {
		schema = deduplicateSchema({ schema });
		if (schema.items) {
			const itemTypes = schema.items.map((item, index) => {
				return irSchemaToAst$1({
					plugin,
					schema: item,
					state: {
						...state,
						path: (0, _hey_api_codegen_core.ref)([
							...(0, _hey_api_codegen_core.fromRef)(state.path),
							"items",
							index
						])
					}
				}).expression;
			});
			if (schema.logicalOperator === "and") {
				const firstSchema = schema.items[0];
				if (firstSchema.logicalOperator === "or" || firstSchema.type && firstSchema.type !== "object") ast.expression = $(z).attr(identifiers.intersection).call(...itemTypes);
				else {
					ast.expression = itemTypes[0];
					itemTypes.slice(1).forEach((item) => {
						ast.expression = ast.expression.attr(identifiers.and).call(item);
					});
				}
			} else ast.expression = $(z).attr(identifiers.union).call($.array().pretty().elements(...itemTypes));
		} else ast = irSchemaToAst$1({
			plugin,
			schema,
			state
		});
	} else {
		const typeAst = irSchemaWithTypeToAst$1({
			plugin,
			schema: { type: "unknown" },
			state
		});
		ast.expression = typeAst.expression;
		ast.typeName = typeAst.anyType;
	}
	if (ast.expression) {
		if (schema.accessScope === "read") ast.expression = ast.expression.attr(identifiers.readonly).call();
		if (optional) ast.expression = ast.expression.attr(identifiers.optional).call();
		if (schema.default !== void 0) ast.expression = ast.expression.attr(identifiers.default).call(schema.type === "integer" || schema.type === "number" ? maybeBigInt(schema.default, schema.format) : $.fromValue(schema.default));
	}
	if (state.hasLazyExpression["~ref"]) {
		if (!ast.typeName) ast.typeName = "ZodTypeAny";
	} else if (ast.typeName) ast.typeName = void 0;
	return ast;
};
const handleComponent$1 = ({ plugin, schema, state }) => {
	const $ref = pathToJsonPointer((0, _hey_api_codegen_core.fromRef)(state.path));
	const ast = irSchemaToAst$1({
		plugin,
		schema,
		state
	});
	const baseName = refToName($ref);
	exportAst({
		ast,
		plugin,
		schema,
		symbol: plugin.symbol(applyNaming(baseName, plugin.config.definitions), { meta: {
			category: "schema",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "definition",
			resourceId: $ref,
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "zod"
		} }),
		typeInferSymbol: plugin.config.definitions.types.infer.enabled ? plugin.symbol(applyNaming(baseName, plugin.config.definitions.types.infer), { meta: {
			category: "type",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "definition",
			resourceId: $ref,
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "zod",
			variant: "infer"
		} }) : void 0
	});
};
const handlerV3 = ({ plugin }) => {
	plugin.symbol("z", {
		external: getZodModule({ plugin }),
		meta: {
			category: "external",
			resource: "zod.z"
		}
	});
	plugin.forEach("operation", "parameter", "requestBody", "schema", "webhook", (event) => {
		const state = (0, _hey_api_codegen_core.refs)({
			hasLazyExpression: false,
			path: event._path,
			tags: event.tags
		});
		switch (event.type) {
			case "operation":
				irOperationToAst({
					getAst: (schema, path$10) => {
						return irSchemaToAst$1({
							plugin,
							schema,
							state: (0, _hey_api_codegen_core.refs)({
								hasLazyExpression: false,
								path: path$10,
								tags: event.tags
							})
						});
					},
					operation: event.operation,
					plugin,
					state
				});
				break;
			case "parameter":
				handleComponent$1({
					plugin,
					schema: event.parameter.schema,
					state
				});
				break;
			case "requestBody":
				handleComponent$1({
					plugin,
					schema: event.requestBody.schema,
					state
				});
				break;
			case "schema":
				handleComponent$1({
					plugin,
					schema: event.schema,
					state
				});
				break;
			case "webhook":
				irWebhookToAst({
					getAst: (schema, path$10) => {
						return irSchemaToAst$1({
							plugin,
							schema,
							state: (0, _hey_api_codegen_core.refs)({
								hasLazyExpression: false,
								path: path$10,
								tags: event.tags
							})
						});
					},
					operation: event.operation,
					plugin,
					state
				});
				break;
		}
	});
};

//#endregion
//#region src/plugins/zod/v4/toAst/unknown.ts
const unknownToAst = ({ plugin }) => {
	const result = {};
	result.expression = $(plugin.external("zod.z")).attr(identifiers.unknown).call();
	return result;
};

//#endregion
//#region src/plugins/zod/v4/toAst/array.ts
const arrayToAst = ({ plugin, schema, state }) => {
	const result = {};
	const z = plugin.external("zod.z");
	const functionName = $(z).attr(identifiers.array);
	if (!schema.items) result.expression = functionName.call(unknownToAst({
		plugin,
		schema: { type: "unknown" },
		state
	}).expression);
	else {
		schema = deduplicateSchema({ schema });
		const itemExpressions = schema.items.map((item, index) => {
			const itemAst = irSchemaToAst({
				plugin,
				schema: item,
				state: {
					...state,
					path: (0, _hey_api_codegen_core.ref)([
						...(0, _hey_api_codegen_core.fromRef)(state.path),
						"items",
						index
					])
				}
			});
			if (itemAst.hasLazyExpression) result.hasLazyExpression = true;
			return itemAst.expression;
		});
		if (itemExpressions.length === 1) result.expression = functionName.call(...itemExpressions);
		else if (schema.logicalOperator === "and") {
			const firstSchema = schema.items[0];
			let intersectionExpression;
			if (firstSchema.logicalOperator === "or" || firstSchema.type && firstSchema.type !== "object") intersectionExpression = $(z).attr(identifiers.intersection).call(...itemExpressions);
			else {
				intersectionExpression = itemExpressions[0];
				for (let i = 1; i < itemExpressions.length; i++) intersectionExpression = intersectionExpression.attr(identifiers.and).call(itemExpressions[i]);
			}
			result.expression = functionName.call(intersectionExpression);
		} else result.expression = $(z).attr(identifiers.array).call($(z).attr(identifiers.union).call($.array(...itemExpressions)));
	}
	if (schema.minItems === schema.maxItems && schema.minItems !== void 0) result.expression = result.expression.attr(identifiers.length).call($.fromValue(schema.minItems));
	else {
		if (schema.minItems !== void 0) result.expression = result.expression.attr(identifiers.min).call($.fromValue(schema.minItems));
		if (schema.maxItems !== void 0) result.expression = result.expression.attr(identifiers.max).call($.fromValue(schema.maxItems));
	}
	return result;
};

//#endregion
//#region src/plugins/zod/v4/toAst/boolean.ts
const booleanToAst = ({ plugin, schema }) => {
	const result = {};
	let chain;
	const z = plugin.external("zod.z");
	if (typeof schema.const === "boolean") {
		chain = $(z).attr(identifiers.literal).call($.literal(schema.const));
		result.expression = chain;
		return result;
	}
	chain = $(z).attr(identifiers.boolean).call();
	result.expression = chain;
	return result;
};

//#endregion
//#region src/plugins/zod/v4/toAst/enum.ts
function itemsNode(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	const enumMembers = [];
	const literalMembers = [];
	let isNullable = false;
	let allStrings = true;
	for (const item of schema.items ?? []) if (item.type === "string" && typeof item.const === "string") {
		const literal = $.literal(item.const);
		enumMembers.push(literal);
		literalMembers.push($(z).attr(identifiers.literal).call(literal));
	} else if ((item.type === "number" || item.type === "integer") && typeof item.const === "number") {
		allStrings = false;
		const literal = $.literal(item.const);
		literalMembers.push($(z).attr(identifiers.literal).call(literal));
	} else if (item.type === "boolean" && typeof item.const === "boolean") {
		allStrings = false;
		const literal = $.literal(item.const);
		literalMembers.push($(z).attr(identifiers.literal).call(literal));
	} else if (item.type === "null" || item.const === null) isNullable = true;
	return {
		allStrings,
		enumMembers,
		isNullable,
		literalMembers
	};
}
function baseNode$3(ctx$1) {
	const { symbols } = ctx$1;
	const { z } = symbols;
	const { allStrings, enumMembers, literalMembers } = ctx$1.nodes.items(ctx$1);
	if (allStrings && enumMembers.length > 0) return $(z).attr(identifiers.enum).call($.array(...enumMembers));
	else if (literalMembers.length === 1) return literalMembers[0];
	else return $(z).attr(identifiers.union).call($.array(...literalMembers));
}
function nullableNode(ctx$1) {
	const { chain, symbols } = ctx$1;
	const { z } = symbols;
	const { isNullable } = ctx$1.nodes.items(ctx$1);
	if (!isNullable) return;
	return $(z).attr(identifiers.nullable).call(chain.current);
}
function enumResolver(ctx$1) {
	const { literalMembers } = ctx$1.nodes.items(ctx$1);
	if (!literalMembers.length) return ctx$1.chain.current;
	const baseExpression = ctx$1.nodes.base(ctx$1);
	ctx$1.chain.current = baseExpression;
	const nullableExpression = ctx$1.nodes.nullable(ctx$1);
	if (nullableExpression) ctx$1.chain.current = nullableExpression;
	return ctx$1.chain.current;
}
const enumToAst = ({ plugin, schema, state }) => {
	const z = plugin.external("zod.z");
	const { literalMembers } = itemsNode({
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$3,
			items: itemsNode,
			nullable: nullableNode
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast: {},
			state
		}
	});
	if (!literalMembers.length) return unknownToAst({
		plugin,
		schema: { type: "unknown" },
		state
	});
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$3,
			items: itemsNode,
			nullable: nullableNode
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast: {},
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.enum;
	return { expression: resolver?.(ctx$1) ?? enumResolver(ctx$1) };
};

//#endregion
//#region src/plugins/zod/v4/toAst/never.ts
const neverToAst = ({ plugin }) => {
	const result = {};
	result.expression = $(plugin.external("zod.z")).attr(identifiers.never).call();
	return result;
};

//#endregion
//#region src/plugins/zod/v4/toAst/null.ts
const nullToAst = ({ plugin }) => {
	const result = {};
	result.expression = $(plugin.external("zod.z")).attr(identifiers.null).call();
	return result;
};

//#endregion
//#region src/plugins/zod/v4/toAst/number.ts
function baseNode$2(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (ctx$1.utils.shouldCoerceToBigInt(schema.format)) return $(z).attr(identifiers.coerce).attr(identifiers.bigint).call();
	let chain = $(z).attr(identifiers.number).call();
	if (schema.type === "integer") chain = $(z).attr(identifiers.int).call();
	return chain;
}
function constNode$1(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (schema.const === void 0) return;
	return $(z).attr(identifiers.literal).call(ctx$1.utils.maybeBigInt(schema.const, schema.format));
}
function maxNode(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.exclusiveMaximum !== void 0) return chain.current.attr(identifiers.lt).call(ctx$1.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));
	if (schema.maximum !== void 0) return chain.current.attr(identifiers.lte).call(ctx$1.utils.maybeBigInt(schema.maximum, schema.format));
	const limit = ctx$1.utils.getIntegerLimit(schema.format);
	if (limit) return chain.current.attr(identifiers.max).call(ctx$1.utils.maybeBigInt(limit.maxValue, schema.format), $.object().prop("error", $.literal(limit.maxError)));
}
function minNode(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.exclusiveMinimum !== void 0) return chain.current.attr(identifiers.gt).call(ctx$1.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));
	if (schema.minimum !== void 0) return chain.current.attr(identifiers.gte).call(ctx$1.utils.maybeBigInt(schema.minimum, schema.format));
	const limit = ctx$1.utils.getIntegerLimit(schema.format);
	if (limit) return chain.current.attr(identifiers.min).call(ctx$1.utils.maybeBigInt(limit.minValue, schema.format), $.object().prop("error", $.literal(limit.minError)));
}
function numberResolver(ctx$1) {
	const constNode$8 = ctx$1.nodes.const(ctx$1);
	if (constNode$8) {
		ctx$1.chain.current = constNode$8;
		return ctx$1.chain.current;
	}
	const baseNode$16 = ctx$1.nodes.base(ctx$1);
	if (baseNode$16) ctx$1.chain.current = baseNode$16;
	const minNode$4 = ctx$1.nodes.min(ctx$1);
	if (minNode$4) ctx$1.chain.current = minNode$4;
	const maxNode$4 = ctx$1.nodes.max(ctx$1);
	if (maxNode$4) ctx$1.chain.current = maxNode$4;
	return ctx$1.chain.current;
}
const numberToNode = ({ plugin, schema, state }) => {
	const ast = {};
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode$2,
			const: constNode$1,
			max: maxNode,
			min: minNode
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast,
			getIntegerLimit,
			maybeBigInt,
			shouldCoerceToBigInt,
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.number;
	ast.expression = resolver?.(ctx$1) ?? numberResolver(ctx$1);
	return ast;
};

//#endregion
//#region src/plugins/zod/v4/toAst/object.ts
function additionalPropertiesNode(ctx$1) {
	const { plugin, schema } = ctx$1;
	if (!schema.additionalProperties || schema.properties && Object.keys(schema.properties).length > 0) return;
	const additionalAst = irSchemaToAst({
		plugin,
		schema: schema.additionalProperties,
		state: {
			...ctx$1.utils.state,
			path: (0, _hey_api_codegen_core.ref)([...(0, _hey_api_codegen_core.fromRef)(ctx$1.utils.state.path), "additionalProperties"])
		}
	});
	if (additionalAst.hasLazyExpression) ctx$1.utils.ast.hasLazyExpression = true;
	return additionalAst.expression;
}
function baseNode$1(ctx$1) {
	const { nodes, symbols } = ctx$1;
	const { z } = symbols;
	const additional = nodes.additionalProperties(ctx$1);
	const shape = nodes.shape(ctx$1);
	if (additional) return $(z).attr(identifiers.record).call($(z).attr(identifiers.string).call(), additional);
	return $(z).attr(identifiers.object).call(shape);
}
function objectResolver(ctx$1) {
	return ctx$1.nodes.base(ctx$1);
}
function shapeNode(ctx$1) {
	const { plugin, schema } = ctx$1;
	const shape = $.object().pretty();
	for (const name in schema.properties) {
		const property = schema.properties[name];
		const propertyAst = irSchemaToAst({
			optional: !schema.required?.includes(name),
			plugin,
			schema: property,
			state: {
				...ctx$1.utils.state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(ctx$1.utils.state.path),
					"properties",
					name
				])
			}
		});
		if (propertyAst.hasLazyExpression) {
			ctx$1.utils.ast.hasLazyExpression = true;
			shape.getter(name, propertyAst.expression.return());
		} else shape.prop(name, propertyAst.expression);
	}
	return shape;
}
const objectToAst = ({ plugin, schema, state }) => {
	const ast = {};
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			additionalProperties: additionalPropertiesNode,
			base: baseNode$1,
			shape: shapeNode
		},
		plugin,
		schema,
		symbols: { z },
		utils: {
			ast,
			state
		}
	};
	const resolver = plugin.config["~resolvers"]?.object;
	ast.expression = resolver?.(ctx$1) ?? objectResolver(ctx$1);
	return ast;
};

//#endregion
//#region src/plugins/zod/v4/toAst/string.ts
function baseNode(ctx$1) {
	const { z } = ctx$1.symbols;
	return $(z).attr(identifiers.string).call();
}
function constNode(ctx$1) {
	const { schema, symbols } = ctx$1;
	const { z } = symbols;
	if (typeof schema.const !== "string") return;
	return $(z).attr(identifiers.literal).call($.literal(schema.const));
}
function formatNode(ctx$1) {
	const { plugin, schema, symbols } = ctx$1;
	const { z } = symbols;
	switch (schema.format) {
		case "date": return $(z).attr(identifiers.iso).attr(identifiers.date).call();
		case "date-time": {
			const obj = $.object().$if(plugin.config.dates.offset, (o) => o.prop("offset", $.literal(true))).$if(plugin.config.dates.local, (o) => o.prop("local", $.literal(true)));
			return $(z).attr(identifiers.iso).attr(identifiers.datetime).call(obj.hasProps() ? obj : void 0);
		}
		case "email": return $(z).attr(identifiers.email).call();
		case "ipv4": return $(z).attr(identifiers.ipv4).call();
		case "ipv6": return $(z).attr(identifiers.ipv6).call();
		case "time": return $(z).attr(identifiers.iso).attr(identifiers.time).call();
		case "uri": return $(z).attr(identifiers.url).call();
		case "uuid": return $(z).attr(identifiers.uuid).call();
	}
}
function lengthNode(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.minLength === void 0 || schema.minLength !== schema.maxLength) return;
	return chain.current.attr(identifiers.length).call($.literal(schema.minLength));
}
function maxLengthNode(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.maxLength === void 0) return;
	return chain.current.attr(identifiers.max).call($.literal(schema.maxLength));
}
function minLengthNode(ctx$1) {
	const { chain, schema } = ctx$1;
	if (schema.minLength === void 0) return;
	return chain.current.attr(identifiers.min).call($.literal(schema.minLength));
}
function patternNode(ctx$1) {
	const { chain, schema } = ctx$1;
	if (!schema.pattern) return;
	return chain.current.attr(identifiers.regex).call($.regexp(schema.pattern));
}
function stringResolver(ctx$1) {
	const constNode$8 = ctx$1.nodes.const(ctx$1);
	if (constNode$8) {
		ctx$1.chain.current = constNode$8;
		return ctx$1.chain.current;
	}
	const baseNode$16 = ctx$1.nodes.base(ctx$1);
	if (baseNode$16) ctx$1.chain.current = baseNode$16;
	const formatNode$4 = ctx$1.nodes.format(ctx$1);
	if (formatNode$4) ctx$1.chain.current = formatNode$4;
	const lengthNode$4 = ctx$1.nodes.length(ctx$1);
	if (lengthNode$4) ctx$1.chain.current = lengthNode$4;
	else {
		const minLengthNode$4 = ctx$1.nodes.minLength(ctx$1);
		if (minLengthNode$4) ctx$1.chain.current = minLengthNode$4;
		const maxLengthNode$4 = ctx$1.nodes.maxLength(ctx$1);
		if (maxLengthNode$4) ctx$1.chain.current = maxLengthNode$4;
	}
	const patternNode$4 = ctx$1.nodes.pattern(ctx$1);
	if (patternNode$4) ctx$1.chain.current = patternNode$4;
	return ctx$1.chain.current;
}
const stringToNode = ({ plugin, schema }) => {
	const z = plugin.external("zod.z");
	const ctx$1 = {
		$,
		chain: { current: $(z) },
		nodes: {
			base: baseNode,
			const: constNode,
			format: formatNode,
			length: lengthNode,
			maxLength: maxLengthNode,
			minLength: minLengthNode,
			pattern: patternNode
		},
		plugin,
		schema,
		symbols: { z }
	};
	const resolver = plugin.config["~resolvers"]?.string;
	return { expression: resolver?.(ctx$1) ?? stringResolver(ctx$1) };
};

//#endregion
//#region src/plugins/zod/v4/toAst/tuple.ts
const tupleToAst = ({ plugin, schema, state }) => {
	const result = {};
	const z = plugin.external("zod.z");
	if (schema.const && Array.isArray(schema.const)) {
		const tupleElements$1 = schema.const.map((value) => $(z).attr(identifiers.literal).call($.fromValue(value)));
		result.expression = $(z).attr(identifiers.tuple).call($.array(...tupleElements$1));
		return result;
	}
	const tupleElements = [];
	if (schema.items) schema.items.forEach((item, index) => {
		const itemSchema = irSchemaToAst({
			plugin,
			schema: item,
			state: {
				...state,
				path: (0, _hey_api_codegen_core.ref)([
					...(0, _hey_api_codegen_core.fromRef)(state.path),
					"items",
					index
				])
			}
		});
		tupleElements.push(itemSchema.expression);
		if (itemSchema.hasLazyExpression) result.hasLazyExpression = true;
	});
	result.expression = $(z).attr(identifiers.tuple).call($.array(...tupleElements));
	return result;
};

//#endregion
//#region src/plugins/zod/v4/toAst/undefined.ts
const undefinedToAst = ({ plugin }) => {
	const result = {};
	result.expression = $(plugin.external("zod.z")).attr(identifiers.undefined).call();
	return result;
};

//#endregion
//#region src/plugins/zod/v4/toAst/void.ts
const voidToAst = ({ plugin }) => {
	const result = {};
	result.expression = $(plugin.external("zod.z")).attr(identifiers.void).call();
	return result;
};

//#endregion
//#region src/plugins/zod/v4/toAst/index.ts
const irSchemaWithTypeToAst = ({ schema, ...args }) => {
	switch (schema.type) {
		case "array": return arrayToAst({
			...args,
			schema
		});
		case "boolean": return booleanToAst({
			...args,
			schema
		});
		case "enum": return enumToAst({
			...args,
			schema
		});
		case "integer":
		case "number": return numberToNode({
			...args,
			schema
		});
		case "never": return neverToAst({
			...args,
			schema
		});
		case "null": return nullToAst({
			...args,
			schema
		});
		case "object": return objectToAst({
			...args,
			schema
		});
		case "string": return shouldCoerceToBigInt(schema.format) ? numberToNode({
			...args,
			schema: {
				...schema,
				type: "number"
			}
		}) : stringToNode({
			...args,
			schema
		});
		case "tuple": return tupleToAst({
			...args,
			schema
		});
		case "undefined": return undefinedToAst({
			...args,
			schema
		});
		case "unknown": return unknownToAst({
			...args,
			schema
		});
		case "void": return voidToAst({
			...args,
			schema
		});
	}
};

//#endregion
//#region src/plugins/zod/v4/plugin.ts
const irSchemaToAst = ({ optional, plugin, schema, state }) => {
	let ast = {};
	const z = plugin.external("zod.z");
	if (schema.$ref) {
		const query = {
			category: "schema",
			resource: "definition",
			resourceId: schema.$ref,
			tool: "zod"
		};
		const refSymbol = plugin.referenceSymbol(query);
		if (plugin.isSymbolRegistered(query)) ast.expression = $(refSymbol);
		else {
			ast.expression = $(z).attr(identifiers.lazy).call($.func().returns("any").do($(refSymbol).return()));
			ast.hasLazyExpression = true;
			state.hasLazyExpression["~ref"] = true;
		}
	} else if (schema.type) {
		const typeAst = irSchemaWithTypeToAst({
			plugin,
			schema,
			state
		});
		ast.expression = typeAst.expression;
		ast.hasLazyExpression = typeAst.hasLazyExpression;
		if (plugin.config.metadata && schema.description) ast.expression = ast.expression.attr(identifiers.register).call($(z).attr(identifiers.globalRegistry), $.object().pretty().prop("description", $.literal(schema.description)));
	} else if (schema.items) {
		schema = deduplicateSchema({ schema });
		if (schema.items) {
			const itemSchemas = schema.items.map((item, index) => irSchemaToAst({
				plugin,
				schema: item,
				state: {
					...state,
					path: (0, _hey_api_codegen_core.ref)([
						...(0, _hey_api_codegen_core.fromRef)(state.path),
						"items",
						index
					])
				}
			}));
			if (schema.logicalOperator === "and") {
				const firstSchema = schema.items[0];
				if (firstSchema.logicalOperator === "or" || firstSchema.type && firstSchema.type !== "object") ast.expression = $(z).attr(identifiers.intersection).call(...itemSchemas.map((schema$1) => schema$1.expression));
				else {
					ast.expression = itemSchemas[0].expression;
					itemSchemas.slice(1).forEach((schema$1) => {
						ast.expression = ast.expression.attr(identifiers.and).call(schema$1.hasLazyExpression ? $(z).attr(identifiers.lazy).call($.func().do(schema$1.expression.return())) : schema$1.expression);
					});
				}
			} else ast.expression = $(z).attr(identifiers.union).call($.array().pretty().elements(...itemSchemas.map((schema$1) => schema$1.expression)));
		} else ast = irSchemaToAst({
			plugin,
			schema,
			state
		});
	} else {
		const typeAst = irSchemaWithTypeToAst({
			plugin,
			schema: { type: "unknown" },
			state
		});
		ast.expression = typeAst.expression;
	}
	if (ast.expression) {
		if (schema.accessScope === "read") ast.expression = ast.expression.attr(identifiers.readonly).call();
		if (optional) {
			ast.expression = $(z).attr(identifiers.optional).call(ast.expression);
			ast.typeName = identifiers.ZodOptional;
		}
		if (schema.default !== void 0) ast.expression = ast.expression.attr(identifiers.default).call(schema.type === "integer" || schema.type === "number" ? maybeBigInt(schema.default, schema.format) : $.fromValue(schema.default));
	}
	return ast;
};
const handleComponent = ({ plugin, schema, state }) => {
	const $ref = pathToJsonPointer((0, _hey_api_codegen_core.fromRef)(state.path));
	const ast = irSchemaToAst({
		plugin,
		schema,
		state
	});
	const baseName = refToName($ref);
	exportAst({
		ast,
		plugin,
		schema,
		symbol: plugin.symbol(applyNaming(baseName, plugin.config.definitions), { meta: {
			category: "schema",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "definition",
			resourceId: $ref,
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "zod"
		} }),
		typeInferSymbol: plugin.config.definitions.types.infer.enabled ? plugin.symbol(applyNaming(baseName, plugin.config.definitions.types.infer), { meta: {
			category: "type",
			path: (0, _hey_api_codegen_core.fromRef)(state.path),
			resource: "definition",
			resourceId: $ref,
			tags: (0, _hey_api_codegen_core.fromRef)(state.tags),
			tool: "zod",
			variant: "infer"
		} }) : void 0
	});
};
const handlerV4 = ({ plugin }) => {
	plugin.symbol("z", {
		external: getZodModule({ plugin }),
		meta: {
			category: "external",
			resource: "zod.z"
		}
	});
	plugin.forEach("operation", "parameter", "requestBody", "schema", "webhook", (event) => {
		const state = (0, _hey_api_codegen_core.refs)({
			hasLazyExpression: false,
			path: event._path,
			tags: event.tags
		});
		switch (event.type) {
			case "operation":
				irOperationToAst({
					getAst: (schema, path$10) => {
						return irSchemaToAst({
							plugin,
							schema,
							state: (0, _hey_api_codegen_core.refs)({
								hasLazyExpression: false,
								path: path$10,
								tags: event.tags
							})
						});
					},
					operation: event.operation,
					plugin,
					state
				});
				break;
			case "parameter":
				handleComponent({
					plugin,
					schema: event.parameter.schema,
					state
				});
				break;
			case "requestBody":
				handleComponent({
					plugin,
					schema: event.requestBody.schema,
					state
				});
				break;
			case "schema":
				handleComponent({
					plugin,
					schema: event.schema,
					state
				});
				break;
			case "webhook":
				irWebhookToAst({
					getAst: (schema, path$10) => {
						return irSchemaToAst({
							plugin,
							schema,
							state: (0, _hey_api_codegen_core.refs)({
								hasLazyExpression: false,
								path: path$10,
								tags: event.tags
							})
						});
					},
					operation: event.operation,
					plugin,
					state
				});
				break;
		}
	});
};

//#endregion
//#region src/plugins/zod/plugin.ts
const handler = (args) => {
	const { plugin } = args;
	switch (plugin.config.compatibilityVersion) {
		case 3: return handlerV3(args);
		case "mini": return handlerMini(args);
		case 4:
		default: return handlerV4(args);
	}
};

//#endregion
//#region src/plugins/zod/config.ts
const defaultConfig = {
	api: new Api(),
	config: {
		case: "camelCase",
		comments: true,
		exportFromIndex: false,
		metadata: false
	},
	handler,
	name: "zod",
	resolveConfig: (plugin, context) => {
		const packageName = "zod";
		const version = context.package.getVersion(packageName);
		const inferCompatibleVersion = () => {
			if (version && (version.major === 4 || version.major === 3)) return version.major;
			return 4;
		};
		const ensureCompatibleVersion = (compatibilityVersion) => {
			if (!compatibilityVersion) return inferCompatibleVersion();
			if (!version) return compatibilityVersion;
			if (compatibilityVersion === 4 || compatibilityVersion === 3 || compatibilityVersion === "mini") {
				if (!context.package.satisfies(version, ">=3.25.0 <5.0.0")) {
					const compatibleVersion = inferCompatibleVersion();
					console.warn(`ðŸ”Œ ${ansi_colors.default.yellow("Warning:")} Installed ${ansi_colors.default.cyan(packageName)} ${ansi_colors.default.cyan(`v${version.version}`)} does not support compatibility version ${ansi_colors.default.yellow(String(compatibilityVersion))}, using ${ansi_colors.default.yellow(String(compatibleVersion))}.`);
					return compatibleVersion;
				}
			}
			return compatibilityVersion;
		};
		plugin.config.compatibilityVersion = ensureCompatibleVersion(plugin.config.compatibilityVersion);
		plugin.config.dates = context.valueToObject({
			defaultValue: {
				local: false,
				offset: false
			},
			value: plugin.config.dates
		});
		plugin.config.types = context.valueToObject({
			defaultValue: { infer: {
				case: "PascalCase",
				enabled: false
			} },
			mappers: { object: (fields, defaultValue) => ({
				...fields,
				infer: context.valueToObject({
					defaultValue: {
						...defaultValue.infer,
						enabled: fields.infer !== void 0 ? Boolean(fields.infer) : defaultValue.infer.enabled
					},
					mappers,
					value: fields.infer
				})
			}) },
			value: plugin.config.types
		});
		plugin.config.definitions = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "z{{name}}",
				types: {
					...plugin.config.types,
					infer: {
						...plugin.config.types.infer,
						name: "{{name}}ZodType"
					}
				}
			},
			mappers: {
				...mappers,
				object: (fields, defaultValue) => ({
					...fields,
					types: context.valueToObject({
						defaultValue: defaultValue.types,
						mappers: { object: (fields$1, defaultValue$1) => ({
							...fields$1,
							infer: context.valueToObject({
								defaultValue: {
									...defaultValue$1.infer,
									enabled: fields$1.infer !== void 0 ? Boolean(fields$1.infer) : defaultValue$1.infer.enabled
								},
								mappers,
								value: fields$1.infer
							})
						}) },
						value: fields.types
					})
				})
			},
			value: plugin.config.definitions
		});
		plugin.config.requests = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "z{{name}}Data",
				types: {
					...plugin.config.types,
					infer: {
						...plugin.config.types.infer,
						name: "{{name}}DataZodType"
					}
				}
			},
			mappers: {
				...mappers,
				object: (fields, defaultValue) => ({
					...fields,
					types: context.valueToObject({
						defaultValue: defaultValue.types,
						mappers: { object: (fields$1, defaultValue$1) => ({
							...fields$1,
							infer: context.valueToObject({
								defaultValue: {
									...defaultValue$1.infer,
									enabled: fields$1.infer !== void 0 ? Boolean(fields$1.infer) : defaultValue$1.infer.enabled
								},
								mappers,
								value: fields$1.infer
							})
						}) },
						value: fields.types
					})
				})
			},
			value: plugin.config.requests
		});
		plugin.config.responses = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "z{{name}}Response",
				types: {
					...plugin.config.types,
					infer: {
						...plugin.config.types.infer,
						name: "{{name}}ResponseZodType"
					}
				}
			},
			mappers: {
				...mappers,
				object: (fields, defaultValue) => ({
					...fields,
					types: context.valueToObject({
						defaultValue: defaultValue.types,
						mappers: { object: (fields$1, defaultValue$1) => ({
							...fields$1,
							infer: context.valueToObject({
								defaultValue: {
									...defaultValue$1.infer,
									enabled: fields$1.infer !== void 0 ? Boolean(fields$1.infer) : defaultValue$1.infer.enabled
								},
								mappers,
								value: fields$1.infer
							})
						}) },
						value: fields.types
					})
				})
			},
			value: plugin.config.responses
		});
		plugin.config.webhooks = context.valueToObject({
			defaultValue: {
				case: plugin.config.case ?? "camelCase",
				enabled: true,
				name: "z{{name}}WebhookRequest",
				types: {
					...plugin.config.types,
					infer: {
						...plugin.config.types.infer,
						name: "{{name}}WebhookRequestZodType"
					}
				}
			},
			mappers: {
				...mappers,
				object: (fields, defaultValue) => ({
					...fields,
					types: context.valueToObject({
						defaultValue: defaultValue.types,
						mappers: { object: (fields$1, defaultValue$1) => ({
							...fields$1,
							infer: context.valueToObject({
								defaultValue: {
									...defaultValue$1.infer,
									enabled: fields$1.infer !== void 0 ? Boolean(fields$1.infer) : defaultValue$1.infer.enabled
								},
								mappers,
								value: fields$1.infer
							})
						}) },
						value: fields.types
					})
				})
			},
			value: plugin.config.webhooks
		});
	},
	tags: ["validator"]
};
/**
* Type helper for Zod plugin, returns {@link Plugin.Config} object
*/
const defineConfig = definePluginConfig(defaultConfig);

//#endregion
//#region src/plugins/config.ts
const defaultPluginConfigs = {
	"@angular/common": defaultConfig$23,
	"@faker-js/faker": defaultConfig$22,
	"@hey-api/client-angular": defaultConfig$21,
	"@hey-api/client-axios": defaultConfig$20,
	"@hey-api/client-fetch": defaultConfig$19,
	"@hey-api/client-ky": defaultConfig$18,
	"@hey-api/client-next": defaultConfig$17,
	"@hey-api/client-nuxt": defaultConfig$16,
	"@hey-api/client-ofetch": defaultConfig$15,
	"@hey-api/schemas": defaultConfig$14,
	"@hey-api/sdk": defaultConfig$13,
	"@hey-api/transformers": defaultConfig$12,
	"@hey-api/typescript": defaultConfig$11,
	"@pinia/colada": defaultConfig$10,
	"@tanstack/angular-query-experimental": defaultConfig$9,
	"@tanstack/react-query": defaultConfig$8,
	"@tanstack/solid-query": defaultConfig$7,
	"@tanstack/svelte-query": defaultConfig$6,
	"@tanstack/vue-query": defaultConfig$5,
	arktype: defaultConfig$4,
	fastify: defaultConfig$3,
	swr: defaultConfig$2,
	valibot: defaultConfig$1,
	zod: defaultConfig
};

//#endregion
//#region src/config/plugins.ts
/**
* Default plugins used to generate artifacts if plugins aren't specified.
*/
const defaultPlugins = ["@hey-api/typescript", "@hey-api/sdk"];
const getPluginsConfig = ({ dependencies, userPlugins, userPluginsConfig }) => {
	const circularReferenceTracker = /* @__PURE__ */ new Set();
	const pluginOrder = /* @__PURE__ */ new Set();
	const plugins = {};
	const dfs = (name) => {
		if (circularReferenceTracker.has(name)) throw new Error(`Circular reference detected at '${name}'`);
		if (pluginOrder.has(name)) return;
		circularReferenceTracker.add(name);
		const defaultPlugin = defaultPluginConfigs[name];
		const userPlugin = userPluginsConfig[name];
		if (!defaultPlugin && !userPlugin) throw new Error(`unknown plugin dependency "${name}" - do you need to register a custom plugin with this name?`);
		const plugin = {
			...defaultPlugin,
			...userPlugin,
			config: {
				...defaultPlugin?.config,
				...userPlugin?.config
			},
			dependencies: new Set([...defaultPlugin?.dependencies || [], ...userPlugin?.dependencies || []])
		};
		if (plugin.resolveConfig) {
			const context = {
				package: packageFactory(dependencies),
				pluginByTag: (tag, props = {}) => {
					const { defaultPlugin: defaultPlugin$1, errorMessage } = props;
					for (const userPlugin$1 of userPlugins) {
						const defaultConfig$24 = defaultPluginConfigs[userPlugin$1] || userPluginsConfig[userPlugin$1];
						if (defaultConfig$24 && defaultConfig$24.tags?.includes(tag) && userPlugin$1 !== name) return userPlugin$1;
					}
					if (defaultPlugin$1) {
						const defaultConfig$24 = defaultPluginConfigs[defaultPlugin$1] || userPluginsConfig[defaultPlugin$1];
						if (defaultConfig$24 && defaultConfig$24.tags?.includes(tag) && defaultPlugin$1 !== name) return defaultPlugin$1;
					}
					throw new Error(errorMessage || `missing plugin - no plugin with tag "${tag}" found`);
				},
				valueToObject
			};
			plugin.resolveConfig(plugin, context);
		}
		for (const dependency of plugin.dependencies) dfs(dependency);
		circularReferenceTracker.delete(name);
		pluginOrder.add(name);
		plugins[name] = plugin;
	};
	for (const name of userPlugins) dfs(name);
	return {
		pluginOrder: Array.from(pluginOrder),
		plugins
	};
};
const isPluginClient = (plugin) => {
	if (typeof plugin === "string") return plugin.startsWith("@hey-api/client");
	return plugin.name.startsWith("@hey-api/client") || plugin.tags && plugin.tags.includes("client");
};
const getPlugins = ({ dependencies, userConfig }) => {
	const userPluginsConfig = {};
	let definedPlugins = defaultPlugins;
	if (userConfig.plugins) {
		userConfig.plugins = userConfig.plugins.filter((plugin) => typeof plugin === "string" && plugin || typeof plugin !== "string" && plugin.name);
		if (userConfig.plugins.length === 1 && isPluginClient(userConfig.plugins[0])) definedPlugins = [...defaultPlugins, ...userConfig.plugins];
		else definedPlugins = userConfig.plugins;
	}
	return getPluginsConfig({
		dependencies,
		userPlugins: definedPlugins.map((plugin) => {
			if (typeof plugin === "string") return plugin;
			const pluginName = plugin.name;
			if (pluginName) if (plugin.handler) userPluginsConfig[pluginName] = plugin;
			else {
				userPluginsConfig[pluginName] = { config: { ...plugin } };
				delete userPluginsConfig[pluginName].config.name;
			}
			return pluginName;
		}).filter(Boolean),
		userPluginsConfig
	});
};

//#endregion
//#region src/config/resolve.ts
const resolveConfig = (validated, dependencies) => {
	const logs = getLogs(validated.job.config);
	const input = getInput(validated.job.config);
	const output = getOutput(validated.job.config);
	const parser = getParser(validated.job.config);
	output.path = node_path.default.resolve(process.cwd(), output.path);
	let plugins;
	try {
		plugins = getPlugins({
			dependencies,
			userConfig: validated.job.config
		});
	} catch (error) {
		validated.errors.push(error);
		plugins = {
			pluginOrder: [],
			plugins: {}
		};
	}
	const config = {
		configFile: validated.job.config.configFile ?? "",
		dryRun: validated.job.config.dryRun ?? false,
		input,
		interactive: validated.job.config.interactive ?? (0, _hey_api_codegen_core.detectInteractiveSession)(),
		logs,
		output,
		parser,
		pluginOrder: plugins.pluginOrder,
		plugins: plugins.plugins
	};
	if (logs.level === "debug") {
		const jobPrefix = ansi_colors.default.gray(`[Job ${validated.job.index}] `);
		console.warn(`${jobPrefix}${ansi_colors.default.cyan("config:")}`, config);
	}
	return {
		config,
		errors: validated.errors,
		index: validated.job.index
	};
};

//#endregion
//#region src/config/validate.ts
function validateJobs(jobs) {
	return jobs.map((job) => {
		const errors = [];
		const { config } = job;
		if (!getInput(config).length) errors.push(new ConfigError("missing input - which OpenAPI specification should we use to generate your output?"));
		if (!getOutput(config).path) errors.push(new ConfigError("missing output - where should we generate your output?"));
		return {
			errors,
			job
		};
	});
}

//#endregion
//#region src/config/init.ts
/**
* @internal
*/
async function resolveJobs({ logger, userConfigs }) {
	const configs = [];
	let dependencies = {};
	const eventLoad = logger.timeEvent("load");
	for (const userConfig of userConfigs) {
		let configFile;
		if (userConfig.configFile) {
			const parts = userConfig.configFile.split(".");
			configFile = parts.slice(0, parts.length - 1).join(".");
		}
		const loaded = await (0, _hey_api_codegen_core.loadConfigFile)({
			configFile,
			logger,
			name: "openapi-ts",
			userConfig
		});
		if (!Object.keys(dependencies).length) dependencies = getProjectDependencies(loaded.foundConfig ? loaded.configFile : void 0);
		configs.push(...loaded.configs);
	}
	eventLoad.timeEnd();
	const eventBuild = logger.timeEvent("build");
	const resolvedJobs = validateJobs(expandToJobs(configs)).map((validated) => resolveConfig(validated, dependencies));
	eventBuild.timeEnd();
	return {
		dependencies,
		jobs: resolvedJobs,
		results: resolvedJobs
	};
}

//#endregion
//#region src/plugins/@hey-api/client-core/bundle/params.ts
const extraPrefixes = Object.entries({
	$body_: "body",
	$headers_: "headers",
	$path_: "path",
	$query_: "query"
});

//#endregion
//#region src/plugins/@hey-api/client-core/bundle/pathSerializer.ts
const separatorArrayExplode = (style) => {
	switch (style) {
		case "label": return ".";
		case "matrix": return ";";
		case "simple": return ",";
		default: return "&";
	}
};
const separatorArrayNoExplode = (style) => {
	switch (style) {
		case "form": return ",";
		case "pipeDelimited": return "|";
		case "spaceDelimited": return "%20";
		default: return ",";
	}
};
const separatorObjectExplode = (style) => {
	switch (style) {
		case "label": return ".";
		case "matrix": return ";";
		case "simple": return ",";
		default: return "&";
	}
};
const serializeArrayParam = ({ allowReserved, explode, name, style, value }) => {
	if (!explode) {
		const joinedValues$1 = (allowReserved ? value : value.map((v) => encodeURIComponent(v))).join(separatorArrayNoExplode(style));
		switch (style) {
			case "label": return `.${joinedValues$1}`;
			case "matrix": return `;${name}=${joinedValues$1}`;
			case "simple": return joinedValues$1;
			default: return `${name}=${joinedValues$1}`;
		}
	}
	const separator = separatorArrayExplode(style);
	const joinedValues = value.map((v) => {
		if (style === "label" || style === "simple") return allowReserved ? v : encodeURIComponent(v);
		return serializePrimitiveParam({
			allowReserved,
			name,
			value: v
		});
	}).join(separator);
	return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};
const serializePrimitiveParam = ({ allowReserved, name, value }) => {
	if (value === void 0 || value === null) return "";
	if (typeof value === "object") throw new Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");
	return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;
};
const serializeObjectParam = ({ allowReserved, explode, name, style, value, valueOnly }) => {
	if (value instanceof Date) return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;
	if (style !== "deepObject" && !explode) {
		let values = [];
		Object.entries(value).forEach(([key, v]) => {
			values = [
				...values,
				key,
				allowReserved ? v : encodeURIComponent(v)
			];
		});
		const joinedValues$1 = values.join(",");
		switch (style) {
			case "form": return `${name}=${joinedValues$1}`;
			case "label": return `.${joinedValues$1}`;
			case "matrix": return `;${name}=${joinedValues$1}`;
			default: return joinedValues$1;
		}
	}
	const separator = separatorObjectExplode(style);
	const joinedValues = Object.entries(value).map(([key, v]) => serializePrimitiveParam({
		allowReserved,
		name: style === "deepObject" ? `${name}[${key}]` : key,
		value: v
	})).join(separator);
	return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};

//#endregion
//#region src/plugins/@hey-api/client-fetch/bundle/utils.ts
const createQuerySerializer = ({ parameters = {}, ...args } = {}) => {
	const querySerializer = (queryParams) => {
		const search = [];
		if (queryParams && typeof queryParams === "object") for (const name in queryParams) {
			const value = queryParams[name];
			if (value === void 0 || value === null) continue;
			const options = parameters[name] || args;
			if (Array.isArray(value)) {
				const serializedArray = serializeArrayParam({
					allowReserved: options.allowReserved,
					explode: true,
					name,
					style: "form",
					value,
					...options.array
				});
				if (serializedArray) search.push(serializedArray);
			} else if (typeof value === "object") {
				const serializedObject = serializeObjectParam({
					allowReserved: options.allowReserved,
					explode: true,
					name,
					style: "deepObject",
					value,
					...options.object
				});
				if (serializedObject) search.push(serializedObject);
			} else {
				const serializedPrimitive = serializePrimitiveParam({
					allowReserved: options.allowReserved,
					name,
					value
				});
				if (serializedPrimitive) search.push(serializedPrimitive);
			}
		}
		return search.join("&");
	};
	return querySerializer;
};
const headersEntries = (headers) => {
	const entries = [];
	headers.forEach((value, key) => {
		entries.push([key, value]);
	});
	return entries;
};
const mergeHeaders = (...headers) => {
	const mergedHeaders = new Headers();
	for (const header of headers) {
		if (!header) continue;
		const iterator = header instanceof Headers ? headersEntries(header) : Object.entries(header);
		for (const [key, value] of iterator) if (value === null) mergedHeaders.delete(key);
		else if (Array.isArray(value)) for (const v of value) mergedHeaders.append(key, v);
		else if (value !== void 0) mergedHeaders.set(key, typeof value === "object" ? JSON.stringify(value) : value);
	}
	return mergedHeaders;
};
const defaultQuerySerializer = createQuerySerializer({
	allowReserved: false,
	array: {
		explode: true,
		style: "form"
	},
	object: {
		explode: true,
		style: "deepObject"
	}
});

//#endregion
//#region src/getSpec.ts
/**
* @internal
*/
const getSpec = async ({ fetchOptions, inputPath, timeout, watch }) => {
	const resolvedInput = (0, _hey_api_json_schema_ref_parser.getResolvedInput)({ pathOrUrlOrSchema: inputPath });
	let arrayBuffer;
	let hasChanged;
	let response;
	if (resolvedInput.type === "url") {
		if (watch.lastValue && watch.isHeadMethodSupported !== false) {
			try {
				const request = await (0, _hey_api_json_schema_ref_parser.sendRequest)({
					fetchOptions: {
						method: "HEAD",
						...fetchOptions,
						headers: mergeHeaders(fetchOptions?.headers, watch.headers)
					},
					timeout,
					url: resolvedInput.path
				});
				if (request.response.status >= 300) return {
					error: "not-ok",
					response: request.response
				};
				response = request.response;
			} catch (error) {
				return {
					error: "not-ok",
					response: new Response(error.message)
				};
			}
			if (!response.ok && watch.isHeadMethodSupported) return {
				error: "not-ok",
				response
			};
			if (watch.isHeadMethodSupported === void 0) watch.isHeadMethodSupported = response.ok;
			if (response.status === 304) return {
				error: "not-modified",
				response
			};
			if (hasChanged === void 0) {
				const eTag = response.headers.get("ETag");
				if (eTag) {
					hasChanged = eTag !== watch.headers.get("If-None-Match");
					if (hasChanged) watch.headers.set("If-None-Match", eTag);
				}
			}
			if (hasChanged === void 0) {
				const lastModified = response.headers.get("Last-Modified");
				if (lastModified) {
					hasChanged = lastModified !== watch.headers.get("If-Modified-Since");
					if (hasChanged) watch.headers.set("If-Modified-Since", lastModified);
				}
			}
			if (hasChanged === false) return {
				error: "not-modified",
				response
			};
		}
		try {
			const request = await (0, _hey_api_json_schema_ref_parser.sendRequest)({
				fetchOptions: {
					method: "GET",
					...fetchOptions
				},
				timeout,
				url: resolvedInput.path
			});
			if (request.response.status >= 300) return {
				error: "not-ok",
				response: request.response
			};
			response = request.response;
		} catch (error) {
			return {
				error: "not-ok",
				response: new Response(error.message)
			};
		}
		if (!response.ok) return {
			error: "not-ok",
			response
		};
		arrayBuffer = response.body ? await response.arrayBuffer() : /* @__PURE__ */ new ArrayBuffer(0);
		if (hasChanged === void 0) {
			const content = new TextDecoder().decode(arrayBuffer);
			hasChanged = content !== watch.lastValue;
			watch.lastValue = content;
		}
	} else if (!watch.lastValue) watch.lastValue = resolvedInput.type;
	else hasChanged = false;
	if (hasChanged === false) return {
		error: "not-modified",
		response
	};
	return {
		arrayBuffer,
		resolvedInput
	};
};

//#endregion
//#region src/utils/minHeap.ts
var MinHeap = class {
	heap = [];
	constructor(declIndex) {
		this.declIndex = declIndex;
	}
	isEmpty() {
		return !this.heap.length;
	}
	pop() {
		const [top] = this.heap;
		if (!this.heap.length) return;
		const last = this.heap.pop();
		if (!this.heap.length) return top;
		this.heap[0] = last;
		this.sinkDown(0);
		return top;
	}
	push(item) {
		this.heap.push(item);
		this.bubbleUp(this.heap.length - 1);
	}
	bubbleUp(index) {
		const heap = this.heap;
		while (index > 0) {
			const parent = Math.floor((index - 1) / 2);
			const parentVal = heap[parent];
			const curVal = heap[index];
			if (this.declIndex.get(parentVal) <= this.declIndex.get(curVal)) break;
			heap[parent] = curVal;
			heap[index] = parentVal;
			index = parent;
		}
	}
	sinkDown(index) {
		const heap = this.heap;
		const len = heap.length;
		while (true) {
			const left = 2 * index + 1;
			const right = 2 * index + 2;
			let smallest = index;
			if (left < len) {
				const leftVal = heap[left];
				const smallestVal = heap[smallest];
				if (this.declIndex.get(leftVal) < this.declIndex.get(smallestVal)) smallest = left;
			}
			if (right < len) {
				const rightVal = heap[right];
				const smallestVal = heap[smallest];
				if (this.declIndex.get(rightVal) < this.declIndex.get(smallestVal)) smallest = right;
			}
			if (smallest === index) break;
			const tmp = heap[smallest];
			heap[smallest] = heap[index];
			heap[index] = tmp;
			index = smallest;
		}
	}
};

//#endregion
//#region src/graph/walk.ts
/**
* Walk the nodes of the graph in declaration (insertion) order.
* This is a cheap alternative to `walkTopological` when dependency ordering
* is not required and the caller only wants nodes in the order they were
* added to the graph.
*/
const walkDeclarations = (graph, callback, options) => {
	const pointers = Array.from(graph.nodes.keys());
	if (options?.preferGroups && options.preferGroups.length > 0) {
		const emitted = /* @__PURE__ */ new Set();
		if (options.matchPointerToGroup) for (const kind of options.preferGroups) for (const pointer of pointers) {
			const result = options.matchPointerToGroup(pointer);
			if (!result.matched) continue;
			if (result.kind === kind) {
				emitted.add(pointer);
				callback(pointer, graph.nodes.get(pointer));
			}
		}
		for (const pointer of pointers) {
			if (emitted.has(pointer)) continue;
			callback(pointer, graph.nodes.get(pointer));
		}
		return;
	}
	for (const pointer of pointers) callback(pointer, graph.nodes.get(pointer));
};
/**
* Walks the nodes of the graph in topological order (dependencies before dependents).
* Calls the callback for each node pointer in order.
* Nodes in cycles are grouped together and emitted in arbitrary order within the group.
*
* @param graph - The dependency graph
* @param callback - Function to call for each node pointer
*/
const walkTopological = (graph, callback, options) => {
	const pointers = Array.from(graph.nodes.keys());
	const baseIndex = /* @__PURE__ */ new Map();
	pointers.forEach((pointer, index) => baseIndex.set(pointer, index));
	const declIndex = /* @__PURE__ */ new Map();
	for (const pointer of pointers) {
		const composite = (options?.getPointerPriority?.(pointer) ?? 10) * 1e6 + (baseIndex.get(pointer) ?? 0);
		declIndex.set(pointer, composite);
	}
	const depsOf = /* @__PURE__ */ new Map();
	for (const pointer of pointers) {
		const raw = graph.subtreeDependencies?.get(pointer) ?? /* @__PURE__ */ new Set();
		const filtered = /* @__PURE__ */ new Set();
		for (const rawPointer of raw) {
			if (rawPointer === pointer) continue;
			if (graph.nodes.has(rawPointer)) filtered.add(rawPointer);
		}
		depsOf.set(pointer, filtered);
	}
	const inDegree = /* @__PURE__ */ new Map();
	const dependents = /* @__PURE__ */ new Map();
	for (const pointer of pointers) inDegree.set(pointer, 0);
	for (const [pointer, deps] of depsOf) {
		inDegree.set(pointer, deps.size);
		for (const d of deps) {
			if (!dependents.has(d)) dependents.set(d, /* @__PURE__ */ new Set());
			dependents.get(d).add(pointer);
		}
	}
	const sortByDecl = (arr) => arr.sort((a, b) => declIndex.get(a) - declIndex.get(b));
	const heap = new MinHeap(declIndex);
	for (const pointer of pointers) if ((inDegree.get(pointer) ?? 0) === 0) heap.push(pointer);
	const emitted = /* @__PURE__ */ new Set();
	const order = [];
	while (!heap.isEmpty()) {
		const cur = heap.pop();
		if (emitted.has(cur)) continue;
		emitted.add(cur);
		order.push(cur);
		const deps = dependents.get(cur);
		if (!deps) continue;
		for (const dep of deps) {
			const v = (inDegree.get(dep) ?? 0) - 1;
			inDegree.set(dep, v);
			if (v === 0) heap.push(dep);
		}
	}
	const remaining = pointers.filter((pointer) => !emitted.has(pointer));
	sortByDecl(remaining);
	for (const pointer of remaining) {
		emitted.add(pointer);
		order.push(pointer);
	}
	let finalOrder = order;
	if (options?.preferGroups && options.preferGroups.length > 0) {
		const groupPriority = /* @__PURE__ */ new Map();
		for (let i = 0; i < options.preferGroups.length; i++) {
			const k = options.preferGroups[i];
			if (k) groupPriority.set(k, i);
		}
		const getGroup = (pointer) => {
			if (options.matchPointerToGroup) {
				const result = options.matchPointerToGroup(pointer);
				if (result.matched) return groupPriority.has(result.kind) ? groupPriority.get(result.kind) : options.preferGroups.length;
			}
			return options.preferGroups.length;
		};
		const proposed = [...order].sort((a, b) => {
			const ga = getGroup(a);
			const gb = getGroup(b);
			return ga !== gb ? ga - gb : order.indexOf(a) - order.indexOf(b);
		});
		const proposedIndex = /* @__PURE__ */ new Map();
		for (let i = 0; i < proposed.length; i++) proposedIndex.set(proposed[i], i);
		if (!(() => {
			for (const [node, deps] of depsOf) for (const dep of deps) {
				if (getGroup(dep) <= getGroup(node)) continue;
				if (proposedIndex.get(dep) >= proposedIndex.get(node)) return true;
			}
			return false;
		})()) finalOrder = proposed;
	}
	for (const pointer of finalOrder) callback(pointer, graph.nodes.get(pointer));
};
const walk = (graph, callback, options) => {
	if (options?.order === "topological") return walkTopological(graph, callback, options);
	return walkDeclarations(graph, callback, options);
};

//#endregion
//#region src/ir/graph.ts
const irTopLevelKinds = [
	"operation",
	"parameter",
	"requestBody",
	"schema",
	"server",
	"webhook"
];
/**
* Checks if a pointer matches a known top-level IR component (schema, parameter, etc) and returns match info.
*
* @param pointer - The IR pointer string (e.g. '#/components/schemas/Foo')
* @param kind - (Optional) The component kind to check
* @returns { matched: true, kind: IrTopLevelKind } | { matched: false } - Whether it matched, and the matched kind if so
*/
const matchIrPointerToGroup = (pointer, kind) => {
	const patterns = {
		operation: /^#\/paths\/[^/]+\/(get|put|post|delete|options|head|patch|trace)$/,
		parameter: /^#\/components\/parameters\/[^/]+$/,
		requestBody: /^#\/components\/requestBodies\/[^/]+$/,
		schema: /^#\/components\/schemas\/[^/]+$/,
		server: /^#\/servers\/(\d+|[^/]+)$/,
		webhook: /^#\/webhooks\/[^/]+\/(get|put|post|delete|options|head|patch|trace)$/
	};
	if (kind) return patterns[kind].test(pointer) ? {
		kind,
		matched: true
	} : { matched: false };
	for (const key of Object.keys(patterns)) {
		const kind$1 = key;
		if (patterns[kind$1].test(pointer)) return {
			kind: kind$1,
			matched: true
		};
	}
	return { matched: false };
};
const preferGroups = [
	"server",
	"schema",
	"parameter",
	"requestBody",
	"operation",
	"webhook"
];
const kindPriority = (() => {
	const partial = {};
	for (let i = 0; i < preferGroups.length; i++) {
		const k = preferGroups[i];
		if (k) partial[k] = i;
	}
	for (const k of irTopLevelKinds) if (partial[k] === void 0) partial[k] = preferGroups.length;
	return partial;
})();
const defaultPriority = 10;
const getIrPointerPriority = (pointer) => {
	const result = matchIrPointerToGroup(pointer);
	if (result.matched) return kindPriority[result.kind] ?? defaultPriority;
	return defaultPriority;
};

//#endregion
//#region src/plugins/shared/utils/instance.ts
const defaultGetFilePath = (symbol) => {
	if (!symbol.meta?.pluginName || typeof symbol.meta.pluginName !== "string") return;
	if (symbol.meta.pluginName.startsWith("@hey-api/client-")) return "client";
	if (symbol.meta.pluginName === "@hey-api/typescript") return "types";
	if (symbol.meta.pluginName.startsWith("@hey-api/")) return symbol.meta.pluginName.split("/")[1];
	return symbol.meta.pluginName;
};
const defaultGetKind = (operation) => {
	switch (operation.method) {
		case "delete":
		case "patch":
		case "post":
		case "put": return ["mutation"];
		case "get": return ["query"];
		default: return;
	}
};
var PluginInstance = class {
	api;
	config;
	context;
	dependencies = [];
	eventHooks;
	gen;
	handler;
	name;
	/**
	* The package metadata and utilities for the current context, constructed
	* from the provided dependencies. Used for managing package-related
	* information such as name, version, and dependency resolution during
	* code generation.
	*/
	package;
	constructor(props) {
		this.api = props.api ?? {};
		this.config = props.config;
		this.context = props.context;
		this.dependencies = props.dependencies;
		this.eventHooks = this.buildEventHooks();
		this.gen = props.gen;
		this.handler = props.handler;
		this.name = props.name;
		this.package = props.context.package;
	}
	external(resource, meta) {
		return this.gen.symbols.reference({
			...meta,
			category: "external",
			resource
		});
	}
	forEach(...args) {
		if (!this.context.graph) throw new Error("No graph available in context");
		let callback;
		let events;
		let options = {
			getPointerPriority: getIrPointerPriority,
			matchPointerToGroup: matchIrPointerToGroup,
			order: "topological",
			preferGroups
		};
		if (typeof args[args.length - 1] === "function") {
			events = args.slice(0, -1);
			callback = args[args.length - 1];
		} else {
			events = args.slice(0, -2);
			callback = args[args.length - 2];
			options = {
				...options,
				...args[args.length - 1]
			};
		}
		const eventSet = new Set(events.length ? events : irTopLevelKinds);
		walk(this.context.graph, (pointer, nodeInfo) => {
			const result = matchIrPointerToGroup(pointer);
			if (!result.matched || !eventSet.has(result.kind)) return;
			let event;
			const baseEvent = {
				_path: jsonPointerToPath(pointer),
				pointer,
				tags: nodeInfo.tags ? Array.from(nodeInfo.tags) : void 0
			};
			switch (result.kind) {
				case "operation":
					event = {
						...baseEvent,
						method: nodeInfo.key,
						operation: nodeInfo.node,
						path: baseEvent._path[1],
						type: result.kind
					};
					break;
				case "parameter":
					event = {
						...baseEvent,
						name: nodeInfo.key,
						parameter: nodeInfo.node,
						type: result.kind
					};
					break;
				case "requestBody":
					event = {
						...baseEvent,
						name: nodeInfo.key,
						requestBody: nodeInfo.node,
						type: result.kind
					};
					break;
				case "schema":
					event = {
						...baseEvent,
						name: nodeInfo.key,
						schema: nodeInfo.node,
						type: result.kind
					};
					break;
				case "server":
					event = {
						...baseEvent,
						server: nodeInfo.node,
						type: result.kind
					};
					break;
				case "webhook":
					event = {
						...baseEvent,
						key: baseEvent._path[1],
						method: nodeInfo.key,
						operation: nodeInfo.node,
						type: result.kind
					};
					break;
			}
			if (event) try {
				callback(event);
			} catch (error) {
				this.forEachError(error, event);
			}
		}, options);
	}
	/**
	* Retrieves a registered plugin instance by its name from the context. This
	* allows plugins to access other plugins that have been registered in the
	* same context, enabling cross-plugin communication and dependencies.
	*
	* @param name Plugin name as defined in the configuration.
	* @returns The plugin instance if found, undefined otherwise.
	*/
	getPlugin(name) {
		return this.context.plugins[name];
	}
	/**
	* Retrieves a registered plugin instance by its name from the context. This
	* allows plugins to access other plugins that have been registered in the
	* same context, enabling cross-plugin communication and dependencies.
	*
	* @param name Plugin name as defined in the configuration.
	* @returns The plugin instance if found, throw otherwise.
	*/
	getPluginOrThrow(name) {
		const plugin = this.getPlugin(name);
		if (!plugin) throw new Error(`plugin not found ${name}`);
		return plugin;
	}
	getSymbol(identifier) {
		return this.gen.symbols.get(identifier);
	}
	hooks = { operation: {
		isMutation: (operation) => this.isOperationKind(operation, "mutation"),
		isQuery: (operation) => this.isOperationKind(operation, "query")
	} };
	/**
	* Registers an intent in the context's intent list.
	*
	* @param intent The intent to be registered.
	* @returns void
	*/
	intent(intent) {
		this.context.intents.push(intent);
	}
	isSymbolRegistered(identifier) {
		return this.gen.symbols.isRegistered(identifier);
	}
	/**
	* Sets or adds a node to the project graph.
	*
	* @param node The node to be added or updated in the project graph.
	* @param index The index at which to update the node. If undefined, the node will be added.
	* @returns The index of the added node or void if updated.
	*/
	node(node, index) {
		for (const hook of this.eventHooks["node:set:before"]) hook({
			node,
			plugin: this
		});
		const result = index !== void 0 ? this.gen.nodes.update(index, node) : this.gen.nodes.add(node);
		for (const hook of this.eventHooks["node:set:after"]) hook({
			node,
			plugin: this
		});
		return result;
	}
	querySymbol(filter) {
		return this.gen.symbols.query(filter)[0];
	}
	referenceSymbol(meta) {
		return this.gen.symbols.reference(meta);
	}
	/**
	* @deprecated use `plugin.symbol()` instead
	*/
	registerSymbol(symbol) {
		return this.symbol(symbol.name, symbol);
	}
	/**
	* Executes plugin's handler function.
	*/
	async run() {
		for (const hook of this.eventHooks["plugin:handler:before"]) hook({ plugin: this });
		await this.handler({ plugin: this });
		for (const hook of this.eventHooks["plugin:handler:after"]) hook({ plugin: this });
	}
	symbol(name, symbol) {
		const symbolIn = {
			...symbol,
			exportFrom: symbol?.exportFrom ?? (!symbol?.external && this.context.config.output.indexFile && this.config.exportFromIndex ? ["index"] : void 0),
			getFilePath: symbol?.getFilePath ?? this.getSymbolFilePath.bind(this),
			meta: {
				pluginName: node_path.default.isAbsolute(this.name) ? "custom" : this.name,
				...symbol?.meta
			},
			name
		};
		for (const hook of this.eventHooks["symbol:register:before"]) hook({
			plugin: this,
			symbol: symbolIn
		});
		const symbolOut = this.gen.symbols.register(symbolIn);
		for (const hook of this.eventHooks["symbol:register:after"]) hook({
			plugin: this,
			symbol: symbolOut
		});
		return symbolOut;
	}
	/**
	* Registers a symbol only if it does not already exist based on the provided
	* metadata. This prevents duplicate symbols from being created in the project.
	*/
	symbolOnce(name, symbol) {
		const meta = { ...symbol?.meta };
		if (symbol?.external) {
			meta.category = "external";
			meta.resource = symbol.external;
		}
		const existing = this.querySymbol(meta);
		if (existing) return existing;
		return this.symbol(name, {
			...symbol,
			meta
		});
	}
	buildEventHooks() {
		const result = {
			"node:set:after": [],
			"node:set:before": [],
			"plugin:handler:after": [],
			"plugin:handler:before": [],
			"symbol:register:after": [],
			"symbol:register:before": []
		};
		const scopes = [this.config["~hooks"]?.events, this.context.config.parser.hooks.events];
		for (const scope of scopes) {
			if (!scope) continue;
			for (const [key, value] of Object.entries(scope)) if (value) result[key].push(value.bind(scope));
		}
		return result;
	}
	forEachError(error, event) {
		const originalError = error instanceof Error ? error : new Error(String(error));
		throw new HeyApiError({
			args: [event],
			error: originalError,
			event: event.type,
			name: "Error",
			pluginName: this.name
		});
	}
	getSymbolFilePath(symbol) {
		const hooks = [this.config["~hooks"]?.symbols, this.context.config.parser.hooks.symbols];
		for (const hook of hooks) {
			const result = hook?.getFilePath?.(symbol);
			if (result !== void 0) return result;
		}
		return defaultGetFilePath(symbol);
	}
	isOperationKind(operation, kind) {
		const method = kind === "query" ? "isQuery" : "isMutation";
		const hooks = [
			this.config["~hooks"]?.operations?.[method],
			this.config["~hooks"]?.operations?.getKind,
			this.context.config.parser.hooks.operations?.[method],
			this.context.config.parser.hooks.operations?.getKind,
			defaultGetKind
		];
		for (const hook of hooks) if (hook) {
			const result = hook(operation);
			if (result !== void 0) return typeof result === "boolean" ? result : result.includes(kind);
		}
		return false;
	}
};

//#endregion
//#region src/ir/context.ts
var Context = class {
	/**
	* Configuration for parsing and generating the output. This
	* is a mix of user-provided and default values.
	*/
	config;
	/**
	* The code generation project instance used to manage files, symbols,
	*/
	gen;
	/**
	* The dependency graph built from the intermediate representation.
	*/
	graph;
	/**
	* Intents declared by plugins.
	*/
	intents = [];
	/**
	* Intermediate representation model obtained from `spec`.
	*/
	ir = {};
	/**
	* Logger instance.
	*/
	logger;
	/**
	* The package metadata and utilities for the current context, constructed
	* from the provided dependencies. Used for managing package-related
	* information such as name, version, and dependency resolution during
	* code generation.
	*/
	package;
	/**
	* A map of registered plugin instances, keyed by plugin name. Plugins are
	* registered through the `registerPlugin` method and can be accessed by
	* their configured name from the config.
	*/
	plugins = {};
	/**
	* Resolved specification from `input`.
	*/
	spec;
	constructor({ config, dependencies, logger, spec }) {
		this.config = config;
		this.gen = new _hey_api_codegen_core.Project({
			defaultFileName: "index",
			fileName: (base) => {
				const name = applyNaming(base, config.output.fileName);
				const { suffix } = config.output.fileName;
				if (!suffix) return name;
				return name === "index" || name.endsWith(suffix) ? name : `${name}${suffix}`;
			},
			nameConflictResolvers: config.output.nameConflictResolver ? { typescript: config.output.nameConflictResolver } : void 0,
			renderers: [new TypeScriptRenderer({
				header: config.output.header,
				preferExportAll: config.output.preferExportAll,
				preferFileExtension: config.output.importFileExtension || void 0,
				resolveModuleName: config.output.resolveModuleName
			})],
			root: config.output.path
		});
		this.logger = logger;
		this.package = packageFactory(dependencies);
		this.spec = spec;
	}
	/**
	* Returns a resolved and dereferenced schema from `spec`.
	*/
	dereference(schema) {
		const resolved = this.resolveRef(schema.$ref);
		const dereferenced = {
			...schema,
			...resolved
		};
		delete dereferenced.$ref;
		return dereferenced;
	}
	/**
	* Registers a new plugin to the global context.
	*
	* @param name Plugin name.
	* @returns Registered plugin instance.
	*/
	registerPlugin(name) {
		const plugin = this.config.plugins[name];
		const instance = new PluginInstance({
			api: plugin.api,
			config: plugin.config,
			context: this,
			dependencies: plugin.dependencies ?? [],
			gen: this.gen,
			handler: plugin.handler,
			name: plugin.name
		});
		this.plugins[instance.name] = instance;
		return instance;
	}
	/**
	* Registers all plugins in the order specified by the configuration and returns
	* an array of the registered PluginInstance objects. Each plugin is instantiated
	* and added to the context's plugins map.
	*
	* @returns {ReadonlyArray<PluginInstance>} An array of registered plugin instances in order.
	*/
	registerPlugins() {
		return this.config.pluginOrder.map((name) => this.registerPlugin(name));
	}
	resolveIrRef($ref) {
		return resolveRef({
			$ref,
			spec: this.ir
		});
	}
	/**
	* Returns a resolved reference from `spec`.
	*/
	resolveRef($ref) {
		return resolveRef({
			$ref,
			spec: this.spec
		});
	}
};

//#endregion
//#region src/openApi/shared/utils/operation.ts
const httpMethods = [
	"delete",
	"get",
	"head",
	"options",
	"patch",
	"post",
	"put",
	"trace"
];
/**
* Sanitizes namespace identifiers so they are valid TypeScript identifiers of a certain form.
*
* 1: Remove any leading characters that are illegal as starting character of a typescript identifier.
* 2: Replace illegal characters in remaining part of type name with hyphen (-).
*
* Step 1 should perhaps instead also replace illegal characters with underscore, or prefix with it, like sanitizeEnumName
* does. The way this is now one could perhaps end up removing all characters, if all are illegal start characters. It
* would be sort of a breaking change to do so, though, previously generated code might change then.
*
* JavaScript identifier regexp pattern retrieved from https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers
*
* The output of this is expected to be converted to PascalCase
*
* @deprecated
*/
const sanitizeNamespaceIdentifier = (name) => name.replace(/^[^\p{ID_Start}]+/u, "").replace(/[^$\u200c\u200d\p{ID_Continue}]/gu, "-").replace(/[$+]/g, "-");
/**
* Returns an operation ID to use across the application. By default, we try
* to use the provided ID. If it's not provided or the SDK is configured
* to exclude it, we generate operation ID from its location.
*
* @deprecated
*/
const operationToId = ({ context, count = 1, id, method, path: path$10, state }) => {
	let result;
	const { output } = context.config;
	const targetCase = (output !== void 0 && typeof output === "object" && "case" in output ? output.case : void 0) ?? "camelCase";
	if (id && (!context.config.plugins["@hey-api/sdk"] || context.config.plugins["@hey-api/sdk"].config.operations && typeof context.config.plugins["@hey-api/sdk"].config.operations !== "function" && typeof context.config.plugins["@hey-api/sdk"].config.operations === "object" && context.config.plugins["@hey-api/sdk"].config.operations.nesting === "operationId")) result = toCase(sanitizeNamespaceIdentifier(id), targetCase);
	else result = toCase(`${method}-${path$10.replace(/{(.*?)}/g, "by-$1").replace(/[/:+]/g, "-")}`, targetCase);
	if (count > 1) result = `${result}${count}`;
	if (state.ids.has(result)) return operationToId({
		context,
		count: count + 1,
		id,
		method,
		path: path$10,
		state
	});
	state.ids.set(result, createOperationKey({
		method,
		path: path$10
	}));
	return result;
};

//#endregion
//#region src/openApi/shared/utils/filter.ts
const namespaceNeedle = "/";
const addNamespace = (namespace$2, value = "") => `${namespace$2}${namespaceNeedle}${value}`;
const removeNamespace = (key) => {
	const index = key.indexOf(namespaceNeedle);
	return {
		name: key.slice(index + 1),
		namespace: key.slice(0, index)
	};
};
/**
* Converts reference strings from OpenAPI $ref keywords into namespaces.
*
* @example '#/components/schemas/Foo' -> 'schema'
*/
const stringToNamespace = (value) => {
	switch (value) {
		case "parameters": return "parameter";
		case "requestBodies": return "body";
		case "responses": return "response";
		case "definitions":
		case "schemas": return "schema";
		default: return "unknown";
	}
};
const createFiltersSetAndRegExps = (type, filters) => {
	const keys = [];
	const regexps = [];
	if (filters) for (const value of filters) if (value.startsWith("/") && value.endsWith("/")) regexps.push(new RegExp(value.slice(1, value.length - 1)));
	else keys.push(addNamespace(type, value));
	return {
		regexps,
		set: new Set(keys)
	};
};
const collectFiltersSetFromRegExpsOpenApiV2 = ({ excludeOperations, excludeSchemas, includeOperations, includeSchemas, spec }) => {
	if ((excludeOperations.regexps.length || includeOperations.regexps.length) && spec.paths) for (const entry of Object.entries(spec.paths)) {
		const path$10 = entry[0];
		const pathItem = entry[1];
		for (const method of httpMethods) {
			if (!pathItem[method]) continue;
			const key = createOperationKey({
				method,
				path: path$10
			});
			if (excludeOperations.regexps.some((regexp$1) => regexp$1.test(key))) excludeOperations.set.add(addNamespace("operation", key));
			if (includeOperations.regexps.some((regexp$1) => regexp$1.test(key))) includeOperations.set.add(addNamespace("operation", key));
		}
	}
	if (spec.definitions) {
		if (excludeSchemas.regexps.length || includeSchemas.regexps.length) for (const key of Object.keys(spec.definitions)) {
			if (excludeSchemas.regexps.some((regexp$1) => regexp$1.test(key))) excludeSchemas.set.add(addNamespace("schema", key));
			if (includeSchemas.regexps.some((regexp$1) => regexp$1.test(key))) includeSchemas.set.add(addNamespace("schema", key));
		}
	}
};
const collectFiltersSetFromRegExpsOpenApiV3 = ({ excludeOperations, excludeParameters, excludeRequestBodies, excludeResponses, excludeSchemas, includeOperations, includeParameters, includeRequestBodies, includeResponses, includeSchemas, spec }) => {
	if ((excludeOperations.regexps.length || includeOperations.regexps.length) && spec.paths) for (const entry of Object.entries(spec.paths)) {
		const path$10 = entry[0];
		const pathItem = entry[1];
		for (const method of httpMethods) {
			if (!pathItem[method]) continue;
			const key = createOperationKey({
				method,
				path: path$10
			});
			if (excludeOperations.regexps.some((regexp$1) => regexp$1.test(key))) excludeOperations.set.add(addNamespace("operation", key));
			if (includeOperations.regexps.some((regexp$1) => regexp$1.test(key))) includeOperations.set.add(addNamespace("operation", key));
		}
	}
	if (spec.components) {
		if ((excludeParameters.regexps.length || includeParameters.regexps.length) && spec.components.parameters) for (const key of Object.keys(spec.components.parameters)) {
			if (excludeParameters.regexps.some((regexp$1) => regexp$1.test(key))) excludeParameters.set.add(addNamespace("parameter", key));
			if (includeParameters.regexps.some((regexp$1) => regexp$1.test(key))) includeParameters.set.add(addNamespace("parameter", key));
		}
		if ((excludeRequestBodies.regexps.length || includeRequestBodies.regexps.length) && spec.components.requestBodies) for (const key of Object.keys(spec.components.requestBodies)) {
			if (excludeRequestBodies.regexps.some((regexp$1) => regexp$1.test(key))) excludeRequestBodies.set.add(addNamespace("body", key));
			if (includeRequestBodies.regexps.some((regexp$1) => regexp$1.test(key))) includeRequestBodies.set.add(addNamespace("body", key));
		}
		if ((excludeResponses.regexps.length || includeResponses.regexps.length) && spec.components.responses) for (const key of Object.keys(spec.components.responses)) {
			if (excludeResponses.regexps.some((regexp$1) => regexp$1.test(key))) excludeResponses.set.add(addNamespace("response", key));
			if (includeResponses.regexps.some((regexp$1) => regexp$1.test(key))) includeResponses.set.add(addNamespace("response", key));
		}
		if ((excludeSchemas.regexps.length || includeSchemas.regexps.length) && spec.components.schemas) for (const key of Object.keys(spec.components.schemas)) {
			if (excludeSchemas.regexps.some((regexp$1) => regexp$1.test(key))) excludeSchemas.set.add(addNamespace("schema", key));
			if (includeSchemas.regexps.some((regexp$1) => regexp$1.test(key))) includeSchemas.set.add(addNamespace("schema", key));
		}
	}
};
const collectFiltersSetFromRegExps = ({ spec, ...filters }) => {
	if ("swagger" in spec) collectFiltersSetFromRegExpsOpenApiV2({
		...filters,
		spec
	});
	else collectFiltersSetFromRegExpsOpenApiV3({
		...filters,
		spec
	});
};
const createFilters = (config, spec, logger) => {
	const eventCreateFilters = logger.timeEvent("create-filters");
	const excludeOperations = createFiltersSetAndRegExps("operation", config?.operations?.exclude);
	const includeOperations = createFiltersSetAndRegExps("operation", config?.operations?.include);
	const excludeParameters = createFiltersSetAndRegExps("parameter", config?.parameters?.exclude);
	const includeParameters = createFiltersSetAndRegExps("parameter", config?.parameters?.include);
	const excludeRequestBodies = createFiltersSetAndRegExps("body", config?.requestBodies?.exclude);
	const includeRequestBodies = createFiltersSetAndRegExps("body", config?.requestBodies?.include);
	const excludeResponses = createFiltersSetAndRegExps("response", config?.responses?.exclude);
	const includeResponses = createFiltersSetAndRegExps("response", config?.responses?.include);
	const excludeSchemas = createFiltersSetAndRegExps("schema", config?.schemas?.exclude);
	const includeSchemas = createFiltersSetAndRegExps("schema", config?.schemas?.include);
	collectFiltersSetFromRegExps({
		excludeOperations,
		excludeParameters,
		excludeRequestBodies,
		excludeResponses,
		excludeSchemas,
		includeOperations,
		includeParameters,
		includeRequestBodies,
		includeResponses,
		includeSchemas,
		spec
	});
	const filters = {
		deprecated: config?.deprecated ?? true,
		operations: {
			exclude: excludeOperations.set,
			include: includeOperations.set
		},
		orphans: config?.orphans ?? false,
		parameters: {
			exclude: excludeParameters.set,
			include: includeParameters.set
		},
		preserveOrder: config?.preserveOrder ?? false,
		requestBodies: {
			exclude: excludeRequestBodies.set,
			include: includeRequestBodies.set
		},
		responses: {
			exclude: excludeResponses.set,
			include: includeResponses.set
		},
		schemas: {
			exclude: excludeSchemas.set,
			include: includeSchemas.set
		},
		tags: {
			exclude: new Set(config?.tags?.exclude),
			include: new Set(config?.tags?.include)
		}
	};
	eventCreateFilters.timeEnd();
	return filters;
};
const hasFilters = (config) => {
	if (!config) return false;
	if (config.orphans === false || config.deprecated === false) return true;
	return Boolean(config.operations?.exclude?.length || config.operations?.include?.length || config.parameters?.exclude?.length || config.parameters?.include?.length || config.requestBodies?.exclude?.length || config.requestBodies?.include?.length || config.responses?.exclude?.length || config.responses?.include?.length || config.schemas?.exclude?.length || config.schemas?.include?.length || config.tags?.exclude?.length || config.tags?.include?.length);
};
/**
* Collect operations that satisfy the include/exclude filters and schema dependencies.
*/
const collectOperations = ({ filters, parameters, requestBodies, resourceMetadata, responses, schemas }) => {
	const finalSet = /* @__PURE__ */ new Set();
	const stack = [...filters.operations.include.size ? filters.operations.include : new Set(resourceMetadata.operations.keys())];
	while (stack.length) {
		const key = stack.pop();
		if (filters.operations.exclude.has(key) || finalSet.has(key)) continue;
		const node = resourceMetadata.operations.get(key);
		if (!node) continue;
		if (!filters.deprecated && node.deprecated) continue;
		if (filters.tags.exclude.size && node.tags.size && [...filters.tags.exclude].some((tag) => node.tags.has(tag))) continue;
		if (filters.tags.include.size && !new Set([...filters.tags.include].filter((tag) => node.tags.has(tag))).size) continue;
		if ([...node.dependencies].some((dependency) => {
			const { namespace: namespace$2 } = removeNamespace(dependency);
			switch (namespace$2) {
				case "body": return !requestBodies.has(dependency);
				case "parameter": return !parameters.has(dependency);
				case "response": return !responses.has(dependency);
				case "schema": return !schemas.has(dependency);
				default: return false;
			}
		})) continue;
		finalSet.add(key);
	}
	return { operations: finalSet };
};
/**
* Collect parameters that satisfy the include/exclude filters and schema dependencies.
*/
const collectParameters = ({ filters, resourceMetadata, schemas }) => {
	const finalSet = /* @__PURE__ */ new Set();
	const stack = [...filters.parameters.include.size ? filters.parameters.include : new Set(resourceMetadata.parameters.keys())];
	while (stack.length) {
		const key = stack.pop();
		if (filters.parameters.exclude.has(key) || finalSet.has(key)) continue;
		const node = resourceMetadata.parameters.get(key);
		if (!node) continue;
		if (!filters.deprecated && node.deprecated) continue;
		finalSet.add(key);
		if (!node.dependencies.size) continue;
		for (const dependency of node.dependencies) {
			const { namespace: namespace$2 } = removeNamespace(dependency);
			switch (namespace$2) {
				case "body":
					if (filters.requestBodies.exclude.has(dependency)) finalSet.delete(key);
					else if (!finalSet.has(dependency)) stack.push(dependency);
					break;
				case "schema":
					if (filters.schemas.exclude.has(dependency)) finalSet.delete(key);
					else if (!schemas.has(dependency)) schemas.add(dependency);
					break;
			}
		}
	}
	return { parameters: finalSet };
};
/**
* Collect request bodies that satisfy the include/exclude filters and schema dependencies.
*/
const collectRequestBodies = ({ filters, resourceMetadata, schemas }) => {
	const finalSet = /* @__PURE__ */ new Set();
	const stack = [...filters.requestBodies.include.size ? filters.requestBodies.include : new Set(resourceMetadata.requestBodies.keys())];
	while (stack.length) {
		const key = stack.pop();
		if (filters.requestBodies.exclude.has(key) || finalSet.has(key)) continue;
		const node = resourceMetadata.requestBodies.get(key);
		if (!node) continue;
		if (!filters.deprecated && node.deprecated) continue;
		finalSet.add(key);
		if (!node.dependencies.size) continue;
		for (const dependency of node.dependencies) {
			const { namespace: namespace$2 } = removeNamespace(dependency);
			switch (namespace$2) {
				case "body":
					if (filters.requestBodies.exclude.has(dependency)) finalSet.delete(key);
					else if (!finalSet.has(dependency)) stack.push(dependency);
					break;
				case "schema":
					if (filters.schemas.exclude.has(dependency)) finalSet.delete(key);
					else if (!schemas.has(dependency)) schemas.add(dependency);
					break;
			}
		}
	}
	return { requestBodies: finalSet };
};
/**
* Collect responses that satisfy the include/exclude filters and schema dependencies.
*/
const collectResponses = ({ filters, resourceMetadata, schemas }) => {
	const finalSet = /* @__PURE__ */ new Set();
	const stack = [...filters.responses.include.size ? filters.responses.include : new Set(resourceMetadata.responses.keys())];
	while (stack.length) {
		const key = stack.pop();
		if (filters.responses.exclude.has(key) || finalSet.has(key)) continue;
		const node = resourceMetadata.responses.get(key);
		if (!node) continue;
		if (!filters.deprecated && node.deprecated) continue;
		finalSet.add(key);
		if (!node.dependencies.size) continue;
		for (const dependency of node.dependencies) {
			const { namespace: namespace$2 } = removeNamespace(dependency);
			switch (namespace$2) {
				case "body":
					if (filters.requestBodies.exclude.has(dependency)) finalSet.delete(key);
					else if (!finalSet.has(dependency)) stack.push(dependency);
					break;
				case "schema":
					if (filters.schemas.exclude.has(dependency)) finalSet.delete(key);
					else if (!schemas.has(dependency)) schemas.add(dependency);
					break;
			}
		}
	}
	return { responses: finalSet };
};
/**
* Collect schemas that satisfy the include/exclude filters.
*/
const collectSchemas = ({ filters, resourceMetadata }) => {
	const finalSet = /* @__PURE__ */ new Set();
	const stack = [...filters.schemas.include.size ? filters.schemas.include : new Set(resourceMetadata.schemas.keys())];
	while (stack.length) {
		const key = stack.pop();
		if (filters.schemas.exclude.has(key) || finalSet.has(key)) continue;
		const node = resourceMetadata.schemas.get(key);
		if (!node) continue;
		if (!filters.deprecated && node.deprecated) continue;
		finalSet.add(key);
		if (!node.dependencies.size) continue;
		for (const dependency of node.dependencies) {
			const { namespace: namespace$2 } = removeNamespace(dependency);
			switch (namespace$2) {
				case "schema":
					if (!finalSet.has(dependency) && !filters.schemas.exclude.has(dependency)) stack.push(dependency);
					break;
			}
		}
	}
	return { schemas: finalSet };
};
/**
* Drop parameters that depend on already excluded parameters.
*/
const dropExcludedParameters = ({ filters, parameters, resourceMetadata }) => {
	if (!filters.parameters.exclude.size) return;
	for (const key of parameters) {
		const node = resourceMetadata.parameters.get(key);
		if (!node?.dependencies.size) continue;
		for (const excludedKey of filters.parameters.exclude) if (node.dependencies.has(excludedKey)) {
			parameters.delete(key);
			break;
		}
	}
};
/**
* Drop request bodies that depend on already excluded request bodies.
*/
const dropExcludedRequestBodies = ({ filters, requestBodies, resourceMetadata }) => {
	if (!filters.requestBodies.exclude.size) return;
	for (const key of requestBodies) {
		const node = resourceMetadata.requestBodies.get(key);
		if (!node?.dependencies.size) continue;
		for (const excludedKey of filters.requestBodies.exclude) if (node.dependencies.has(excludedKey)) {
			requestBodies.delete(key);
			break;
		}
	}
};
/**
* Drop responses that depend on already excluded responses.
*/
const dropExcludedResponses = ({ filters, resourceMetadata, responses }) => {
	if (!filters.responses.exclude.size) return;
	for (const key of responses) {
		const node = resourceMetadata.responses.get(key);
		if (!node?.dependencies.size) continue;
		for (const excludedKey of filters.responses.exclude) if (node.dependencies.has(excludedKey)) {
			responses.delete(key);
			break;
		}
	}
};
/**
* Drop schemas that depend on already excluded schemas.
*/
const dropExcludedSchemas = ({ filters, resourceMetadata, schemas }) => {
	if (!filters.schemas.exclude.size) return;
	for (const key of schemas) {
		const node = resourceMetadata.schemas.get(key);
		if (!node?.dependencies.size) continue;
		for (const excludedKey of filters.schemas.exclude) if (node.dependencies.has(excludedKey)) {
			schemas.delete(key);
			break;
		}
	}
};
const dropOrphans = ({ operationDependencies, parameters, requestBodies, responses, schemas }) => {
	for (const key of schemas) if (!operationDependencies.has(key)) schemas.delete(key);
	for (const key of parameters) if (!operationDependencies.has(key)) parameters.delete(key);
	for (const key of requestBodies) if (!operationDependencies.has(key)) requestBodies.delete(key);
	for (const key of responses) if (!operationDependencies.has(key)) responses.delete(key);
};
const collectOperationDependencies = ({ operations, resourceMetadata }) => {
	const finalSet = /* @__PURE__ */ new Set();
	const stack = [...new Set([...operations].flatMap((key) => [...resourceMetadata.operations.get(key)?.dependencies ?? []]))];
	while (stack.length) {
		const key = stack.pop();
		if (finalSet.has(key)) continue;
		finalSet.add(key);
		const { namespace: namespace$2 } = removeNamespace(key);
		let dependencies;
		if (namespace$2 === "body") dependencies = resourceMetadata.requestBodies.get(key)?.dependencies;
		else if (namespace$2 === "operation") dependencies = resourceMetadata.operations.get(key)?.dependencies;
		else if (namespace$2 === "parameter") dependencies = resourceMetadata.parameters.get(key)?.dependencies;
		else if (namespace$2 === "response") dependencies = resourceMetadata.responses.get(key)?.dependencies;
		else if (namespace$2 === "schema") dependencies = resourceMetadata.schemas.get(key)?.dependencies;
		if (!dependencies?.size) continue;
		for (const dependency of dependencies) if (!finalSet.has(dependency)) stack.push(dependency);
	}
	return { operationDependencies: finalSet };
};
const createFilteredDependencies = ({ filters, logger, resourceMetadata }) => {
	const eventCreateFilteredDependencies = logger.timeEvent("create-filtered-dependencies");
	const { schemas } = collectSchemas({
		filters,
		resourceMetadata
	});
	const { parameters } = collectParameters({
		filters,
		resourceMetadata,
		schemas
	});
	const { requestBodies } = collectRequestBodies({
		filters,
		resourceMetadata,
		schemas
	});
	const { responses } = collectResponses({
		filters,
		resourceMetadata,
		schemas
	});
	dropExcludedSchemas({
		filters,
		resourceMetadata,
		schemas
	});
	dropExcludedParameters({
		filters,
		parameters,
		resourceMetadata
	});
	dropExcludedRequestBodies({
		filters,
		requestBodies,
		resourceMetadata
	});
	dropExcludedResponses({
		filters,
		resourceMetadata,
		responses
	});
	const { operations } = collectOperations({
		filters,
		parameters,
		requestBodies,
		resourceMetadata,
		responses,
		schemas
	});
	if (!filters.orphans && operations.size) {
		const { operationDependencies } = collectOperationDependencies({
			operations,
			resourceMetadata
		});
		dropOrphans({
			operationDependencies,
			parameters,
			requestBodies,
			responses,
			schemas
		});
	}
	eventCreateFilteredDependencies.timeEnd();
	return {
		operations,
		parameters,
		requestBodies,
		responses,
		schemas
	};
};

//#endregion
//#region src/openApi/shared/graph/meta.ts
/**
* Builds a resource metadata map from a Graph, matching the old Graph interface
* for compatibility with filtering code.
*/
const buildResourceMetadata = (graph, logger) => {
	const eventBuildResourceMetadata = logger.timeEvent("build-resource-metadata");
	const resourceMetadata = {
		operations: /* @__PURE__ */ new Map(),
		parameters: /* @__PURE__ */ new Map(),
		requestBodies: /* @__PURE__ */ new Map(),
		responses: /* @__PURE__ */ new Map(),
		schemas: /* @__PURE__ */ new Map()
	};
	const getDependencies = (pointer) => {
		const dependencies = /* @__PURE__ */ new Set();
		const nodeDependencies = graph.transitiveDependencies.get(pointer);
		if (nodeDependencies?.size) for (const dependency of nodeDependencies) {
			const path$10 = jsonPointerToPath(dependency);
			const type = path$10[path$10.length - 2];
			const name = path$10[path$10.length - 1];
			if (type && name) {
				const namespace$2 = stringToNamespace(type);
				if (namespace$2 === "unknown") console.warn(`unsupported type: ${type}`);
				dependencies.add(addNamespace(namespace$2, name));
			}
		}
		return dependencies;
	};
	for (const [pointer, nodeInfo] of graph.nodes) {
		const path$10 = jsonPointerToPath(pointer);
		if (path$10[0] === "components") {
			if (path$10.length === 3) {
				if (path$10[1] === "schemas") {
					const name = path$10[path$10.length - 1];
					resourceMetadata.schemas.set(addNamespace("schema", name), {
						dependencies: getDependencies(pointer),
						deprecated: nodeInfo.deprecated ?? false
					});
				} else if (path$10[1] === "parameters") {
					const name = path$10[path$10.length - 1];
					resourceMetadata.parameters.set(addNamespace("parameter", name), {
						dependencies: getDependencies(pointer),
						deprecated: nodeInfo.deprecated ?? false
					});
				} else if (path$10[1] === "requestBodies") {
					const name = path$10[path$10.length - 1];
					resourceMetadata.requestBodies.set(addNamespace("body", name), {
						dependencies: getDependencies(pointer),
						deprecated: nodeInfo.deprecated ?? false
					});
				} else if (path$10[1] === "responses") {
					const name = path$10[path$10.length - 1];
					resourceMetadata.responses.set(addNamespace("response", name), {
						dependencies: getDependencies(pointer),
						deprecated: nodeInfo.deprecated ?? false
					});
				}
			}
			continue;
		}
		if (path$10[0] === "paths") {
			if (path$10.length === 3 && httpMethods.includes(path$10[2])) {
				const method = path$10[path$10.length - 1];
				const operationKey = createOperationKey({
					method,
					path: path$10.slice(1, -1).join("/")
				});
				resourceMetadata.operations.set(addNamespace("operation", operationKey), {
					dependencies: getDependencies(pointer),
					deprecated: nodeInfo.deprecated ?? false,
					tags: nodeInfo.tags ?? /* @__PURE__ */ new Set()
				});
			}
			continue;
		}
		if (path$10[0] === "definitions") {
			if (path$10.length === 2) {
				const name = path$10[path$10.length - 1];
				resourceMetadata.schemas.set(addNamespace("schema", name), {
					dependencies: getDependencies(pointer),
					deprecated: nodeInfo.deprecated ?? false
				});
			}
			continue;
		}
	}
	eventBuildResourceMetadata.timeEnd();
	return { resourceMetadata };
};

//#endregion
//#region src/openApi/shared/utils/schema.ts
const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

//#endregion
//#region src/openApi/shared/utils/schemaChildRelationships.ts
const childSchemaRelationships = [
	["additionalProperties", "single"],
	["allOf", "array"],
	["anyOf", "array"],
	["contains", "single"],
	["dependentSchemas", "objectMap"],
	["else", "single"],
	["if", "single"],
	["items", "singleOrArray"],
	["oneOf", "array"],
	["patternProperties", "objectMap"],
	["properties", "objectMap"],
	["propertyNames", "single"],
	["then", "single"]
];

//#endregion
//#region src/openApi/shared/utils/transforms.ts
const getSchemasObject = (spec) => {
	if (hasComponentsSchemasObject(spec)) return spec.components.schemas;
	if (hasDefinitionsObject(spec)) return spec.definitions;
};
/**
* Checks if the given spec has a valid OpenAPI 3.x components.schemas object.
* Returns true if present, false otherwise.
*/
const hasComponentsSchemasObject = (spec) => typeof spec === "object" && spec !== null && "components" in spec && typeof spec.components === "object" && spec.components !== null && "schemas" in spec.components && typeof spec.components.schemas === "object" && spec.components.schemas !== null;
/**
* Checks if the given spec has a valid OpenAPI 2.0 definitions object.
* Returns true if present, false otherwise.
*/
const hasDefinitionsObject = (spec) => typeof spec === "object" && spec !== null && "definitions" in spec && typeof spec.definitions === "object" && spec.definitions !== null;

//#endregion
//#region src/openApi/shared/transforms/utils.ts
const hasName = (obj, value) => {
	if (obj instanceof Set) return obj.has(value);
	if (obj instanceof Array) return obj.includes(value);
	return value in obj;
};
const getUniqueComponentName = ({ base, components, extraComponents }) => {
	let index = 2;
	let name = base;
	while (hasName(components, name) || extraComponents && hasName(extraComponents, name)) {
		name = `${base}${index}`;
		index += 1;
	}
	return name;
};
const isPathRootSchema = (path$10) => path$10.length === 3 && path$10[0] === "components" && path$10[1] === "schemas" || path$10.length === 2 && path$10[0] === "definitions";
const specToSchemasPointerNamespace = (spec) => {
	if (spec && typeof spec === "object") {
		if ("swagger" in spec) return "#/definitions/";
		if ("openapi" in spec) return "#/components/schemas/";
	}
	return "";
};

//#endregion
//#region src/openApi/shared/transforms/enums.ts
/**
* Generate a unique, structural signature for an enum schema for deduplication.
* Only considers 'type' and sorted 'enum' values, ignoring other fields.
*
* @param schema - The schema object to analyze
* @returns A string signature if the schema is an enum, otherwise undefined
*/
const getEnumSignature = (schema) => {
	if (!schema || typeof schema !== "object" || !("enum" in schema) || !(schema.enum instanceof Array)) return;
	const type = ("type" in schema ? schema.type : void 0) || "";
	const values = [...schema.enum].sort();
	return JSON.stringify({
		type,
		values
	});
};
/**
* Recursively walk all schemas in the OpenAPI spec, visiting every object/array
* that could contain an enum. Calls the visitor with node info for each.
*
* @param key - The key of the current node
* @param node - The current node
* @param parent - The parent node
* @param path - The path to the current node
* @param visitor - Function to call for each visited node
*/
const walkSchemas$1 = ({ key, node, parent, path: path$10, visitor }) => {
	if (!node || typeof node !== "object" || node instanceof Array) return;
	const value = node;
	if ("type" in value || "enum" in value || childSchemaRelationships.some(([keyword]) => keyword in value)) visitor({
		key,
		node,
		parent,
		path: path$10
	});
	for (const [k, v] of Object.entries(value)) if (typeof v === "object" && v !== null) if (v instanceof Array) v.forEach((item, index) => walkSchemas$1({
		key: index,
		node: item,
		parent: v,
		path: [
			...path$10,
			k,
			index
		],
		visitor
	}));
	else walkSchemas$1({
		key: k,
		node: v,
		parent: node,
		path: [...path$10, k],
		visitor
	});
};
/**
* Inlines all root/top-level enums by replacing $refs to them with the actual enum schema,
* and then removes the now-unreferenced root enums from the schemas object.
*
* @param spec - The OpenAPI spec object to transform
*/
const inlineMode = ({ spec }) => {
	const schemasObj = getSchemasObject(spec);
	if (!schemasObj) return;
	const schemasPointerNamespace = specToSchemasPointerNamespace(spec);
	const rootEnums = {};
	for (const [name, schema] of Object.entries(schemasObj)) if (getEnumSignature(schema)) rootEnums[`${schemasPointerNamespace}${name}`] = schema;
	const replaceEnumRefs = (node) => {
		if (node instanceof Array) node.forEach(replaceEnumRefs);
		else if (node && typeof node === "object") for (const [k, v] of Object.entries(node)) if (k === "$ref" && typeof v === "string" && v in rootEnums) {
			Object.assign(node, deepClone(rootEnums[v]));
			delete node["$ref"];
		} else replaceEnumRefs(v);
	};
	replaceEnumRefs(spec);
	for (const pointer of Object.keys(rootEnums)) {
		const path$10 = jsonPointerToPath(pointer);
		const name = path$10[path$10.length - 1];
		if (name) delete schemasObj[name];
	}
};
/**
* Promotes all inline enums to reusable root components (if mode is 'root'),
* deduplicates by signature, and replaces inline enums with $refs.
*
* Naming, casing, and deduplication are controlled by the enums transform config.
* Existing root enums are reused if structurally identical.
*
* @param spec - The OpenAPI spec object to transform
* @param config - The enums transform config
*/
const rootMode = ({ config, spec }) => {
	const schemasObj = getSchemasObject(spec);
	if (!schemasObj) return;
	const rootEnumSignatures = {};
	for (const [name, schema] of Object.entries(schemasObj)) {
		const signature = getEnumSignature(schema);
		if (signature) rootEnumSignatures[signature] = name;
	}
	const inlineEnums = [];
	walkSchemas$1({
		key: null,
		node: spec,
		parent: null,
		path: [],
		visitor: (nodeInfo) => {
			if (!isPathRootSchema(nodeInfo.path)) {
				const signature = getEnumSignature(nodeInfo.node);
				if (signature) inlineEnums.push({
					...nodeInfo,
					signature
				});
			}
		}
	});
	const signatureToName = {};
	const signatureToSchema = {};
	for (const { key, node, signature } of inlineEnums) {
		if (signature in signatureToName) continue;
		if (signature in rootEnumSignatures) {
			signatureToName[signature] = rootEnumSignatures[signature];
			continue;
		}
		signatureToName[signature] = getUniqueComponentName({
			base: applyNaming(typeof node === "object" && node && "title" in node && typeof node.title === "string" ? node.title : String(key), config),
			components: schemasObj,
			extraComponents: Object.values(signatureToName)
		});
		signatureToSchema[signature] = node;
	}
	for (const [signature, name] of Object.entries(signatureToName)) {
		const schema = signatureToSchema[signature];
		if (name && !(name in schemasObj) && schema && typeof schema === "object") schemasObj[name] = schema;
	}
	const schemasPointerNamespace = specToSchemasPointerNamespace(spec);
	for (const { key, parent, signature } of inlineEnums) {
		const name = signatureToName[signature];
		if (name && key != null && parent && typeof parent === "object") parent[key] = { $ref: `${schemasPointerNamespace}${name}` };
	}
};
/**
* Applies the enums transform according to the configured mode ('inline' or 'root').
*
* - In 'inline' mode, all root enums are inlined and removed.
* - In 'root' mode, all inline enums are promoted to root components and deduplicated.
*
* @param config - The enums transform config
* @param spec - The OpenAPI spec object to transform
*/
const enumsTransform = ({ config, spec }) => {
	if (config.mode === "inline") {
		inlineMode({ spec });
		return;
	}
	if (config.mode === "root") {
		rootMode({
			config,
			spec
		});
		return;
	}
};

//#endregion
//#region src/openApi/shared/transforms/propertiesRequiredByDefault.ts
/**
* Recursively walk all schemas in the OpenAPI spec, visiting every object.
* Calls the visitor with node info for each.
*
* @param key - The key of the current node
* @param node - The current node
* @param parent - The parent node
* @param path - The path to the current node
* @param visitor - Function to call for each visited node
*/
const walkSchemas = ({ key, node, parent, path: path$10, visitor }) => {
	if (!node || typeof node !== "object" || node instanceof Array) return;
	const value = node;
	if ("type" in value || childSchemaRelationships.some(([keyword]) => keyword in value)) visitor({
		key,
		node,
		parent,
		path: path$10
	});
	for (const [k, v] of Object.entries(value)) if (typeof v === "object" && v !== null) if (v instanceof Array) v.forEach((item, index) => walkSchemas({
		key: index,
		node: item,
		parent: v,
		path: [
			...path$10,
			k,
			index
		],
		visitor
	}));
	else walkSchemas({
		key: k,
		node: v,
		parent: node,
		path: [...path$10, k],
		visitor
	});
};
/**
* Applies the properties required by default transform
*
* @param spec - The OpenAPI spec object to transform
*/
const propertiesRequiredByDefaultTransform = ({ spec }) => {
	walkSchemas({
		key: null,
		node: spec,
		parent: null,
		path: [],
		visitor: (nodeInfo) => {
			if (nodeInfo.node && typeof nodeInfo.node === "object" && "type" in nodeInfo.node && nodeInfo.node.type === "object" && "properties" in nodeInfo.node && nodeInfo.node.properties && typeof nodeInfo.node.properties === "object" && !("required" in nodeInfo.node)) {
				const propKeys = Object.keys(nodeInfo.node.properties);
				if (propKeys.length > 0) nodeInfo.node.required = propKeys;
			}
		}
	});
};

//#endregion
//#region src/openApi/shared/utils/deepEqual.ts
/**
* Deep equality for JSON-compatible values (objects, arrays, primitives).
* Used to determine whether read/write pruned variants actually differ.
*/
const deepEqual = (a, b) => {
	if (a === b) return true;
	if (a === null || b === null) return a === b;
	const typeA = typeof a;
	if (typeA !== typeof b) return false;
	if (typeA !== "object") return false;
	if (Array.isArray(a) || Array.isArray(b)) {
		if (!Array.isArray(a) || !Array.isArray(b)) return false;
		if (a.length !== b.length) return false;
		for (let i = 0; i < a.length; i++) if (!deepEqual(a[i], b[i])) return false;
		return true;
	}
	const objA = a;
	const objB = b;
	const keysA = Object.keys(objA).sort();
	const keysB = Object.keys(objB).sort();
	if (keysA.length !== keysB.length) return false;
	for (let i = 0; i < keysA.length; i++) if (keysA[i] !== keysB[i]) return false;
	for (const key of keysA) if (!deepEqual(objA[key], objB[key])) return false;
	return true;
};
var deepEqual_default = deepEqual;

//#endregion
//#region src/openApi/shared/utils/graph.ts
/**
* Ensures every relevant child node (e.g., properties, items) in the graph has a `scopes` property.
* If a node does not have its own scopes, it inherits from its parent if available.
*
* @param nodes - Map of JSON Pointer to NodeInfo.
*/
const annotateChildScopes = (nodes) => {
	for (const [, nodeInfo] of nodes) {
		if (nodeInfo.scopes) continue;
		if (nodeInfo.parentPointer) {
			const parentInfo = nodes.get(nodeInfo.parentPointer);
			if (parentInfo?.scopes) nodeInfo.scopes = new Set(parentInfo.scopes);
		}
	}
};
/**
* Recursively collects all $ref dependencies in the subtree rooted at `pointer`.
*/
const collectPointerDependencies = ({ cache, graph, pointer, visited }) => {
	const cached = cache.transitiveDependencies.get(pointer);
	if (cached) return {
		subtreeDependencies: cache.subtreeDependencies.get(pointer),
		transitiveDependencies: cached
	};
	if (visited.has(pointer)) return {
		subtreeDependencies: /* @__PURE__ */ new Set(),
		transitiveDependencies: /* @__PURE__ */ new Set()
	};
	visited.add(pointer);
	if (!graph.nodes.get(pointer)) return {
		subtreeDependencies: /* @__PURE__ */ new Set(),
		transitiveDependencies: /* @__PURE__ */ new Set()
	};
	const transitiveDependencies = /* @__PURE__ */ new Set();
	const subtreeDependencies = /* @__PURE__ */ new Set();
	const nodeDependencies = graph.nodeDependencies.get(pointer);
	if (nodeDependencies) for (const depPointer of nodeDependencies) {
		transitiveDependencies.add(depPointer);
		subtreeDependencies.add(depPointer);
		const depResult = collectPointerDependencies({
			cache,
			graph,
			pointer: depPointer,
			visited
		});
		for (const dependency of depResult.transitiveDependencies) transitiveDependencies.add(dependency);
	}
	const children = cache.parentToChildren.get(pointer) ?? [];
	for (const childPointer of children) {
		let childResult = {
			subtreeDependencies: cache.subtreeDependencies.get(childPointer),
			transitiveDependencies: cache.transitiveDependencies.get(childPointer)
		};
		if (!childResult.subtreeDependencies || !childResult.transitiveDependencies) {
			childResult = collectPointerDependencies({
				cache,
				graph,
				pointer: childPointer,
				visited
			});
			cache.transitiveDependencies.set(childPointer, childResult.transitiveDependencies);
			cache.subtreeDependencies.set(childPointer, childResult.subtreeDependencies);
		}
		for (const dependency of childResult.transitiveDependencies) transitiveDependencies.add(dependency);
		for (const dependency of childResult.subtreeDependencies) subtreeDependencies.add(dependency);
	}
	cache.transitiveDependencies.set(pointer, transitiveDependencies);
	cache.subtreeDependencies.set(pointer, subtreeDependencies);
	return {
		subtreeDependencies,
		transitiveDependencies
	};
};
/**
* Propagates scopes through the graph using a worklist algorithm.
* Each node's scopes will be updated to include any scopes inherited via $ref dependencies, combinator/child relationships, and parent relationships.
* Handles cycles and deep chains efficiently.
*
* Whenever a node's scopes change, all dependents are notified:
*   - Its parent (if any)
*   - All nodes that reference it via $ref (reverse dependencies)
*   - Combinator parents (allOf/anyOf/oneOf) if applicable
*
* @param graph - The Graph structure containing nodes, dependencies, and reverseNodeDependencies.
*/
const propagateScopes = (graph) => {
	const worklist = new Set(Array.from(graph.nodes.entries()).filter(([, nodeInfo]) => nodeInfo.scopes && nodeInfo.scopes.size > 0).map(([pointer]) => pointer));
	/**
	* Notifies all dependents of a node that its scopes may have changed.
	* Dependents include:
	*   - The parent node (if any)
	*   - All nodes that reference this node via $ref (reverse dependencies)
	*   - Combinator parents (allOf/anyOf/oneOf) if this node is a combinator child
	*
	* @param pointer - The JSON pointer of the node whose dependents to notify
	* @param nodeInfo - The NodeInfo of the node
	* @param childPointer - (Optional) The pointer of the child, used to detect combinator parents
	*/
	const notifyAllDependents = (pointer, nodeInfo, childPointer) => {
		if (nodeInfo.parentPointer) worklist.add(nodeInfo.parentPointer);
		const reverseNodeDependencies = graph.reverseNodeDependencies.get(pointer);
		if (reverseNodeDependencies) for (const dependentPointer of reverseNodeDependencies) worklist.add(dependentPointer);
		if (childPointer) {
			const combinatorChildMatch = childPointer.match(/(.*)\/(allOf|anyOf|oneOf)\/\d+$/);
			if (combinatorChildMatch) {
				const combinatorParentPointer = combinatorChildMatch[1];
				if (combinatorParentPointer) worklist.add(combinatorParentPointer);
			}
		}
	};
	/**
	* Propagates scopes from a child node to its parent node.
	* If the parent's scopes change, notifies all dependents.
	*
	* @param pointer - The parent node's pointer
	* @param nodeInfo - The parent node's NodeInfo
	* @param childPointer - The child node's pointer
	*/
	const propagateChildScopes = (pointer, nodeInfo, childPointer) => {
		if (!nodeInfo?.scopes) return;
		const childInfo = graph.nodes.get(childPointer);
		if (!childInfo?.scopes) return;
		if (propagateScopesToNode(childInfo, nodeInfo)) notifyAllDependents(pointer, nodeInfo, childPointer);
	};
	while (worklist.size > 0) {
		const pointer = worklist.values().next().value;
		worklist.delete(pointer);
		const nodeInfo = graph.nodes.get(pointer);
		if (!nodeInfo) continue;
		if (!nodeInfo.scopes) nodeInfo.scopes = /* @__PURE__ */ new Set();
		const node = nodeInfo.node;
		for (const [keyword, type] of childSchemaRelationships) {
			if (!node || typeof node !== "object" || !(keyword in node)) continue;
			const value = node[keyword];
			if (type === "array" && value instanceof Array) for (let index = 0; index < value.length; index++) propagateChildScopes(pointer, nodeInfo, `${pointer}/${keyword}/${index}`);
			else if (type === "objectMap" && typeof value === "object" && value !== null && !(value instanceof Array)) for (const key of Object.keys(value)) propagateChildScopes(pointer, nodeInfo, `${pointer}/${keyword}/${key}`);
			else if (type === "single" && typeof value === "object" && value !== null) propagateChildScopes(pointer, nodeInfo, `${pointer}/${keyword}`);
			else if (type === "singleOrArray") {
				if (value instanceof Array) for (let index = 0; index < value.length; index++) propagateChildScopes(pointer, nodeInfo, `${pointer}/${keyword}/${index}`);
				else if (typeof value === "object" && value !== null) propagateChildScopes(pointer, nodeInfo, `${pointer}/${keyword}`);
			}
		}
		const nodeDependencies = graph.nodeDependencies.get(pointer);
		if (nodeDependencies) for (const depPointer of nodeDependencies) {
			const depNode = graph.nodes.get(depPointer);
			if (depNode?.scopes) {
				if (propagateScopesToNode(depNode, nodeInfo)) notifyAllDependents(pointer, nodeInfo);
			}
		}
		if (nodeInfo.parentPointer) {
			const parentInfo = graph.nodes.get(nodeInfo.parentPointer);
			if (parentInfo) {
				if (propagateScopesToNode(nodeInfo, parentInfo)) notifyAllDependents(nodeInfo.parentPointer, parentInfo);
			}
		}
	}
};
/**
* Propagates scopes from one node to another.
* Adds any scopes from fromNodeInfo to toNodeInfo that are not already present.
* Returns true if any scopes were added, false otherwise.
*
* @param fromNodeInfo - The node to propagate scopes from
* @param toNodeInfo - The node to propagate scopes to
* @returns boolean - Whether any scopes were added
*/
const propagateScopesToNode = (fromNodeInfo, toNodeInfo) => {
	if (!fromNodeInfo.scopes) return false;
	if (!toNodeInfo.scopes) toNodeInfo.scopes = /* @__PURE__ */ new Set();
	let changed = false;
	for (const scope of fromNodeInfo.scopes) if (!toNodeInfo.scopes.has(scope)) {
		toNodeInfo.scopes.add(scope);
		changed = true;
	}
	return changed;
};
/**
* Seeds each node in the graph with its local access scope(s) based on its own properties.
* - 'read' if readOnly: true
* - 'write' if writeOnly: true
* - 'normal' if node is an object property
*
* Only non-array objects are considered for scope seeding.
*
* @param nodes - Map of JSON Pointer to NodeInfo.
*/
const seedLocalScopes = (nodes) => {
	for (const [pointer, nodeInfo] of nodes) {
		const { node } = nodeInfo;
		if (typeof node !== "object" || node === null || node instanceof Array) continue;
		if ("readOnly" in node && node.readOnly === true) nodeInfo.scopes = new Set(["read"]);
		else if ("writeOnly" in node && node.writeOnly === true) nodeInfo.scopes = new Set(["write"]);
		else if (pointer.match(/\/properties\/[^/]+$/)) nodeInfo.scopes = new Set(["normal"]);
	}
};
/**
* Builds a graph of all nodes in an OpenAPI spec, indexed by normalized JSON Pointer,
* and tracks all $ref dependencies and reverse dependencies between nodes.
*
* - All keys in the returned maps are normalized JSON Pointers (RFC 6901, always starting with '#').
* - The `nodes` map allows fast lookup of any node and its parent/key context.
* - The `dependencies` map records, for each node, the set of normalized pointers it references via $ref.
* - The `reverseNodeDependencies` map records, for each node, the set of nodes that reference it via $ref.
* - After construction, all nodes will have their local and propagated scopes annotated.
*
* @param root The root object (e.g., the OpenAPI spec)
* @returns An object with:
*   - nodes: Map from normalized JSON Pointer string to NodeInfo
*   - dependencies: Map from normalized JSON Pointer string to Set of referenced normalized JSON Pointers
*   - reverseNodeDependencies: Map from normalized JSON Pointer string to Set of referencing normalized JSON Pointers
*/
const buildGraph = (root, logger) => {
	const eventBuildGraph = logger.timeEvent("build-graph");
	const graph = {
		nodeDependencies: /* @__PURE__ */ new Map(),
		nodes: /* @__PURE__ */ new Map(),
		reverseNodeDependencies: /* @__PURE__ */ new Map(),
		subtreeDependencies: /* @__PURE__ */ new Map(),
		transitiveDependencies: /* @__PURE__ */ new Map()
	};
	const walk$1 = ({ key, node, parentPointer, path: path$10 }) => {
		if (typeof node !== "object" || node === null) return;
		const pointer = pathToJsonPointer(path$10);
		let deprecated;
		let tags;
		if (typeof node === "object" && node !== null) {
			if ("deprecated" in node && typeof node.deprecated === "boolean") deprecated = Boolean(node.deprecated);
			if ("$ref" in node && typeof node.$ref === "string") {
				const refPointer = normalizeJsonPointer(node.$ref);
				if (!graph.nodeDependencies.has(pointer)) graph.nodeDependencies.set(pointer, /* @__PURE__ */ new Set());
				graph.nodeDependencies.get(pointer).add(refPointer);
			}
			if ("tags" in node && node.tags instanceof Array) tags = new Set(node.tags.filter((tag) => typeof tag === "string"));
		}
		graph.nodes.set(pointer, {
			deprecated,
			key,
			node,
			parentPointer,
			tags
		});
		if (node instanceof Array) node.forEach((item, index) => walk$1({
			key: index,
			node: item,
			parentPointer: pointer,
			path: [...path$10, index]
		}));
		else for (const [childKey, value] of Object.entries(node)) walk$1({
			key: childKey,
			node: value,
			parentPointer: pointer,
			path: [...path$10, childKey]
		});
	};
	walk$1({
		key: null,
		node: root,
		parentPointer: null,
		path: []
	});
	const cache = {
		parentToChildren: /* @__PURE__ */ new Map(),
		subtreeDependencies: /* @__PURE__ */ new Map(),
		transitiveDependencies: /* @__PURE__ */ new Map()
	};
	for (const [pointer, nodeInfo] of graph.nodes) {
		const parent = nodeInfo.parentPointer;
		if (!parent) continue;
		if (!cache.parentToChildren.has(parent)) cache.parentToChildren.set(parent, []);
		cache.parentToChildren.get(parent).push(pointer);
	}
	for (const [pointerFrom, pointers] of graph.nodeDependencies) for (const pointerTo of pointers) {
		if (!graph.reverseNodeDependencies.has(pointerTo)) graph.reverseNodeDependencies.set(pointerTo, /* @__PURE__ */ new Set());
		graph.reverseNodeDependencies.get(pointerTo).add(pointerFrom);
	}
	seedLocalScopes(graph.nodes);
	propagateScopes(graph);
	annotateChildScopes(graph.nodes);
	for (const pointer of graph.nodes.keys()) {
		const result = collectPointerDependencies({
			cache,
			graph,
			pointer,
			visited: /* @__PURE__ */ new Set()
		});
		graph.transitiveDependencies.set(pointer, result.transitiveDependencies);
		graph.subtreeDependencies.set(pointer, result.subtreeDependencies);
	}
	eventBuildGraph.timeEnd();
	return { graph };
};

//#endregion
//#region src/openApi/shared/transforms/readWrite.ts
const schemaKeys = new Set([
	"additionalProperties",
	"allOf",
	"anyOf",
	"items",
	"not",
	"oneOf",
	"patternProperties",
	"properties",
	"schema"
]);
const getComponentContext = (path$10) => {
	if (path$10.length === 3 && path$10[0] === "components") {
		const type = path$10[1];
		if (type === "parameters") return "write";
		if (type === "requestBodies") return "write";
		if (type === "responses") return "read";
		if (type === "headers") return "read";
	}
	if (path$10.length === 2) {
		const type = path$10[0];
		if (type === "parameters") return "write";
		if (type === "responses") return "read";
	}
};
/**
* Capture the original schema objects by pointer before splitting.
* This is used to safely remove only the true originals after splitting,
* even if names are swapped or overwritten by split variants.
*/
const captureOriginalSchemas = (spec, logger) => {
	const event = logger.timeEvent("capture-original-schemas");
	const originals = {};
	if (hasComponentsSchemasObject(spec)) for (const [name, obj] of Object.entries(spec.components.schemas)) originals[`#/components/schemas/${name}`] = obj;
	else if (hasDefinitionsObject(spec)) for (const [name, obj] of Object.entries(spec.definitions)) originals[`#/definitions/${name}`] = obj;
	event.timeEnd();
	return originals;
};
/**
* Inserts split schemas into the spec at the correct location (OpenAPI 3.x or 2.0).
* This function is robust to spec version and will assign all split schemas
* to either components.schemas (OAS3) or definitions (OAS2).
*
* @param spec - The OpenAPI spec object
* @param split - The split schemas (from splitSchemas)
*/
const insertSplitSchemasIntoSpec = ({ logger, spec, split }) => {
	const event = logger.timeEvent("insert-split-schemas-into-spec");
	if (hasComponentsSchemasObject(spec)) Object.assign(spec.components.schemas, split.schemas);
	else if (hasDefinitionsObject(spec)) Object.assign(spec.definitions, split.schemas);
	event.timeEnd();
};
/**
* Prunes a schema by removing all child schemas (in any structural keyword)
* that are marked with the given scope (readOnly/writeOnly), or that are $ref to a schema
* that is exclusively the excluded scope (according to the graph).
*
* Uses childSchemaRelationships for parity with graph traversal.
* Returns true if the schema itself should be removed from its parent.
*
* @param graph - The Graph containing all nodes and their scopes
* @param schema - The schema object to prune
* @param scope - The scope to exclude ('readOnly' or 'writeOnly')
* @returns boolean - Whether the schema should be removed from its parent
*/
const pruneSchemaByScope = (graph, schema, scope) => {
	if (schema && typeof schema === "object") {
		if ("$ref" in schema && typeof schema.$ref === "string") {
			const nodeInfo = graph.nodes.get(schema.$ref);
			if (nodeInfo?.scopes) {
				if (scope === "writeOnly" && nodeInfo.scopes.size === 1 && nodeInfo.scopes.has("write") || scope === "readOnly" && nodeInfo.scopes.size === 1 && nodeInfo.scopes.has("read")) {
					delete schema["$ref"];
					if (!childSchemaRelationships.some(([keyword]) => keyword in schema)) return true;
				}
			}
		}
		for (const [keyword, type] of childSchemaRelationships) {
			if (!(keyword in schema)) continue;
			const value = schema[keyword];
			if (type === "array" && value instanceof Array) {
				for (let index = value.length - 1; index >= 0; index--) {
					const item = value[index];
					if (item && typeof item === "object" && item[scope] === true) value.splice(index, 1);
					else if (pruneSchemaByScope(graph, item, scope)) value.splice(index, 1);
				}
				if (!value.length) delete schema[keyword];
			} else if (type === "objectMap" && typeof value === "object" && value !== null && !(value instanceof Array)) {
				const objMap = value;
				const removedProperties = /* @__PURE__ */ new Set();
				for (const key of Object.keys(objMap)) {
					const prop = objMap[key];
					if (prop && typeof prop === "object" && prop[scope] === true) {
						delete objMap[key];
						if (keyword === "properties") removedProperties.add(key);
					} else if (pruneSchemaByScope(graph, prop, scope)) {
						delete objMap[key];
						if (keyword === "properties") removedProperties.add(key);
					}
				}
				if (removedProperties.size > 0 && keyword === "properties" && "required" in schema && Array.isArray(schema.required)) {
					const filteredRequired = schema.required.filter((prop) => !removedProperties.has(prop));
					if (!filteredRequired.length) delete schema.required;
					else schema.required = filteredRequired;
				}
				if (!Object.keys(objMap).length) delete schema[keyword];
			} else if (type === "single" && typeof value === "object" && value !== null) {
				if (value[scope] === true) delete schema[keyword];
				else if (pruneSchemaByScope(graph, value, scope)) delete schema[keyword];
			} else if (type === "singleOrArray") {
				if (value instanceof Array) {
					for (let index = value.length - 1; index >= 0; index--) {
						const item = value[index];
						if (item && typeof item === "object" && item[scope] === true) value.splice(index, 1);
						else if (pruneSchemaByScope(graph, item, scope)) value.splice(index, 1);
					}
					if (!value.length) delete schema[keyword];
				} else if (typeof value === "object" && value !== null) {
					if (value[scope] === true) delete schema[keyword];
					else if (pruneSchemaByScope(graph, value, scope)) delete schema[keyword];
				}
			}
		}
		if (schema.type === "object" && !childSchemaRelationships.some(([keyword]) => keyword in schema)) return true;
	}
	return false;
};
/**
* Remove only the true original schemas that were split, by object identity.
* This is robust to swaps, overwrites, and name collisions.
*
* @param originalSchemas - Map of original pointers to their schema objects (captured before splitting)
* @param spec - The OpenAPI spec object
* @param split - The split mapping (from splitSchemas)
*/
const removeOriginalSplitSchemas = ({ logger, originalSchemas, spec, split }) => {
	const event = logger.timeEvent("remove-original-split-schemas");
	const schemasObj = getSchemasObject(spec);
	for (const originalPointer of Object.keys(split.mapping)) {
		const path$10 = jsonPointerToPath(originalPointer);
		const name = path$10[path$10.length - 1];
		if (typeof name === "string" && schemasObj && Object.prototype.hasOwnProperty.call(schemasObj, name) && schemasObj[name] === originalSchemas[originalPointer]) delete schemasObj[name];
	}
	event.timeEnd();
};
/**
* Splits schemas with both 'read' and 'write' scopes into read/write variants.
* Returns the new schemas and a mapping from original pointer to new variant pointers.
*
* @param config - The readWrite transform config
* @param graph - The Graph containing all nodes and their scopes
* @param spec - The OpenAPI spec object
* @returns SplitSchemas - The split schemas and pointer mappings
*/
const splitSchemas = ({ config, graph, logger, spec }) => {
	const event = logger.timeEvent("split-schemas");
	const existingNames = /* @__PURE__ */ new Set();
	const split = {
		mapping: {},
		reverseMapping: {},
		schemas: {}
	};
	const schemasPointerNamespace = specToSchemasPointerNamespace(spec);
	const schemasNamespaceSegments = schemasPointerNamespace.split("/").length - 1;
	/**
	* Extracts the schema name from pointer, but only if it's a top-level schema
	* pointer. Returns an empty string if it's a nested pointer.
	* @param pointer
	* @returns Schema's base name.
	*/
	const pointerToSchema = (pointer) => {
		if (pointer.startsWith(schemasPointerNamespace)) {
			const path$10 = jsonPointerToPath(pointer);
			if (path$10.length === schemasNamespaceSegments) return path$10[schemasNamespaceSegments - 1] || "";
		}
		return "";
	};
	for (const pointer of graph.nodes.keys()) {
		const name = pointerToSchema(pointer);
		if (name) existingNames.add(name);
	}
	for (const [pointer, nodeInfo] of graph.nodes) {
		const name = pointerToSchema(pointer);
		if (!name || !(nodeInfo.scopes?.has("read") || nodeInfo.scopes?.has("write")) || !nodeInfo.scopes?.has("normal")) continue;
		const readSchema = deepClone(nodeInfo.node);
		pruneSchemaByScope(graph, readSchema, "writeOnly");
		const readBase = applyNaming(name, config.responses);
		const readName = readBase === name ? readBase : getUniqueComponentName({
			base: readBase,
			components: existingNames
		});
		existingNames.add(readName);
		split.schemas[readName] = readSchema;
		const readPointer = `${schemasPointerNamespace}${readName}`;
		const writeSchema = deepClone(nodeInfo.node);
		pruneSchemaByScope(graph, writeSchema, "readOnly");
		const transitiveDeps = graph.transitiveDependencies.get(pointer) || /* @__PURE__ */ new Set();
		if (!Array.from(transitiveDeps).some((depPointer) => {
			const depNodeInfo = graph.nodes.get(depPointer);
			return depNodeInfo?.scopes?.has("normal") && (depNodeInfo.scopes.has("read") || depNodeInfo.scopes.has("write"));
		}) && deepEqual_default(readSchema, writeSchema) && deepEqual_default(readSchema, nodeInfo.node)) continue;
		const writeBase = applyNaming(name, config.requests);
		const writeName = writeBase === name && writeBase !== readName ? writeBase : getUniqueComponentName({
			base: writeBase,
			components: existingNames
		});
		existingNames.add(writeName);
		split.schemas[writeName] = writeSchema;
		const writePointer = `${schemasPointerNamespace}${writeName}`;
		split.mapping[pointer] = {
			read: readPointer,
			write: writePointer
		};
		split.reverseMapping[readPointer] = pointer;
		split.reverseMapping[writePointer] = pointer;
	}
	event.timeEnd();
	return split;
};
/**
* Recursively updates $ref fields in the spec to point to the correct read/write variant
* according to the current context (read/write), using the split mapping.
*
* @param spec - The OpenAPI spec object
* @param split - The split mapping (from splitSchemas)
*/
const updateRefsInSpec = ({ logger, spec, split }) => {
	const event = logger.timeEvent("update-refs-in-spec");
	const schemasPointerNamespace = specToSchemasPointerNamespace(spec);
	const walk$1 = ({ context, currentPointer, inSchema, node, path: path$10, visited = /* @__PURE__ */ new Set() }) => {
		if (node instanceof Array) node.forEach((item, index) => walk$1({
			context,
			currentPointer,
			inSchema,
			node: item,
			path: [...path$10, index],
			visited
		}));
		else if (node && typeof node === "object") {
			let nextPointer = currentPointer;
			let nextContext = context;
			if (isPathRootSchema(path$10)) {
				nextPointer = `${schemasPointerNamespace}${path$10[path$10.length - 1]}`;
				const originalPointer = split.reverseMapping[nextPointer];
				if (originalPointer) {
					const mapping = split.mapping[originalPointer];
					if (mapping?.read === nextPointer) nextContext = "read";
					else if (mapping?.write === nextPointer) nextContext = "write";
				}
			}
			const compContext = getComponentContext(path$10);
			if (compContext !== void 0) {
				for (const key in node) {
					if (!Object.prototype.hasOwnProperty.call(node, key)) continue;
					walk$1({
						context: compContext,
						currentPointer: nextPointer,
						inSchema: false,
						node: node[key],
						path: [...path$10, key],
						visited
					});
				}
				return;
			}
			for (const key in node) {
				if (!Object.prototype.hasOwnProperty.call(node, key)) continue;
				const value = node[key];
				if (!inSchema) {
					if (key === "requestBody") {
						walk$1({
							context: "write",
							currentPointer: nextPointer,
							inSchema: false,
							node: value,
							path: [...path$10, key],
							visited
						});
						continue;
					}
					if (key === "responses") {
						walk$1({
							context: "read",
							currentPointer: nextPointer,
							inSchema: false,
							node: value,
							path: [...path$10, key],
							visited
						});
						continue;
					}
					if (key === "parameters" && Array.isArray(value)) {
						value.forEach((param, index) => {
							if (param && typeof param === "object" && "schema" in param) walk$1({
								context: "write",
								currentPointer: nextPointer,
								inSchema: true,
								node: param.schema,
								path: [
									...path$10,
									key,
									index,
									"schema"
								],
								visited
							});
							if (param && typeof param === "object" && "content" in param) walk$1({
								context: "write",
								currentPointer: nextPointer,
								inSchema: false,
								node: param.content,
								path: [
									...path$10,
									key,
									index,
									"content"
								],
								visited
							});
						});
						continue;
					}
					if (key === "headers" && typeof value === "object" && value !== null) {
						for (const headerKey in value) {
							if (!Object.prototype.hasOwnProperty.call(value, headerKey)) continue;
							walk$1({
								context: "read",
								currentPointer: nextPointer,
								inSchema: false,
								node: value[headerKey],
								path: [
									...path$10,
									key,
									headerKey
								],
								visited
							});
						}
						continue;
					}
				}
				if (schemaKeys.has(key)) walk$1({
					context: nextContext,
					currentPointer: nextPointer,
					inSchema: true,
					node: value,
					path: [...path$10, key],
					visited
				});
				else if (key === "$ref" && typeof value === "string") {
					const map = split.mapping[value];
					if (map) {
						if (nextContext === "read" && map.read) node[key] = map.read;
						else if (nextContext === "write" && map.write) node[key] = map.write;
						else if (!nextContext && map.read) node[key] = map.read;
					}
				} else walk$1({
					context: nextContext,
					currentPointer: nextPointer,
					inSchema,
					node: value,
					path: [...path$10, key],
					visited
				});
			}
		}
	};
	walk$1({
		context: null,
		currentPointer: null,
		inSchema: false,
		node: spec,
		path: []
	});
	event.timeEnd();
};
/**
* Orchestrates the full read/write transform:
* - Captures original schemas
* - Splits schemas into read/write variants
* - Inserts split schemas into the spec
* - Updates $refs throughout the spec
* - Removes original schemas that were split
*
* @param config - The readWrite transform config
* @param spec - The OpenAPI spec object
*/
const readWriteTransform = ({ config, logger, spec }) => {
	const { graph } = buildGraph(spec, logger);
	const originalSchemas = captureOriginalSchemas(spec, logger);
	const split = splitSchemas({
		config,
		graph,
		logger,
		spec
	});
	insertSplitSchemasIntoSpec({
		logger,
		spec,
		split
	});
	updateRefsInSpec({
		logger,
		spec,
		split
	});
	removeOriginalSplitSchemas({
		logger,
		originalSchemas,
		spec,
		split
	});
};

//#endregion
//#region src/openApi/shared/transforms/index.ts
const transformOpenApiSpec = ({ context }) => {
	const { logger } = context;
	const eventTransformOpenApiSpec = logger.timeEvent("transform-openapi-spec");
	if (context.config.parser.transforms.enums.enabled) enumsTransform({
		config: context.config.parser.transforms.enums,
		spec: context.spec
	});
	if (context.config.parser.transforms.propertiesRequiredByDefault) propertiesRequiredByDefaultTransform({ spec: context.spec });
	if (context.config.parser.transforms.readWrite.enabled) readWriteTransform({
		config: context.config.parser.transforms.readWrite,
		logger,
		spec: context.spec
	});
	eventTransformOpenApiSpec.timeEnd();
};

//#endregion
//#region src/openApi/shared/utils/parameter.ts
const mergeParametersObjects = ({ source: source$2, target }) => {
	const result = { ...target };
	if (source$2) {
		if (source$2.cookie) if (result.cookie) result.cookie = {
			...result.cookie,
			...source$2.cookie
		};
		else result.cookie = source$2.cookie;
		if (source$2.header) if (result.header) result.header = {
			...result.header,
			...source$2.header
		};
		else result.header = source$2.header;
		if (source$2.path) if (result.path) result.path = {
			...result.path,
			...source$2.path
		};
		else result.path = source$2.path;
		if (source$2.query) if (result.query) result.query = {
			...result.query,
			...source$2.query
		};
		else result.query = source$2.query;
	}
	if (!Object.keys(result).length) return;
	return result;
};

//#endregion
//#region src/openApi/shared/utils/validator.ts
const isSimpleKey = (key) => /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(key);
const formatPath = (path$10) => path$10.map((segment, i) => {
	if (typeof segment === "number") return `[${segment}]`;
	if (i === 0) return segment;
	return isSimpleKey(segment) ? `.${segment}` : `['${segment.replace(/"/g, "\\'")}']`;
}).join("");
const formatValidatorIssue = (issue) => {
	const pathStr = formatPath(issue.path);
	const level = issue.severity === "error" ? ansi_colors.default.bold.red : ansi_colors.default.bold.yellow;
	const highlightedMessage = issue.message.replace(/`([^`]+)`/g, (_, code) => ansi_colors.default.yellow(`\`${code}\``));
	return `${level(`[${issue.severity.toUpperCase()}]`)} ${ansi_colors.default.cyan(pathStr)}: ${highlightedMessage}`;
};
const shouldPrint = ({ context, issue }) => {
	if (context.config.logs.level === "silent") return false;
	if (issue.severity === "error") return context.config.logs.level !== "warn";
	return true;
};
const handleValidatorResult = ({ context, result }) => {
	for (const issue of result.issues) if (shouldPrint({
		context,
		issue
	})) console.log(formatValidatorIssue(issue));
	if (!result.valid) process.exit(1);
};

//#endregion
//#region src/openApi/2.0.x/parser/filter.ts
/**
* Replace source spec with filtered version.
*/
const filterSpec$2 = ({ logger, operations, preserveOrder, schemas, spec }) => {
	const eventFilterSpec = logger.timeEvent("filter-spec");
	if (spec.definitions) {
		const filtered = {};
		if (preserveOrder) {
			for (const [name, source$2] of Object.entries(spec.definitions)) if (schemas.has(addNamespace("schema", name))) filtered[name] = source$2;
		} else for (const key of schemas) {
			const { name } = removeNamespace(key);
			const source$2 = spec.definitions[name];
			if (source$2) filtered[name] = source$2;
		}
		spec.definitions = filtered;
	}
	if (spec.paths) for (const entry of Object.entries(spec.paths)) {
		const path$10 = entry[0];
		const pathItem = entry[1];
		for (const method of httpMethods) {
			if (!pathItem[method]) continue;
			const key = addNamespace("operation", createOperationKey({
				method,
				path: path$10
			}));
			if (!operations.has(key)) delete pathItem[method];
		}
		if (!Object.keys(pathItem).length) delete spec.paths[path$10];
	}
	eventFilterSpec.timeEnd();
};

//#endregion
//#region src/ir/mediaType.ts
const fileLikeRegExp = /^(application\/(pdf|rtf|msword|vnd\.(ms-|openxmlformats-officedocument\.)|zip|x-(7z|tar|rar|zip|iso)|octet-stream|gzip|x-msdownload|json\+download|xml|x-yaml|x-7z-compressed|x-tar)|text\/(yaml|css|javascript)|audio\/(mpeg|wav)|video\/(mp4|x-matroska)|image\/(vnd\.adobe\.photoshop|svg\+xml))(; ?charset=[^;]+)?$/i;
const jsonMimeRegExp = /^application\/(.*\+)?json(;.*)?$/i;
const multipartFormDataMimeRegExp = /^multipart\/form-data(;.*)?$/i;
const textMimeRegExp = /^text\/[a-z0-9.+-]+(;.*)?$/i;
const xWwwFormUrlEncodedMimeRegExp = /^application\/x-www-form-urlencoded(;.*)?$/i;
const octetStreamMimeRegExp = /^application\/octet-stream(;.*)?$/i;
const isMediaTypeFileLike = ({ mediaType }) => {
	fileLikeRegExp.lastIndex = 0;
	return fileLikeRegExp.test(mediaType);
};
const mediaTypeToIrMediaType = ({ mediaType }) => {
	jsonMimeRegExp.lastIndex = 0;
	if (jsonMimeRegExp.test(mediaType)) return "json";
	multipartFormDataMimeRegExp.lastIndex = 0;
	if (multipartFormDataMimeRegExp.test(mediaType)) return "form-data";
	textMimeRegExp.lastIndex = 0;
	if (textMimeRegExp.test(mediaType)) return "text";
	xWwwFormUrlEncodedMimeRegExp.lastIndex = 0;
	if (xWwwFormUrlEncodedMimeRegExp.test(mediaType)) return "url-search-params";
	octetStreamMimeRegExp.lastIndex = 0;
	if (octetStreamMimeRegExp.test(mediaType)) return "octet-stream";
};

//#endregion
//#region src/openApi/2.0.x/parser/mediaType.ts
const contentToSchema$2 = ({ content }) => {
	const { mediaType, schema } = content;
	if (schema && "$ref" in schema) return { allOf: [{ ...schema }] };
	if (!schema) {
		if (isMediaTypeFileLike({ mediaType })) return {
			format: "binary",
			type: "string"
		};
		return;
	}
	if (schema.type === "string" && !schema.format && isMediaTypeFileLike({ mediaType })) return {
		...schema,
		format: "binary"
	};
	return schema;
};
const mediaTypeObjects$2 = ({ mimeTypes, response }) => {
	const objects = [];
	for (const mediaType of mimeTypes ?? []) objects.push({
		mediaType,
		schema: response.schema,
		type: mediaTypeToIrMediaType({ mediaType })
	});
	return objects;
};

//#endregion
//#region src/ir/pagination.ts
function getPaginationKeywordsRegExp(pagination) {
	const pattern = `^(${pagination.keywords.join("|")})$`;
	return new RegExp(pattern);
}

//#endregion
//#region src/openApi/shared/utils/discriminator.ts
const discriminatorValues = ($ref, mapping, shouldUseRefAsValue) => {
	const values = [];
	for (const name in mapping) if (mapping[name] === $ref) values.push(name);
	if (!values.length && (!shouldUseRefAsValue || shouldUseRefAsValue())) return [refToName($ref)];
	return values;
};

//#endregion
//#region src/openApi/2.0.x/parser/schema.ts
const getSchemaType$1 = ({ schema }) => {
	if (schema.type) return schema.type;
	if (schema.properties) return "object";
};
const parseSchemaJsDoc$2 = ({ irSchema, schema }) => {
	if (schema.example) irSchema.example = schema.example;
	if (schema.description) irSchema.description = schema.description;
	if (schema.title) irSchema.title = schema.title;
};
const parseSchemaMeta$2 = ({ irSchema, schema }) => {
	if (schema.default !== void 0) irSchema.default = schema.default;
	if (schema.exclusiveMaximum) {
		if (schema.maximum !== void 0) irSchema.exclusiveMaximum = schema.maximum;
	} else if (schema.maximum !== void 0) irSchema.maximum = schema.maximum;
	if (schema.exclusiveMinimum) {
		if (schema.minimum !== void 0) irSchema.exclusiveMinimum = schema.minimum;
	} else if (schema.minimum !== void 0) irSchema.minimum = schema.minimum;
	if (schema.format) irSchema.format = schema.format;
	if (schema.maxItems !== void 0) irSchema.maxItems = schema.maxItems;
	if (schema.maxLength !== void 0) irSchema.maxLength = schema.maxLength;
	if (schema.minItems !== void 0) irSchema.minItems = schema.minItems;
	if (schema.minLength !== void 0) irSchema.minLength = schema.minLength;
	if (schema.pattern) irSchema.pattern = schema.pattern;
	if (schema.readOnly) irSchema.accessScope = "read";
};
const parseArray$2 = ({ context, irSchema = {}, schema, state }) => {
	if (schema.maxItems && schema.maxItems === schema.minItems) irSchema.type = "tuple";
	else irSchema.type = "array";
	let schemaItems = [];
	if (schema.items) {
		const irItemsSchema = schemaToIrSchema$2({
			context,
			schema: schema.items,
			state
		});
		if (!schemaItems.length && schema.maxItems && schema.maxItems === schema.minItems) schemaItems = Array(schema.maxItems).fill(irItemsSchema);
		else if ("$ref" in schema.items) schemaItems.push(irItemsSchema);
		else {
			const ofArray = schema.items.allOf;
			if (ofArray && ofArray.length > 1 && !schema.items["x-nullable"]) irSchema = {
				...irSchema,
				...irItemsSchema
			};
			else schemaItems.push(irItemsSchema);
		}
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		schema: irSchema
	});
	return irSchema;
};
const parseBoolean$2 = ({ irSchema = {} }) => {
	irSchema.type = "boolean";
	return irSchema;
};
const parseNumber$2 = ({ irSchema = {}, schema }) => {
	irSchema.type = schema.type;
	return irSchema;
};
const parseObject$2 = ({ context, irSchema = {}, schema, state }) => {
	irSchema.type = "object";
	const schemaProperties = {};
	for (const name in schema.properties) {
		const property = schema.properties[name];
		if (typeof property === "boolean") {} else schemaProperties[name] = schemaToIrSchema$2({
			context,
			schema: property,
			state
		});
	}
	if (Object.keys(schemaProperties).length) irSchema.properties = schemaProperties;
	if (schema.additionalProperties === void 0) {
		if (!irSchema.properties) irSchema.additionalProperties = { type: "unknown" };
	} else if (typeof schema.additionalProperties === "boolean") {
		if (!(state.inAllOf && schema.additionalProperties === false && (!schema.properties || !Object.keys(schema.properties).length))) irSchema.additionalProperties = { type: schema.additionalProperties ? "unknown" : "never" };
	} else irSchema.additionalProperties = schemaToIrSchema$2({
		context,
		schema: schema.additionalProperties,
		state
	});
	if (schema.required) irSchema.required = schema.required;
	return irSchema;
};
const parseString$2 = ({ irSchema = {} }) => {
	irSchema.type = "string";
	return irSchema;
};
const parseExtensions$2 = ({ source: source$2, target }) => {
	for (const key in source$2) if (key.startsWith("x-")) target[key] = source$2[key];
};
const initIrSchema$2 = ({ schema }) => {
	const irSchema = {};
	parseSchemaJsDoc$2({
		irSchema,
		schema
	});
	parseExtensions$2({
		source: schema,
		target: irSchema
	});
	return irSchema;
};
const parseAllOf$2 = ({ context, schema, state }) => {
	let irSchema = initIrSchema$2({ schema });
	const schemaItems = [];
	const schemaType = getSchemaType$1({ schema });
	const compositionSchemas = schema.allOf;
	for (const compositionSchema of compositionSchemas) {
		const originalInAllOf = state.inAllOf;
		if (!("$ref" in compositionSchema)) state.inAllOf = true;
		const irCompositionSchema = schemaToIrSchema$2({
			context,
			schema: compositionSchema,
			state
		});
		state.inAllOf = originalInAllOf;
		if (state.inAllOf === void 0) delete state.inAllOf;
		if (schema.required) if (irCompositionSchema.required) irCompositionSchema.required = [...irCompositionSchema.required, ...schema.required];
		else irCompositionSchema.required = schema.required;
		schemaItems.push(irCompositionSchema);
		if (compositionSchema.$ref) {
			const ref$41 = context.resolveRef(compositionSchema.$ref);
			if (ref$41.discriminator && state.$ref) {
				const valueSchemas = discriminatorValues(state.$ref).map((value) => ({
					const: value,
					type: "string"
				}));
				const irDiscriminatorSchema = {
					properties: { [ref$41.discriminator]: valueSchemas.length > 1 ? {
						items: valueSchemas,
						logicalOperator: "or"
					} : valueSchemas[0] },
					type: "object"
				};
				if (ref$41.required?.includes(ref$41.discriminator)) irDiscriminatorSchema.required = [ref$41.discriminator];
				schemaItems.push(irDiscriminatorSchema);
			}
		}
	}
	if (schemaType === "object") {
		const irObjectSchema = parseOneType$2({
			context,
			schema: {
				...schema,
				type: "object"
			},
			state
		});
		if (irObjectSchema.properties) {
			for (const requiredProperty of irObjectSchema.required ?? []) if (!irObjectSchema.properties[requiredProperty]) for (const compositionSchema of compositionSchemas) {
				const finalCompositionSchema = compositionSchema.$ref ? context.resolveRef(compositionSchema.$ref) : compositionSchema;
				if (getSchemaType$1({ schema: finalCompositionSchema }) === "object") {
					const irCompositionSchema = parseOneType$2({
						context,
						schema: {
							...finalCompositionSchema,
							type: "object"
						},
						state
					});
					if (irCompositionSchema.properties?.[requiredProperty]) {
						irObjectSchema.properties[requiredProperty] = irCompositionSchema.properties[requiredProperty];
						break;
					}
				}
			}
			schemaItems.push(irObjectSchema);
		}
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		logicalOperator: "and",
		mutateSchemaOneItem: true,
		schema: irSchema
	});
	if (schema["x-nullable"]) {
		const nestedItems = [{ type: "null" }];
		if (schemaItems.length) nestedItems.unshift(irSchema);
		irSchema = {
			items: nestedItems,
			logicalOperator: "or"
		};
		if (nestedItems[0].deprecated) irSchema.deprecated = nestedItems[0].deprecated;
		if (nestedItems[0].description) irSchema.description = nestedItems[0].description;
	}
	return irSchema;
};
const parseEnum$2 = ({ context, schema, state }) => {
	let irSchema = initIrSchema$2({ schema });
	irSchema.type = "enum";
	const schemaItems = [];
	for (const [index, enumValue] of schema.enum.entries()) {
		const typeOfEnumValue = typeof enumValue;
		let enumType;
		if (typeOfEnumValue === "string" || typeOfEnumValue === "number" || typeOfEnumValue === "boolean") enumType = typeOfEnumValue;
		else if (typeOfEnumValue === "object" && Array.isArray(enumValue)) enumType = "array";
		else if (enumValue === null) {
			if (schema["x-nullable"]) enumType = "null";
		} else console.warn("ðŸš¨", `unhandled "${typeOfEnumValue}" typeof value "${enumValue}" for enum`, schema.enum);
		if (!enumType) continue;
		const irTypeSchema = parseOneType$2({
			context,
			schema: {
				description: schema["x-enum-descriptions"]?.[index],
				title: schema["x-enum-varnames"]?.[index] ?? schema["x-enumNames"]?.[index],
				type: enumType === "null" ? "string" : enumType
			},
			state
		});
		irTypeSchema.const = enumValue;
		if (enumType === "null") irTypeSchema.type = enumType;
		if (irTypeSchema.type === "array") irTypeSchema.type = "tuple";
		schemaItems.push(irTypeSchema);
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		schema: irSchema
	});
	return irSchema;
};
const parseRef$2 = ({ context, schema, state }) => {
	const irSchema = {};
	if (!isTopLevelComponentRef(schema.$ref)) {
		if (!state.circularReferenceTracker.has(schema.$ref)) {
			const refSchema = context.resolveRef(schema.$ref);
			const originalRef = state.$ref;
			state.$ref = schema.$ref;
			const irSchema$1 = schemaToIrSchema$2({
				context,
				schema: refSchema,
				state
			});
			state.$ref = originalRef;
			return irSchema$1;
		}
	}
	irSchema.$ref = decodeURI(schema.$ref);
	irSchema.$ref = irSchema.$ref.replace(/#\/definitions\/([^/]+)/g, "#/components/schemas/$1");
	if (!state.circularReferenceTracker.has(schema.$ref)) {
		const refSchema = context.resolveRef(schema.$ref);
		const originalRef = state.$ref;
		state.$ref = schema.$ref;
		schemaToIrSchema$2({
			context,
			schema: refSchema,
			state
		});
		state.$ref = originalRef;
	}
	return irSchema;
};
const parseNullableType$1 = ({ context, irSchema, schema, state }) => {
	if (!irSchema) irSchema = initIrSchema$2({ schema });
	const typeIrSchema = {};
	parseSchemaMeta$2({
		irSchema: typeIrSchema,
		schema
	});
	if (typeIrSchema.default === null) delete typeIrSchema.default;
	irSchema = addItemsToSchema({
		items: [parseOneType$2({
			context,
			irSchema: typeIrSchema,
			schema,
			state
		}), { type: "null" }],
		schema: irSchema
	});
	return irSchema;
};
const parseType$2 = ({ context, schema, state }) => {
	const irSchema = initIrSchema$2({ schema });
	parseSchemaMeta$2({
		irSchema,
		schema
	});
	const type = getSchemaType$1({ schema });
	if (!type) return irSchema;
	if (schema["x-nullable"]) return parseNullableType$1({
		context,
		irSchema,
		schema: {
			...schema,
			type
		},
		state
	});
	return parseOneType$2({
		context,
		irSchema,
		schema: {
			...schema,
			type
		},
		state
	});
};
const parseOneType$2 = ({ context, irSchema, schema, state }) => {
	if (!irSchema) {
		irSchema = initIrSchema$2({ schema });
		parseSchemaMeta$2({
			irSchema,
			schema
		});
	}
	switch (schema.type) {
		case "array": return parseArray$2({
			context,
			irSchema,
			schema,
			state
		});
		case "boolean": return parseBoolean$2({
			context,
			irSchema,
			schema,
			state
		});
		case "integer":
		case "number": return parseNumber$2({
			context,
			irSchema,
			schema,
			state
		});
		case "object": return parseObject$2({
			context,
			irSchema,
			schema,
			state
		});
		case "string": return parseString$2({
			context,
			irSchema,
			schema,
			state
		});
		default: return parseUnknown$2({
			context,
			irSchema,
			schema
		});
	}
};
const parseUnknown$2 = ({ irSchema, schema }) => {
	if (!irSchema) irSchema = initIrSchema$2({ schema });
	irSchema.type = "unknown";
	parseSchemaMeta$2({
		irSchema,
		schema
	});
	return irSchema;
};
const schemaToIrSchema$2 = ({ context, schema, state }) => {
	if (!state) state = { circularReferenceTracker: /* @__PURE__ */ new Set() };
	if (state.$ref) state.circularReferenceTracker.add(state.$ref);
	if (schema.$ref) return parseRef$2({
		context,
		schema,
		state
	});
	if (schema.enum) return parseEnum$2({
		context,
		schema,
		state
	});
	if (schema.allOf) return parseAllOf$2({
		context,
		schema,
		state
	});
	if (schema.type || schema.properties) return parseType$2({
		context,
		schema,
		state
	});
	return parseUnknown$2({
		context,
		schema
	});
};
const parseSchema$2 = ({ $ref, context, schema }) => {
	if (!context.ir.components) context.ir.components = {};
	if (!context.ir.components.schemas) context.ir.components.schemas = {};
	context.ir.components.schemas[refToName($ref)] = schemaToIrSchema$2({
		context,
		schema,
		state: {
			$ref,
			circularReferenceTracker: /* @__PURE__ */ new Set()
		}
	});
};

//#endregion
//#region src/openApi/2.0.x/parser/pagination.ts
const isPaginationType$2 = (schemaType) => schemaType === "boolean" || schemaType === "integer" || schemaType === "number" || schemaType === "string";
const paginationField$2 = ({ context, name, schema }) => {
	if (getPaginationKeywordsRegExp(context.config.parser.pagination).test(name)) return true;
	if ("$ref" in schema) {
		const ref$41 = context.resolveRef(schema.$ref ?? "");
		if ("in" in ref$41 && ref$41.in) return paginationField$2({
			context,
			name,
			schema: "schema" in ref$41 ? ref$41.schema : {
				...ref$41,
				in: void 0
			}
		});
		return paginationField$2({
			context,
			name,
			schema: ref$41
		});
	}
	if ("in" in schema) {
		if (!schema.in) return false;
		return paginationField$2({
			context,
			name,
			schema: "schema" in schema ? schema.schema : {
				...schema,
				in: void 0
			}
		});
	}
	for (const name$1 in schema.properties) if (getPaginationKeywordsRegExp(context.config.parser.pagination).test(name$1)) {
		const property = schema.properties[name$1];
		if (typeof property !== "boolean" && !("$ref" in property)) {
			if (isPaginationType$2(getSchemaType$1({ schema: property }))) return name$1;
		}
	}
	for (const allOf of schema.allOf ?? []) {
		const pagination = paginationField$2({
			context,
			name,
			schema: allOf
		});
		if (pagination) return pagination;
	}
	return false;
};

//#endregion
//#region src/openApi/2.0.x/parser/operation.ts
const parseOperationJsDoc$2 = ({ irOperation, operation }) => {
	if (operation.deprecated !== void 0) irOperation.deprecated = operation.deprecated;
	if (operation.description) irOperation.description = operation.description;
	if (operation.summary) irOperation.summary = operation.summary;
	if (operation.tags?.length) irOperation.tags = operation.tags;
};
const initIrOperation$2 = ({ context, method, operation, path: path$10, state }) => {
	const irOperation = {
		id: operationToId({
			context,
			id: operation.operationId,
			method,
			path: path$10,
			state
		}),
		method,
		path: path$10
	};
	if (operation.operationId) irOperation.operationId = operation.operationId;
	parseOperationJsDoc$2({
		irOperation,
		operation
	});
	parseExtensions$2({
		source: operation,
		target: irOperation
	});
	return irOperation;
};
const operationToIrOperation$2 = ({ context, method, operation, path: path$10, securitySchemesMap, state }) => {
	const irOperation = initIrOperation$2({
		context,
		method,
		operation,
		path: path$10,
		state
	});
	if (operation.parameters) irOperation.parameters = operation.parameters;
	let isRequestBodyRequired = false;
	const requestBodyObject = {
		mediaType: "",
		schema: {
			properties: {},
			required: [],
			type: "object"
		}
	};
	const requestBodyObjectRequired = [];
	const hasBodyParameter = operation.requestBody?.some((param) => {
		return ("$ref" in param ? context.resolveRef(param.$ref) : param).in === "body";
	});
	for (const requestBodyParameter of operation.requestBody ?? []) {
		const requestBody = "$ref" in requestBodyParameter ? context.resolveRef(requestBodyParameter.$ref) : requestBodyParameter;
		const schema = requestBody.in === "body" ? requestBody.schema : {
			...requestBody,
			format: requestBody.type === "file" ? "binary" : requestBody.format,
			required: void 0,
			type: requestBody.type === "file" ? "string" : requestBody.type
		};
		let mimeTypes = operation.consumes;
		if (!mimeTypes && hasBodyParameter && requestBody.in === "body") mimeTypes = ["application/json"];
		const contents = mediaTypeObjects$2({
			mimeTypes,
			response: { schema }
		});
		const content = contents.find((content$1) => content$1.type === "json") || contents[0];
		if (content) {
			const pagination = paginationField$2({
				context,
				name: "",
				schema: content.schema && "$ref" in content.schema ? {
					allOf: [{ ...content.schema }],
					description: requestBody.description
				} : {
					description: requestBody.description,
					...content.schema
				}
			});
			const irSchema = schemaToIrSchema$2({
				context,
				schema: "$ref" in requestBody ? {
					allOf: [{
						...requestBody,
						$ref: requestBody.$ref,
						required: [],
						type: "string"
					}],
					description: requestBody.description
				} : content.schema && "$ref" in content.schema ? {
					allOf: [{ ...content.schema }],
					description: requestBody.description
				} : {
					description: requestBody.description,
					...content.schema
				},
				state: void 0
			});
			requestBodyObject.mediaType = content.mediaType;
			if (requestBody.in === "body") requestBodyObject.schema = irSchema;
			else {
				requestBodyObject.schema.properties[requestBody.name] = irSchema;
				if (requestBody.required) requestBodyObjectRequired.push(requestBody.name);
			}
			if (pagination) requestBodyObject.pagination = pagination;
			if (content.type) requestBodyObject.type = content.type;
		}
		if (requestBody.required) isRequestBodyRequired = true;
	}
	if (requestBodyObject.mediaType) {
		if (requestBodyObjectRequired.length) requestBodyObject.schema.required = requestBodyObjectRequired;
		irOperation.body = requestBodyObject;
		if (isRequestBodyRequired) irOperation.body.required = isRequestBodyRequired;
	}
	for (const name in operation.responses) {
		if (!irOperation.responses) irOperation.responses = {};
		const response = operation.responses[name];
		const responseObject = "$ref" in response ? context.resolveRef(response.$ref) : response;
		const contents = mediaTypeObjects$2({
			mimeTypes: operation.produces ? operation.produces : ["application/json"],
			response: responseObject
		});
		const content = contents.find((content$1) => content$1.type === "json") || contents[0];
		if (content) irOperation.responses[name] = {
			mediaType: content.mediaType,
			schema: schemaToIrSchema$2({
				context,
				schema: {
					description: responseObject.description,
					...contentToSchema$2({ content })
				},
				state: void 0
			})
		};
		else irOperation.responses[name] = { schema: {
			description: responseObject.description,
			type: name === "204" ? "void" : "unknown"
		} };
	}
	if (operation.security) {
		const securitySchemeObjects = /* @__PURE__ */ new Map();
		for (const securityRequirementObject of operation.security) for (const name in securityRequirementObject) {
			const securitySchemeObject = securitySchemesMap.get(name);
			if (!securitySchemeObject) continue;
			let irSecuritySchemeObject;
			if (securitySchemeObject.type === "apiKey") irSecuritySchemeObject = securitySchemeObject;
			if (securitySchemeObject.type === "basic") irSecuritySchemeObject = {
				description: securitySchemeObject.description,
				scheme: "basic",
				type: "http"
			};
			if (securitySchemeObject.type === "oauth2") {
				irSecuritySchemeObject = {
					description: securitySchemeObject.description,
					flows: {},
					type: "oauth2"
				};
				switch (securitySchemeObject.flow) {
					case "accessCode":
						irSecuritySchemeObject.flows.authorizationCode = {
							authorizationUrl: securitySchemeObject.authorizationUrl,
							scopes: securitySchemeObject.scopes,
							tokenUrl: securitySchemeObject.tokenUrl
						};
						break;
					case "application":
						irSecuritySchemeObject.flows.clientCredentials = {
							scopes: securitySchemeObject.scopes,
							tokenUrl: securitySchemeObject.tokenUrl
						};
						break;
					case "implicit":
						irSecuritySchemeObject.flows.implicit = {
							authorizationUrl: securitySchemeObject.authorizationUrl,
							scopes: securitySchemeObject.scopes
						};
						break;
					case "password":
						irSecuritySchemeObject.flows.password = {
							scopes: securitySchemeObject.scopes,
							tokenUrl: securitySchemeObject.tokenUrl
						};
						break;
				}
			}
			if (!irSecuritySchemeObject) continue;
			securitySchemeObjects.set(name, irSecuritySchemeObject);
		}
		if (securitySchemeObjects.size) irOperation.security = Array.from(securitySchemeObjects.values());
	}
	return irOperation;
};
const parsePathOperation$2 = ({ context, method, operation, path: path$10, securitySchemesMap, state }) => {
	if (!context.ir.paths) context.ir.paths = {};
	if (!context.ir.paths[path$10]) context.ir.paths[path$10] = {};
	context.ir.paths[path$10][method] = operationToIrOperation$2({
		context,
		method,
		operation,
		path: path$10,
		securitySchemesMap,
		state
	});
};

//#endregion
//#region src/openApi/2.0.x/parser/parameter.ts
/**
* Returns default parameter `explode` based on value of `collectionFormat`.
*/
const defaultExplode$2 = (collectionFormat) => {
	switch (collectionFormat) {
		case "multi": return true;
		case "csv":
		case "pipes":
		case "ssv":
		case "tsv":
		default: return false;
	}
};
/**
* Returns default parameter `style` based on value of `in`.
*/
const defaultStyle$2 = (_in) => {
	switch (_in) {
		case "header":
		case "path": return "simple";
		case "query":
		default: return "form";
	}
};
const parametersArrayToObject$2 = ({ context, operation, parameters }) => {
	if (!parameters || !Object.keys(parameters).length) return;
	const parametersObject = {};
	for (const parameterOrReference of parameters) {
		const parameter = "$ref" in parameterOrReference ? context.dereference(parameterOrReference) : parameterOrReference;
		if (parameter.in === "body" || parameter.in === "formData") {
			if (!operation.requestBody) operation.requestBody = [];
			operation.requestBody.push(parameter);
			continue;
		}
		if (!parametersObject[parameter.in]) parametersObject[parameter.in] = {};
		parametersObject[parameter.in][parameter.name.toLocaleLowerCase()] = parameterToIrParameter$2({
			$ref: `#/todo/real/path/to/parameter/${parameter.name}`,
			context,
			parameter
		});
	}
	return parametersObject;
};
const parameterToIrParameter$2 = ({ $ref, context, parameter }) => {
	const schema = parameter;
	const finalSchema = schema && "$ref" in schema ? {
		allOf: [{
			...schema,
			$ref: schema.$ref,
			required: Array.isArray(schema.required) ? schema.required : [],
			type: schema.type
		}],
		description: parameter.description
	} : {
		description: parameter.description,
		...schema,
		required: Array.isArray(schema.required) ? schema.required : [],
		type: schema.type
	};
	const pagination = paginationField$2({
		context,
		name: parameter.name,
		schema: finalSchema
	});
	const style = defaultStyle$2(parameter.in);
	const irParameter = {
		allowReserved: false,
		explode: defaultExplode$2(parameter.collectionFormat),
		location: parameter.in,
		name: parameter.name,
		schema: schemaToIrSchema$2({
			context,
			schema: finalSchema,
			state: {
				$ref,
				circularReferenceTracker: /* @__PURE__ */ new Set()
			}
		}),
		style
	};
	if (parameter.description) irParameter.description = parameter.description;
	if (pagination) irParameter.pagination = pagination;
	if (parameter.required) irParameter.required = parameter.required;
	parseExtensions$2({
		source: parameter,
		target: irParameter
	});
	return irParameter;
};

//#endregion
//#region src/openApi/2.0.x/parser/server.ts
const parseServers$2 = ({ context }) => {
	let schemes = context.spec.schemes ?? [];
	let host = context.spec.host ?? "";
	const path$10 = context.spec.basePath ?? "";
	for (const input of context.config.input) if (typeof input.path === "string") {
		const url = parseUrl(input.path);
		if (!schemes.length) {
			if (url.protocol) schemes = [url.protocol];
		}
		if (!host) host = `${url.host}${url.port ? `:${url.port}` : ""}`;
	}
	if (!schemes.length) schemes = [""];
	const servers = schemes.map((scheme) => `${scheme ? `${scheme}://` : ""}${host}${path$10}`).filter(Boolean);
	if (servers.length) context.ir.servers = servers.map((url) => ({ url }));
};

//#endregion
//#region src/openApi/2.0.x/parser/validate.ts
const validateOpenApiSpec$2 = (spec, logger) => {
	const eventValidate = logger.timeEvent("validate");
	const issues = [];
	const operationIds = /* @__PURE__ */ new Map();
	if (spec.paths) for (const entry of Object.entries(spec.paths)) {
		const path$10 = entry[0];
		const pathItem = entry[1];
		for (const method of httpMethods) {
			if (method === "trace") continue;
			const operation = pathItem[method];
			if (!operation) continue;
			const operationKey = createOperationKey({
				method,
				path: path$10
			});
			if (operation.operationId) if (!operationIds.has(operation.operationId)) operationIds.set(operation.operationId, operationKey);
			else issues.push({
				code: "duplicate_key",
				context: {
					key: "operationId",
					value: operation.operationId
				},
				message: "Duplicate `operationId` found. Each `operationId` must be unique.",
				path: [
					"paths",
					path$10,
					method,
					"operationId"
				],
				severity: "error"
			});
		}
	}
	eventValidate.timeEnd();
	return {
		issues,
		valid: !issues.some((issue) => issue.severity === "error")
	};
};

//#endregion
//#region src/openApi/2.0.x/parser/index.ts
const parseV2_0_X = (context) => {
	if (context.config.parser.validate_EXPERIMENTAL) handleValidatorResult({
		context,
		result: validateOpenApiSpec$2(context.spec, context.logger)
	});
	if (hasFilters(context.config.parser.filters)) {
		const filters = createFilters(context.config.parser.filters, context.spec, context.logger);
		const { graph } = buildGraph(context.spec, context.logger);
		const { resourceMetadata } = buildResourceMetadata(graph, context.logger);
		filterSpec$2({
			...createFilteredDependencies({
				filters,
				logger: context.logger,
				resourceMetadata
			}),
			logger: context.logger,
			preserveOrder: filters.preserveOrder,
			spec: context.spec
		});
	}
	transformOpenApiSpec({ context });
	const state = { ids: /* @__PURE__ */ new Map() };
	const securitySchemesMap = /* @__PURE__ */ new Map();
	for (const name in context.spec.securityDefinitions) {
		const securitySchemeObject = context.spec.securityDefinitions[name];
		securitySchemesMap.set(name, securitySchemeObject);
	}
	if (context.spec.definitions) for (const name in context.spec.definitions) {
		const $ref = `#/definitions/${name}`;
		const schema = context.spec.definitions[name];
		parseSchema$2({
			$ref,
			context,
			schema
		});
	}
	parseServers$2({ context });
	for (const path$10 in context.spec.paths) {
		if (path$10.startsWith("x-")) continue;
		const pathItem = context.spec.paths[path$10];
		const finalPathItem = pathItem.$ref ? {
			...context.resolveRef(pathItem.$ref),
			...pathItem
		} : pathItem;
		const commonOperation = {
			consumes: context.spec.consumes,
			produces: context.spec.produces,
			responses: {},
			security: context.spec.security
		};
		const operationArgs = {
			context,
			operation: {
				...commonOperation,
				parameters: parametersArrayToObject$2({
					context,
					operation: commonOperation,
					parameters: finalPathItem.parameters
				})
			},
			path: path$10,
			securitySchemesMap,
			state
		};
		if (finalPathItem.delete) {
			const parameters = mergeParametersObjects({
				source: parametersArrayToObject$2({
					context,
					operation: finalPathItem.delete,
					parameters: finalPathItem.delete.parameters
				}),
				target: operationArgs.operation.parameters
			});
			parsePathOperation$2({
				...operationArgs,
				method: "delete",
				operation: {
					...operationArgs.operation,
					...finalPathItem.delete,
					parameters
				}
			});
		}
		if (finalPathItem.get) {
			const parameters = mergeParametersObjects({
				source: parametersArrayToObject$2({
					context,
					operation: finalPathItem.get,
					parameters: finalPathItem.get.parameters
				}),
				target: operationArgs.operation.parameters
			});
			parsePathOperation$2({
				...operationArgs,
				method: "get",
				operation: {
					...operationArgs.operation,
					...finalPathItem.get,
					parameters
				}
			});
		}
		if (finalPathItem.head) {
			const parameters = mergeParametersObjects({
				source: parametersArrayToObject$2({
					context,
					operation: finalPathItem.head,
					parameters: finalPathItem.head.parameters
				}),
				target: operationArgs.operation.parameters
			});
			parsePathOperation$2({
				...operationArgs,
				method: "head",
				operation: {
					...operationArgs.operation,
					...finalPathItem.head,
					parameters
				}
			});
		}
		if (finalPathItem.options) {
			const parameters = mergeParametersObjects({
				source: parametersArrayToObject$2({
					context,
					operation: finalPathItem.options,
					parameters: finalPathItem.options.parameters
				}),
				target: operationArgs.operation.parameters
			});
			parsePathOperation$2({
				...operationArgs,
				method: "options",
				operation: {
					...operationArgs.operation,
					...finalPathItem.options,
					parameters
				}
			});
		}
		if (finalPathItem.patch) {
			const parameters = mergeParametersObjects({
				source: parametersArrayToObject$2({
					context,
					operation: finalPathItem.patch,
					parameters: finalPathItem.patch.parameters
				}),
				target: operationArgs.operation.parameters
			});
			parsePathOperation$2({
				...operationArgs,
				method: "patch",
				operation: {
					...operationArgs.operation,
					...finalPathItem.patch,
					parameters
				}
			});
		}
		if (finalPathItem.post) {
			const parameters = mergeParametersObjects({
				source: parametersArrayToObject$2({
					context,
					operation: finalPathItem.post,
					parameters: finalPathItem.post.parameters
				}),
				target: operationArgs.operation.parameters
			});
			parsePathOperation$2({
				...operationArgs,
				method: "post",
				operation: {
					...operationArgs.operation,
					...finalPathItem.post,
					parameters
				}
			});
		}
		if (finalPathItem.put) {
			const parameters = mergeParametersObjects({
				source: parametersArrayToObject$2({
					context,
					operation: finalPathItem.put,
					parameters: finalPathItem.put.parameters
				}),
				target: operationArgs.operation.parameters
			});
			parsePathOperation$2({
				...operationArgs,
				method: "put",
				operation: {
					...operationArgs.operation,
					...finalPathItem.put,
					parameters
				}
			});
		}
	}
};

//#endregion
//#region src/openApi/3.0.x/parser/filter.ts
/**
* Replace source spec with filtered version.
*/
const filterSpec$1 = ({ logger, operations, parameters, preserveOrder, requestBodies, responses, schemas, spec }) => {
	const eventFilterSpec = logger.timeEvent("filter-spec");
	if (spec.components) {
		if (spec.components.parameters) {
			const filtered = {};
			if (preserveOrder) {
				for (const [name, source$2] of Object.entries(spec.components.parameters)) if (parameters.has(addNamespace("parameter", name))) filtered[name] = source$2;
			} else for (const key of parameters) {
				const { name } = removeNamespace(key);
				const source$2 = spec.components.parameters[name];
				if (source$2) filtered[name] = source$2;
			}
			spec.components.parameters = filtered;
		}
		if (spec.components.requestBodies) {
			const filtered = {};
			if (preserveOrder) {
				for (const [name, source$2] of Object.entries(spec.components.requestBodies)) if (requestBodies.has(addNamespace("body", name))) filtered[name] = source$2;
			} else for (const key of requestBodies) {
				const { name } = removeNamespace(key);
				const source$2 = spec.components.requestBodies[name];
				if (source$2) filtered[name] = source$2;
			}
			spec.components.requestBodies = filtered;
		}
		if (spec.components.responses) {
			const filtered = {};
			if (preserveOrder) {
				for (const [name, source$2] of Object.entries(spec.components.responses)) if (responses.has(addNamespace("response", name))) filtered[name] = source$2;
			} else for (const key of responses) {
				const { name } = removeNamespace(key);
				const source$2 = spec.components.responses[name];
				if (source$2) filtered[name] = source$2;
			}
			spec.components.responses = filtered;
		}
		if (spec.components.schemas) {
			const filtered = {};
			if (preserveOrder) {
				for (const [name, source$2] of Object.entries(spec.components.schemas)) if (schemas.has(addNamespace("schema", name))) filtered[name] = source$2;
			} else for (const key of schemas) {
				const { name } = removeNamespace(key);
				const source$2 = spec.components.schemas[name];
				if (source$2) filtered[name] = source$2;
			}
			spec.components.schemas = filtered;
		}
	}
	if (spec.paths) for (const entry of Object.entries(spec.paths)) {
		const path$10 = entry[0];
		const pathItem = entry[1];
		for (const method of httpMethods) {
			if (!pathItem[method]) continue;
			const key = addNamespace("operation", createOperationKey({
				method,
				path: path$10
			}));
			if (!operations.has(key)) delete pathItem[method];
		}
		if (!Object.keys(pathItem).length) delete spec.paths[path$10];
	}
	eventFilterSpec.timeEnd();
};

//#endregion
//#region src/openApi/3.0.x/parser/mediaType.ts
const contentToSchema$1 = ({ content }) => {
	const { mediaType, schema } = content;
	if (schema && "$ref" in schema) return { allOf: [{ ...schema }] };
	if (!schema) {
		if (isMediaTypeFileLike({ mediaType })) return {
			format: "binary",
			type: "string"
		};
		return;
	}
	if (schema.type === "string" && !schema.format && isMediaTypeFileLike({ mediaType })) return {
		...schema,
		format: "binary"
	};
	return schema;
};
const mediaTypeObjects$1 = ({ content }) => {
	const objects = [];
	for (const mediaType in content) objects.push({
		mediaType,
		schema: content[mediaType].schema,
		type: mediaTypeToIrMediaType({ mediaType })
	});
	return objects;
};

//#endregion
//#region src/openApi/3.0.x/parser/schema.ts
const getSchemaType = ({ schema }) => {
	if (schema.type) return schema.type;
	if (schema.properties) return "object";
};
/**
* Recursively finds discriminators in a schema, including nested allOf compositions.
* This is needed when a schema extends another schema via allOf, and that parent
* schema is itself an allOf composition with discriminators in inline schemas.
*/
const findDiscriminatorsInSchema$1 = ({ context, discriminators = [], schema }) => {
	if (schema.discriminator) discriminators.push({
		discriminator: schema.discriminator,
		oneOf: schema.oneOf
	});
	if (schema.allOf) for (const compositionSchema of schema.allOf) {
		let resolvedSchema;
		if ("$ref" in compositionSchema) resolvedSchema = context.resolveRef(compositionSchema.$ref);
		else resolvedSchema = compositionSchema;
		findDiscriminatorsInSchema$1({
			context,
			discriminators,
			schema: resolvedSchema
		});
	}
	return discriminators;
};
/**
* Gets the discriminator value for a schema.
* Returns only the schema's own discriminator value, not child values.
*/
const getAllDiscriminatorValues$1 = ({ discriminator, schemaRef }) => {
	const values = [];
	for (const [value, mappedSchemaRef] of Object.entries(discriminator.mapping || {})) if (mappedSchemaRef === schemaRef) values.push(value);
	return values;
};
const parseSchemaJsDoc$1 = ({ irSchema, schema }) => {
	if (schema.deprecated !== void 0) irSchema.deprecated = schema.deprecated;
	if (schema.example) irSchema.example = schema.example;
	if (schema.description) irSchema.description = schema.description;
	if (schema.title) irSchema.title = schema.title;
};
const parseSchemaMeta$1 = ({ irSchema, schema }) => {
	if (schema.default !== void 0) irSchema.default = schema.default;
	if (schema.exclusiveMaximum) {
		if (schema.maximum !== void 0) irSchema.exclusiveMaximum = schema.maximum;
	} else if (schema.maximum !== void 0) irSchema.maximum = schema.maximum;
	if (schema.exclusiveMinimum) {
		if (schema.minimum !== void 0) irSchema.exclusiveMinimum = schema.minimum;
	} else if (schema.minimum !== void 0) irSchema.minimum = schema.minimum;
	if (schema.format) irSchema.format = schema.format;
	if (schema.maxItems !== void 0) irSchema.maxItems = schema.maxItems;
	if (schema.maxLength !== void 0) irSchema.maxLength = schema.maxLength;
	if (schema.minItems !== void 0) irSchema.minItems = schema.minItems;
	if (schema.minLength !== void 0) irSchema.minLength = schema.minLength;
	if (schema.pattern) irSchema.pattern = schema.pattern;
	if (schema.readOnly) irSchema.accessScope = "read";
	else if (schema.writeOnly) irSchema.accessScope = "write";
};
const parseArray$1 = ({ context, irSchema = {}, schema, state }) => {
	if (schema.maxItems && schema.maxItems === schema.minItems) irSchema.type = "tuple";
	else irSchema.type = "array";
	let schemaItems = [];
	if (schema.items) {
		const irItemsSchema = schemaToIrSchema$1({
			context,
			schema: schema.items,
			state
		});
		if (!schemaItems.length && schema.maxItems && schema.maxItems === schema.minItems) schemaItems = Array(schema.maxItems).fill(irItemsSchema);
		else if ("$ref" in schema.items) schemaItems.push(irItemsSchema);
		else {
			const ofArray = schema.items.allOf || schema.items.anyOf || schema.items.oneOf;
			if (ofArray && ofArray.length > 1 && !schema.items.nullable) irSchema = {
				...irSchema,
				...irItemsSchema
			};
			else schemaItems.push(irItemsSchema);
		}
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		schema: irSchema
	});
	return irSchema;
};
const parseBoolean$1 = ({ irSchema = {} }) => {
	irSchema.type = "boolean";
	return irSchema;
};
const parseNumber$1 = ({ irSchema = {}, schema }) => {
	irSchema.type = schema.type;
	return irSchema;
};
const parseObject$1 = ({ context, irSchema = {}, schema, state }) => {
	irSchema.type = "object";
	const schemaProperties = {};
	for (const name in schema.properties) {
		const property = schema.properties[name];
		if (typeof property === "boolean") {} else schemaProperties[name] = schemaToIrSchema$1({
			context,
			schema: property,
			state
		});
	}
	if (Object.keys(schemaProperties).length) irSchema.properties = schemaProperties;
	if (schema.additionalProperties === void 0) {
		if (!irSchema.properties) irSchema.additionalProperties = { type: "unknown" };
	} else if (typeof schema.additionalProperties === "boolean") {
		if (!(state.inAllOf && schema.additionalProperties === false && (!schema.properties || !Object.keys(schema.properties).length))) irSchema.additionalProperties = { type: schema.additionalProperties ? "unknown" : "never" };
	} else irSchema.additionalProperties = schemaToIrSchema$1({
		context,
		schema: schema.additionalProperties,
		state
	});
	if (schema.required) irSchema.required = schema.required;
	return irSchema;
};
const parseString$1 = ({ irSchema = {} }) => {
	irSchema.type = "string";
	return irSchema;
};
const parseExtensions$1 = ({ source: source$2, target }) => {
	for (const key in source$2) if (key.startsWith("x-")) target[key] = source$2[key];
};
const initIrSchema$1 = ({ schema }) => {
	const irSchema = {};
	parseSchemaJsDoc$1({
		irSchema,
		schema
	});
	parseExtensions$1({
		source: schema,
		target: irSchema
	});
	return irSchema;
};
const parseAllOf$1 = ({ context, schema, state }) => {
	let irSchema = initIrSchema$1({ schema });
	const schemaItems = [];
	const schemaType = getSchemaType({ schema });
	const compositionSchemas = schema.allOf;
	const discriminatorsToAdd = [];
	const addedDiscriminators = /* @__PURE__ */ new Set();
	for (const compositionSchema of compositionSchemas) {
		const originalInAllOf = state.inAllOf;
		if (!("$ref" in compositionSchema)) state.inAllOf = true;
		const irCompositionSchema = schemaToIrSchema$1({
			context,
			schema: compositionSchema,
			state
		});
		state.inAllOf = originalInAllOf;
		if (state.inAllOf === void 0) delete state.inAllOf;
		if (schema.required) if (irCompositionSchema.required) irCompositionSchema.required = [...irCompositionSchema.required, ...schema.required];
		else irCompositionSchema.required = schema.required;
		schemaItems.push(irCompositionSchema);
		if ("$ref" in compositionSchema) {
			const ref$41 = context.resolveRef(compositionSchema.$ref);
			if (state.$ref) {
				const discriminators = findDiscriminatorsInSchema$1({
					context,
					schema: ref$41
				});
				for (const { discriminator, oneOf } of discriminators) {
					if (addedDiscriminators.has(discriminator.propertyName)) continue;
					const values = discriminatorValues(state.$ref, discriminator.mapping, oneOf ? () => oneOf.some((o) => "$ref" in o && o.$ref === state.$ref) : void 0);
					if (values.length > 0) {
						const isRequired = discriminators.some((d) => d.discriminator.propertyName === discriminator.propertyName && (ref$41.required?.includes(d.discriminator.propertyName) || ref$41.allOf && ref$41.allOf.some((item) => {
							return ("$ref" in item ? context.resolveRef(item.$ref) : item).required?.includes(d.discriminator.propertyName);
						})));
						discriminatorsToAdd.push({
							discriminator,
							isRequired,
							values
						});
						addedDiscriminators.add(discriminator.propertyName);
					}
				}
			}
		}
	}
	for (const { discriminator, isRequired, values } of discriminatorsToAdd) {
		const allValues = getAllDiscriminatorValues$1({
			discriminator,
			schemaRef: state.$ref
		});
		const valueSchemas = (allValues.length > 0 ? allValues : values).map((value) => ({
			const: value,
			type: "string"
		}));
		const discriminatorProperty = valueSchemas.length > 1 ? {
			items: valueSchemas,
			logicalOperator: "or"
		} : valueSchemas[0];
		for (const item of schemaItems) if (item.$ref || item.symbolRef) {
			if ((() => {
				if (!item.$ref) return false;
				try {
					const refSchema = context.resolveRef(item.$ref);
					return refSchema.properties?.[discriminator.propertyName] !== void 0 || refSchema.allOf && refSchema.allOf.some((allOfItem) => {
						return ("$ref" in allOfItem ? context.resolveRef(allOfItem.$ref) : allOfItem).properties?.[discriminator.propertyName] !== void 0;
					});
				} catch {
					return false;
				}
			})()) {
				if (!item.omit) item.omit = [discriminator.propertyName];
				else if (!item.omit.includes(discriminator.propertyName)) item.omit = [...item.omit, discriminator.propertyName];
			}
		}
		let inlineSchema;
		for (let i = schemaItems.length - 1; i >= 0; i--) {
			const item = schemaItems[i];
			if (item.type === "object" || item.properties) {
				inlineSchema = item;
				break;
			}
		}
		if (inlineSchema) {
			if (!inlineSchema.properties) inlineSchema.properties = {};
			inlineSchema.properties[discriminator.propertyName] = discriminatorProperty;
			if (isRequired) {
				if (!inlineSchema.required) inlineSchema.required = [];
				if (!inlineSchema.required.includes(discriminator.propertyName)) inlineSchema.required = [...inlineSchema.required, discriminator.propertyName];
			}
		} else {
			const irDiscriminatorSchema = {
				properties: { [discriminator.propertyName]: discriminatorProperty },
				type: "object"
			};
			if (isRequired) irDiscriminatorSchema.required = [discriminator.propertyName];
			schemaItems.push(irDiscriminatorSchema);
		}
	}
	if (schemaType === "object") {
		const irObjectSchema = parseOneType$1({
			context,
			schema: {
				...schema,
				type: "object"
			},
			state
		});
		if (irObjectSchema.properties) {
			for (const requiredProperty of irObjectSchema.required ?? []) if (!irObjectSchema.properties[requiredProperty]) for (const compositionSchema of compositionSchemas) {
				const finalCompositionSchema = "$ref" in compositionSchema ? context.resolveRef(compositionSchema.$ref) : compositionSchema;
				if (getSchemaType({ schema: finalCompositionSchema }) === "object") {
					const irCompositionSchema = parseOneType$1({
						context,
						schema: {
							...finalCompositionSchema,
							type: "object"
						},
						state
					});
					if (irCompositionSchema.properties?.[requiredProperty]) {
						irObjectSchema.properties[requiredProperty] = irCompositionSchema.properties[requiredProperty];
						break;
					}
				}
			}
			schemaItems.push(irObjectSchema);
		}
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		logicalOperator: "and",
		mutateSchemaOneItem: true,
		schema: irSchema
	});
	if (schema.nullable) {
		const nestedItems = [{ type: "null" }];
		if (schemaItems.length) nestedItems.unshift(irSchema);
		irSchema = {
			items: nestedItems,
			logicalOperator: "or"
		};
		if (nestedItems[0].deprecated) irSchema.deprecated = nestedItems[0].deprecated;
		if (nestedItems[0].description) irSchema.description = nestedItems[0].description;
	}
	return irSchema;
};
const parseAnyOf$1 = ({ context, schema, state }) => {
	let irSchema = initIrSchema$1({ schema });
	const schemaItems = [];
	const schemaType = getSchemaType({ schema });
	const compositionSchemas = schema.anyOf;
	for (const compositionSchema of compositionSchemas) {
		let irCompositionSchema = schemaToIrSchema$1({
			context,
			schema: compositionSchema,
			state
		});
		if (schema.discriminator && irCompositionSchema.$ref != null) {
			const valueSchemas = discriminatorValues(irCompositionSchema.$ref, schema.discriminator.mapping).map((value) => ({
				const: value,
				type: "string"
			}));
			irCompositionSchema = {
				items: [{
					properties: { [schema.discriminator.propertyName]: valueSchemas.length > 1 ? {
						items: valueSchemas,
						logicalOperator: "or"
					} : valueSchemas[0] },
					type: "object"
				}, irCompositionSchema],
				logicalOperator: "and"
			};
		}
		schemaItems.push(irCompositionSchema);
	}
	if (schema.nullable) schemaItems.push({ type: "null" });
	irSchema = addItemsToSchema({
		items: schemaItems,
		mutateSchemaOneItem: true,
		schema: irSchema
	});
	if (schemaType === "object") {
		const irObjectSchema = parseOneType$1({
			context,
			schema: {
				...schema,
				type: "object"
			},
			state
		});
		if (irObjectSchema.properties) irSchema = {
			items: [irSchema, irObjectSchema],
			logicalOperator: "and"
		};
	}
	return irSchema;
};
const parseEnum$1 = ({ context, schema, state }) => {
	let irSchema = initIrSchema$1({ schema });
	irSchema.type = "enum";
	const schemaItems = [];
	for (const [index, enumValue] of schema.enum.entries()) {
		const typeOfEnumValue = typeof enumValue;
		let enumType;
		if (typeOfEnumValue === "string" || typeOfEnumValue === "number" || typeOfEnumValue === "boolean") enumType = typeOfEnumValue;
		else if (typeOfEnumValue === "object" && Array.isArray(enumValue)) enumType = "array";
		else if (enumValue === null) {
			if (schema.nullable) enumType = "null";
		} else console.warn("ðŸš¨", `unhandled "${typeOfEnumValue}" typeof value "${enumValue}" for enum`, schema.enum);
		if (!enumType) continue;
		const irTypeSchema = parseOneType$1({
			context,
			schema: {
				description: schema["x-enum-descriptions"]?.[index],
				title: schema["x-enum-varnames"]?.[index] ?? schema["x-enumNames"]?.[index],
				type: enumType === "null" ? "string" : enumType
			},
			state
		});
		irTypeSchema.const = enumValue;
		if (enumType === "null") irTypeSchema.type = enumType;
		if (irTypeSchema.type === "array") irTypeSchema.type = "tuple";
		schemaItems.push(irTypeSchema);
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		schema: irSchema
	});
	return irSchema;
};
const parseOneOf$1 = ({ context, schema, state }) => {
	let irSchema = initIrSchema$1({ schema });
	let schemaItems = [];
	const schemaType = getSchemaType({ schema });
	const compositionSchemas = schema.oneOf;
	for (const compositionSchema of compositionSchemas) {
		let irCompositionSchema = schemaToIrSchema$1({
			context,
			schema: compositionSchema,
			state
		});
		if (schema.discriminator && irCompositionSchema.$ref != null) {
			const valueSchemas = discriminatorValues(irCompositionSchema.$ref, schema.discriminator.mapping).map((value) => ({
				const: value,
				type: "string"
			}));
			irCompositionSchema = {
				items: [{
					properties: { [schema.discriminator.propertyName]: valueSchemas.length > 1 ? {
						items: valueSchemas,
						logicalOperator: "or"
					} : valueSchemas[0] },
					required: [schema.discriminator.propertyName],
					type: "object"
				}, irCompositionSchema],
				logicalOperator: "and"
			};
		}
		if (irCompositionSchema.logicalOperator === "or" && irCompositionSchema.type !== "array" && irCompositionSchema.items) schemaItems = schemaItems.concat(irCompositionSchema.items);
		else schemaItems.push(irCompositionSchema);
	}
	if (schema.nullable) schemaItems.push({ type: "null" });
	irSchema = addItemsToSchema({
		items: schemaItems,
		mutateSchemaOneItem: true,
		schema: irSchema
	});
	if (schemaType === "object") {
		const irObjectSchema = parseOneType$1({
			context,
			schema: {
				...schema,
				type: "object"
			},
			state
		});
		if (irObjectSchema.properties) irSchema = {
			items: [irSchema, irObjectSchema],
			logicalOperator: "and"
		};
	}
	return irSchema;
};
const parseRef$1 = ({ context, schema, state }) => {
	if (!isTopLevelComponentRef(schema.$ref)) {
		if (!state.circularReferenceTracker.has(schema.$ref)) {
			const refSchema = context.resolveRef(schema.$ref);
			const originalRef = state.$ref;
			state.$ref = schema.$ref;
			const irSchema$1 = schemaToIrSchema$1({
				context,
				schema: refSchema,
				state
			});
			state.$ref = originalRef;
			return irSchema$1;
		}
	}
	const irSchema = {};
	irSchema.$ref = decodeURI(schema.$ref);
	if (!state.circularReferenceTracker.has(schema.$ref)) {
		const refSchema = context.resolveRef(schema.$ref);
		const originalRef = state.$ref;
		state.$ref = schema.$ref;
		schemaToIrSchema$1({
			context,
			schema: refSchema,
			state
		});
		state.$ref = originalRef;
	}
	return irSchema;
};
const parseNullableType = ({ context, irSchema, schema, state }) => {
	if (!irSchema) irSchema = initIrSchema$1({ schema });
	const typeIrSchema = {};
	parseSchemaMeta$1({
		irSchema: typeIrSchema,
		schema
	});
	if (typeIrSchema.default === null) delete typeIrSchema.default;
	irSchema = addItemsToSchema({
		items: [parseOneType$1({
			context,
			irSchema: typeIrSchema,
			schema,
			state
		}), { type: "null" }],
		schema: irSchema
	});
	return irSchema;
};
const parseType$1 = ({ context, schema, state }) => {
	const irSchema = initIrSchema$1({ schema });
	parseSchemaMeta$1({
		irSchema,
		schema
	});
	const type = getSchemaType({ schema });
	if (!type) return irSchema;
	if (!schema.nullable) return parseOneType$1({
		context,
		irSchema,
		schema: {
			...schema,
			type
		},
		state
	});
	return parseNullableType({
		context,
		irSchema,
		schema: {
			...schema,
			type
		},
		state
	});
};
const parseOneType$1 = ({ context, irSchema, schema, state }) => {
	if (!irSchema) {
		irSchema = initIrSchema$1({ schema });
		parseSchemaMeta$1({
			irSchema,
			schema
		});
	}
	switch (schema.type) {
		case "array": return parseArray$1({
			context,
			irSchema,
			schema,
			state
		});
		case "boolean": return parseBoolean$1({
			context,
			irSchema,
			schema,
			state
		});
		case "integer":
		case "number": return parseNumber$1({
			context,
			irSchema,
			schema,
			state
		});
		case "object": return parseObject$1({
			context,
			irSchema,
			schema,
			state
		});
		case "string": return parseString$1({
			context,
			irSchema,
			schema,
			state
		});
		default: return parseUnknown$1({
			context,
			irSchema,
			schema
		});
	}
};
const parseUnknown$1 = ({ irSchema, schema }) => {
	if (!irSchema) irSchema = initIrSchema$1({ schema });
	irSchema.type = "unknown";
	parseSchemaMeta$1({
		irSchema,
		schema
	});
	return irSchema;
};
const schemaToIrSchema$1 = ({ context, schema, state }) => {
	if (!state) state = { circularReferenceTracker: /* @__PURE__ */ new Set() };
	if (state.$ref) state.circularReferenceTracker.add(state.$ref);
	if ("$ref" in schema) return parseRef$1({
		context,
		schema,
		state
	});
	if (schema.enum) return parseEnum$1({
		context,
		schema,
		state
	});
	if (schema.allOf) return parseAllOf$1({
		context,
		schema,
		state
	});
	if (schema.anyOf) return parseAnyOf$1({
		context,
		schema,
		state
	});
	if (schema.oneOf) return parseOneOf$1({
		context,
		schema,
		state
	});
	if (schema.type || schema.properties) return parseType$1({
		context,
		schema,
		state
	});
	return parseUnknown$1({
		context,
		schema
	});
};
const parseSchema$1 = ({ $ref, context, schema }) => {
	if (!context.ir.components) context.ir.components = {};
	if (!context.ir.components.schemas) context.ir.components.schemas = {};
	context.ir.components.schemas[refToName($ref)] = schemaToIrSchema$1({
		context,
		schema,
		state: {
			$ref,
			circularReferenceTracker: /* @__PURE__ */ new Set()
		}
	});
};

//#endregion
//#region src/openApi/3.0.x/parser/pagination.ts
const isPaginationType$1 = (schemaType) => schemaType === "boolean" || schemaType === "integer" || schemaType === "number" || schemaType === "string";
const paginationField$1 = ({ context, name, schema }) => {
	if (getPaginationKeywordsRegExp(context.config.parser.pagination).test(name)) return true;
	if ("$ref" in schema) {
		const ref$41 = context.resolveRef(schema.$ref);
		if ("content" in ref$41 || "in" in ref$41) {
			let refSchema;
			if ("in" in ref$41) refSchema = ref$41.schema;
			if (!refSchema) {
				const contents = mediaTypeObjects$1({ content: ref$41.content });
				const content = contents.find((content$1) => content$1.type === "json") || contents[0];
				if (content?.schema) refSchema = content.schema;
			}
			if (!refSchema) return false;
			return paginationField$1({
				context,
				name,
				schema: refSchema
			});
		}
		return paginationField$1({
			context,
			name,
			schema: ref$41
		});
	}
	for (const name$1 in schema.properties) if (getPaginationKeywordsRegExp(context.config.parser.pagination).test(name$1)) {
		const property = schema.properties[name$1];
		if (typeof property !== "boolean" && !("$ref" in property)) {
			if (isPaginationType$1(getSchemaType({ schema: property }))) return name$1;
		}
	}
	for (const allOf of schema.allOf ?? []) {
		const pagination = paginationField$1({
			context,
			name,
			schema: allOf
		});
		if (pagination) return pagination;
	}
	return false;
};

//#endregion
//#region src/openApi/3.0.x/parser/operation.ts
const parseOperationJsDoc$1 = ({ irOperation, operation }) => {
	if (operation.deprecated !== void 0) irOperation.deprecated = operation.deprecated;
	if (operation.description) irOperation.description = operation.description;
	if (operation.summary) irOperation.summary = operation.summary;
	if (operation.tags?.length) irOperation.tags = operation.tags;
};
const initIrOperation$1 = ({ context, method, operation, path: path$10, state }) => {
	const irOperation = {
		id: operationToId({
			context,
			id: operation.operationId,
			method,
			path: path$10,
			state
		}),
		method,
		path: path$10
	};
	if (operation.operationId) irOperation.operationId = operation.operationId;
	parseOperationJsDoc$1({
		irOperation,
		operation
	});
	parseExtensions$1({
		source: operation,
		target: irOperation
	});
	return irOperation;
};
const operationToIrOperation$1 = ({ context, method, operation, path: path$10, securitySchemesMap, state }) => {
	const irOperation = initIrOperation$1({
		context,
		method,
		operation,
		path: path$10,
		state
	});
	if (operation.parameters) irOperation.parameters = operation.parameters;
	if (operation.requestBody) {
		const requestBody = "$ref" in operation.requestBody ? context.resolveRef(operation.requestBody.$ref) : operation.requestBody;
		const contents = mediaTypeObjects$1({ content: requestBody.content });
		const content = contents.find((content$1) => content$1.type === "json") || contents[0];
		if (content) {
			const pagination = paginationField$1({
				context,
				name: "",
				schema: content.schema && "$ref" in content.schema ? {
					allOf: [{ ...content.schema }],
					description: requestBody.description
				} : {
					description: requestBody.description,
					...content.schema
				}
			});
			irOperation.body = {
				mediaType: content.mediaType,
				schema: schemaToIrSchema$1({
					context,
					schema: "$ref" in operation.requestBody ? {
						allOf: [{ ...operation.requestBody }],
						description: requestBody.description
					} : content.schema && "$ref" in content.schema ? {
						allOf: [{ ...content.schema }],
						description: requestBody.description
					} : {
						description: requestBody.description,
						...content.schema
					},
					state: void 0
				})
			};
			if (pagination) irOperation.body.pagination = pagination;
			if (requestBody.required) irOperation.body.required = requestBody.required;
			if (content.type) irOperation.body.type = content.type;
		}
	}
	for (const name in operation.responses) {
		if (name.startsWith("x-")) continue;
		if (!irOperation.responses) irOperation.responses = {};
		const response = operation.responses[name];
		const responseObject = "$ref" in response ? context.resolveRef(response.$ref) : response;
		const contents = mediaTypeObjects$1({ content: responseObject.content });
		const content = contents.find((content$1) => content$1.type === "json") || contents[0];
		if (content) irOperation.responses[name] = {
			mediaType: content.mediaType,
			schema: schemaToIrSchema$1({
				context,
				schema: {
					description: responseObject.description,
					...contentToSchema$1({ content })
				},
				state: void 0
			})
		};
		else irOperation.responses[name] = { schema: {
			description: responseObject.description,
			type: name === "204" ? "void" : "unknown"
		} };
	}
	if (operation.security) {
		const securitySchemeObjects = /* @__PURE__ */ new Map();
		for (const securityRequirementObject of operation.security) for (const name in securityRequirementObject) {
			const securitySchemeObject = securitySchemesMap.get(name);
			if (!securitySchemeObject) continue;
			securitySchemeObjects.set(name, securitySchemeObject);
		}
		if (securitySchemeObjects.size) irOperation.security = Array.from(securitySchemeObjects.values());
	}
	return irOperation;
};
const parsePathOperation$1 = ({ context, method, operation, path: path$10, securitySchemesMap, state }) => {
	if (!context.ir.paths) context.ir.paths = {};
	if (!context.ir.paths[path$10]) context.ir.paths[path$10] = {};
	if (operation.servers) context.ir.servers = [...context.ir.servers ?? [], ...operation.servers];
	context.ir.paths[path$10][method] = operationToIrOperation$1({
		context,
		method,
		operation,
		path: path$10,
		securitySchemesMap,
		state
	});
};

//#endregion
//#region src/openApi/3.0.x/parser/parameter.ts
/**
* Returns default parameter `allowReserved` based on value of `in`.
*/
const defaultAllowReserved$1 = (_in) => {
	switch (_in) {
		case "query": return false;
		default: return;
	}
};
/**
* Returns default parameter `explode` based on value of `style`.
*/
const defaultExplode$1 = (style) => {
	switch (style) {
		case "deepObject":
		case "form": return true;
		default: return false;
	}
};
/**
* Returns default parameter `style` based on value of `in`.
*/
const defaultStyle$1 = (_in) => {
	switch (_in) {
		case "header":
		case "path": return "simple";
		case "cookie":
		case "query": return "form";
	}
};
const parametersArrayToObject$1 = ({ context, parameters }) => {
	if (!parameters || !Object.keys(parameters).length) return;
	const parametersObject = {};
	for (const parameterOrReference of parameters) {
		const parameter = "$ref" in parameterOrReference ? context.dereference(parameterOrReference) : parameterOrReference;
		if (!parametersObject[parameter.in]) parametersObject[parameter.in] = {};
		parametersObject[parameter.in][parameter.name.toLocaleLowerCase()] = parameterToIrParameter$1({
			$ref: `#/todo/real/path/to/parameter/${parameter.name}`,
			context,
			parameter
		});
	}
	return parametersObject;
};
const parameterToIrParameter$1 = ({ $ref, context, parameter }) => {
	let schema = parameter.schema;
	if (!schema) {
		const contents = mediaTypeObjects$1({ content: parameter.content });
		const content = contents.find((content$1) => content$1.type === "json") || contents[0];
		if (content) schema = content.schema;
	}
	const finalSchema = schema && "$ref" in schema ? {
		allOf: [{ ...schema }],
		deprecated: parameter.deprecated,
		description: parameter.description
	} : {
		deprecated: parameter.deprecated,
		description: parameter.description,
		...schema
	};
	const pagination = paginationField$1({
		context,
		name: parameter.name,
		schema: finalSchema
	});
	const style = parameter.style || defaultStyle$1(parameter.in);
	const explode = parameter.explode !== void 0 ? parameter.explode : defaultExplode$1(style);
	const irParameter = {
		allowReserved: parameter.allowReserved !== void 0 ? parameter.allowReserved : defaultAllowReserved$1(parameter.in),
		explode,
		location: parameter.in,
		name: parameter.name,
		schema: schemaToIrSchema$1({
			context,
			schema: finalSchema,
			state: {
				$ref,
				circularReferenceTracker: /* @__PURE__ */ new Set()
			}
		}),
		style
	};
	if (parameter.deprecated) irParameter.deprecated = parameter.deprecated;
	if (parameter.description) irParameter.description = parameter.description;
	if (pagination) irParameter.pagination = pagination;
	if (parameter.required) irParameter.required = parameter.required;
	parseExtensions$1({
		source: parameter,
		target: irParameter
	});
	return irParameter;
};
const parseParameter$1 = ({ $ref, context, parameter }) => {
	if (!context.ir.components) context.ir.components = {};
	if (!context.ir.components.parameters) context.ir.components.parameters = {};
	context.ir.components.parameters[refToName($ref)] = parameterToIrParameter$1({
		$ref,
		context,
		parameter
	});
};

//#endregion
//#region src/openApi/3.0.x/parser/requestBody.ts
const requestBodyToIrRequestBody$1 = ({ $ref, context, requestBody }) => {
	const contents = mediaTypeObjects$1({ content: requestBody.content });
	const content = contents.find((content$1) => content$1.type === "json") || contents[0];
	const schema = content ? content.schema : void 0;
	const irRequestBody = { schema: schemaToIrSchema$1({
		context,
		schema: {
			description: requestBody.description,
			...schema
		},
		state: {
			$ref,
			circularReferenceTracker: /* @__PURE__ */ new Set()
		}
	}) };
	if (requestBody.description) irRequestBody.description = requestBody.description;
	if (requestBody.required) irRequestBody.required = requestBody.required;
	return irRequestBody;
};
const parseRequestBody$1 = ({ $ref, context, requestBody }) => {
	if (!context.ir.components) context.ir.components = {};
	if (!context.ir.components.requestBodies) context.ir.components.requestBodies = {};
	context.ir.components.requestBodies[refToName($ref)] = requestBodyToIrRequestBody$1({
		$ref,
		context,
		requestBody
	});
};

//#endregion
//#region src/openApi/3.0.x/parser/server.ts
const parseServers$1 = ({ context }) => {
	if (context.spec.servers) {
		context.ir.servers = context.spec.servers;
		return;
	}
	for (const input of context.config.input) if (typeof input.path === "string") {
		const url = parseUrl(input.path);
		context.ir.servers = [{ url: `${url.protocol ? `${url.protocol}://` : ""}${url.host}${url.port ? `:${url.port}` : ""}` }];
	}
	if (!context.ir.servers) context.ir.servers = [{ url: "/" }];
};

//#endregion
//#region src/openApi/3.0.x/parser/validate.ts
const validateOpenApiSpec$1 = (spec, logger) => {
	const eventValidate = logger.timeEvent("validate");
	const issues = [];
	const operationIds = /* @__PURE__ */ new Map();
	if (spec.paths) for (const entry of Object.entries(spec.paths)) {
		const path$10 = entry[0];
		const pathItem = entry[1];
		for (const method of httpMethods) {
			const operation = pathItem[method];
			if (!operation) continue;
			const operationKey = createOperationKey({
				method,
				path: path$10
			});
			if (operation.operationId) if (!operationIds.has(operation.operationId)) operationIds.set(operation.operationId, operationKey);
			else issues.push({
				code: "duplicate_key",
				context: {
					key: "operationId",
					value: operation.operationId
				},
				message: "Duplicate `operationId` found. Each `operationId` must be unique.",
				path: [
					"paths",
					path$10,
					method,
					"operationId"
				],
				severity: "error"
			});
		}
	}
	if (spec.servers) {
		if (typeof spec.servers !== "object" || !Array.isArray(spec.servers)) issues.push({
			code: "invalid_type",
			message: "`servers` must be an array.",
			path: [],
			severity: "error"
		});
		for (let index = 0; index < spec.servers.length; index++) {
			const server = spec.servers[index];
			if (!server || typeof server !== "object") issues.push({
				code: "invalid_type",
				context: {
					actual: typeof server,
					expected: "object"
				},
				message: "Each entry in `servers` must be an object.",
				path: ["servers", index],
				severity: "error"
			});
			else if (!server.url) issues.push({
				code: "missing_required_field",
				context: { field: "url" },
				message: "Missing required field `url` in server object.",
				path: ["servers", index],
				severity: "error"
			});
		}
	}
	eventValidate.timeEnd();
	return {
		issues,
		valid: !issues.some((issue) => issue.severity === "error")
	};
};

//#endregion
//#region src/openApi/3.0.x/parser/index.ts
const parseV3_0_X = (context) => {
	if (context.config.parser.validate_EXPERIMENTAL) handleValidatorResult({
		context,
		result: validateOpenApiSpec$1(context.spec, context.logger)
	});
	if (hasFilters(context.config.parser.filters)) {
		const filters = createFilters(context.config.parser.filters, context.spec, context.logger);
		const { graph } = buildGraph(context.spec, context.logger);
		const { resourceMetadata } = buildResourceMetadata(graph, context.logger);
		filterSpec$1({
			...createFilteredDependencies({
				filters,
				logger: context.logger,
				resourceMetadata
			}),
			logger: context.logger,
			preserveOrder: filters.preserveOrder,
			spec: context.spec
		});
	}
	transformOpenApiSpec({ context });
	const state = { ids: /* @__PURE__ */ new Map() };
	const securitySchemesMap = /* @__PURE__ */ new Map();
	if (context.spec.components) {
		for (const name in context.spec.components.securitySchemes) {
			const securityOrReference = context.spec.components.securitySchemes[name];
			const securitySchemeObject = "$ref" in securityOrReference ? context.resolveRef(securityOrReference.$ref) : securityOrReference;
			securitySchemesMap.set(name, securitySchemeObject);
		}
		for (const name in context.spec.components.parameters) {
			const $ref = `#/components/parameters/${name}`;
			const parameterOrReference = context.spec.components.parameters[name];
			parseParameter$1({
				$ref,
				context,
				parameter: "$ref" in parameterOrReference ? context.resolveRef(parameterOrReference.$ref) : parameterOrReference
			});
		}
		for (const name in context.spec.components.requestBodies) {
			const $ref = `#/components/requestBodies/${name}`;
			const requestBodyOrReference = context.spec.components.requestBodies[name];
			parseRequestBody$1({
				$ref,
				context,
				requestBody: "$ref" in requestBodyOrReference ? context.resolveRef(requestBodyOrReference.$ref) : requestBodyOrReference
			});
		}
		for (const name in context.spec.components.schemas) {
			const $ref = `#/components/schemas/${name}`;
			const schema = context.spec.components.schemas[name];
			parseSchema$1({
				$ref,
				context,
				schema
			});
		}
	}
	parseServers$1({ context });
	for (const path$10 in context.spec.paths) {
		if (path$10.startsWith("x-")) continue;
		const pathItem = context.spec.paths[path$10];
		const finalPathItem = pathItem.$ref ? {
			...context.resolveRef(pathItem.$ref),
			...pathItem
		} : pathItem;
		const operationArgs = {
			context,
			operation: {
				description: finalPathItem.description,
				parameters: parametersArrayToObject$1({
					context,
					parameters: finalPathItem.parameters
				}),
				security: context.spec.security,
				servers: finalPathItem.servers,
				summary: finalPathItem.summary
			},
			path: path$10,
			securitySchemesMap,
			state
		};
		if (finalPathItem.delete) parsePathOperation$1({
			...operationArgs,
			method: "delete",
			operation: {
				...operationArgs.operation,
				...finalPathItem.delete,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject$1({
						context,
						parameters: finalPathItem.delete.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.get) parsePathOperation$1({
			...operationArgs,
			method: "get",
			operation: {
				...operationArgs.operation,
				...finalPathItem.get,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject$1({
						context,
						parameters: finalPathItem.get.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.head) parsePathOperation$1({
			...operationArgs,
			method: "head",
			operation: {
				...operationArgs.operation,
				...finalPathItem.head,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject$1({
						context,
						parameters: finalPathItem.head.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.options) parsePathOperation$1({
			...operationArgs,
			method: "options",
			operation: {
				...operationArgs.operation,
				...finalPathItem.options,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject$1({
						context,
						parameters: finalPathItem.options.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.patch) parsePathOperation$1({
			...operationArgs,
			method: "patch",
			operation: {
				...operationArgs.operation,
				...finalPathItem.patch,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject$1({
						context,
						parameters: finalPathItem.patch.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.post) parsePathOperation$1({
			...operationArgs,
			method: "post",
			operation: {
				...operationArgs.operation,
				...finalPathItem.post,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject$1({
						context,
						parameters: finalPathItem.post.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.put) parsePathOperation$1({
			...operationArgs,
			method: "put",
			operation: {
				...operationArgs.operation,
				...finalPathItem.put,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject$1({
						context,
						parameters: finalPathItem.put.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.trace) parsePathOperation$1({
			...operationArgs,
			method: "trace",
			operation: {
				...operationArgs.operation,
				...finalPathItem.trace,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject$1({
						context,
						parameters: finalPathItem.trace.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
	}
};

//#endregion
//#region src/openApi/3.1.x/parser/filter.ts
/**
* Replace source spec with filtered version.
*/
const filterSpec = ({ logger, operations, parameters, preserveOrder, requestBodies, responses, schemas, spec }) => {
	const eventFilterSpec = logger.timeEvent("filter-spec");
	if (spec.components) {
		if (spec.components.parameters) {
			const filtered = {};
			if (preserveOrder) {
				for (const [name, source$2] of Object.entries(spec.components.parameters)) if (parameters.has(addNamespace("parameter", name))) filtered[name] = source$2;
			} else for (const key of parameters) {
				const { name } = removeNamespace(key);
				const source$2 = spec.components.parameters[name];
				if (source$2) filtered[name] = source$2;
			}
			spec.components.parameters = filtered;
		}
		if (spec.components.requestBodies) {
			const filtered = {};
			if (preserveOrder) {
				for (const [name, source$2] of Object.entries(spec.components.requestBodies)) if (requestBodies.has(addNamespace("body", name))) filtered[name] = source$2;
			} else for (const key of requestBodies) {
				const { name } = removeNamespace(key);
				const source$2 = spec.components.requestBodies[name];
				if (source$2) filtered[name] = source$2;
			}
			spec.components.requestBodies = filtered;
		}
		if (spec.components.responses) {
			const filtered = {};
			if (preserveOrder) {
				for (const [name, source$2] of Object.entries(spec.components.responses)) if (responses.has(addNamespace("response", name))) filtered[name] = source$2;
			} else for (const key of responses) {
				const { name } = removeNamespace(key);
				const source$2 = spec.components.responses[name];
				if (source$2) filtered[name] = source$2;
			}
			spec.components.responses = filtered;
		}
		if (spec.components.schemas) {
			const filtered = {};
			if (preserveOrder) {
				for (const [name, source$2] of Object.entries(spec.components.schemas)) if (schemas.has(addNamespace("schema", name))) filtered[name] = source$2;
			} else for (const key of schemas) {
				const { name } = removeNamespace(key);
				const source$2 = spec.components.schemas[name];
				if (source$2) filtered[name] = source$2;
			}
			spec.components.schemas = filtered;
		}
	}
	if (spec.paths) for (const entry of Object.entries(spec.paths)) {
		const path$10 = entry[0];
		const pathItem = entry[1];
		for (const method of httpMethods) {
			if (!pathItem[method]) continue;
			const key = addNamespace("operation", createOperationKey({
				method,
				path: path$10
			}));
			if (!operations.has(key)) delete pathItem[method];
		}
		if (!Object.keys(pathItem).length) delete spec.paths[path$10];
	}
	eventFilterSpec.timeEnd();
};

//#endregion
//#region src/openApi/3.1.x/parser/mediaType.ts
const contentToSchema = ({ content }) => {
	const { mediaType, schema } = content;
	if (!schema) {
		if (isMediaTypeFileLike({ mediaType })) return {
			format: "binary",
			type: "string"
		};
		return;
	}
	if (schema.type === "string" && !schema.format && isMediaTypeFileLike({ mediaType })) return {
		...schema,
		format: "binary"
	};
	return schema;
};
const mediaTypeObjects = ({ content }) => {
	const objects = [];
	for (const mediaType in content) objects.push({
		mediaType,
		schema: content[mediaType].schema,
		type: mediaTypeToIrMediaType({ mediaType })
	});
	return objects;
};

//#endregion
//#region src/openApi/3.1.x/parser/schema.ts
const getSchemaTypes = ({ schema }) => {
	if (typeof schema.type === "string") return [schema.type];
	if (schema.type) return schema.type;
	if (schema.properties) return ["object"];
	return [];
};
/**
* Recursively finds discriminators in a schema, including nested allOf compositions.
* This is needed when a schema extends another schema via allOf, and that parent
* schema is itself an allOf composition with discriminators in inline schemas.
*/
const findDiscriminatorsInSchema = ({ context, discriminators = [], schema }) => {
	if (schema.discriminator) discriminators.push({
		discriminator: schema.discriminator,
		oneOf: schema.oneOf
	});
	if (schema.allOf) for (const compositionSchema of schema.allOf) {
		let resolvedSchema;
		if (compositionSchema.$ref) resolvedSchema = context.resolveRef(compositionSchema.$ref);
		else resolvedSchema = compositionSchema;
		findDiscriminatorsInSchema({
			context,
			discriminators,
			schema: resolvedSchema
		});
	}
	return discriminators;
};
/**
* Gets the discriminator value for a schema.
* Returns only the schema's own discriminator value, not child values.
*/
const getAllDiscriminatorValues = ({ discriminator, schemaRef }) => {
	const values = [];
	for (const [value, mappedSchemaRef] of Object.entries(discriminator.mapping || {})) if (mappedSchemaRef === schemaRef) values.push(value);
	return values;
};
const parseSchemaJsDoc = ({ irSchema, schema }) => {
	if (schema.deprecated !== void 0) irSchema.deprecated = schema.deprecated;
	if (schema.example) irSchema.example = schema.example;
	if (schema.description) irSchema.description = schema.description;
	if (schema.title) irSchema.title = schema.title;
};
const parseSchemaMeta = ({ irSchema, schema }) => {
	if (schema.const !== void 0) {
		irSchema.const = schema.const;
		if (!schema.type) if (schema.const === null) irSchema.type = "null";
		else switch (typeof schema.const) {
			case "bigint":
			case "number":
				irSchema.type = "number";
				break;
			case "boolean":
				irSchema.type = "boolean";
				break;
			case "string":
				irSchema.type = "string";
				break;
		}
	}
	if (schema.default !== void 0) irSchema.default = schema.default;
	if (schema.exclusiveMaximum !== void 0) irSchema.exclusiveMaximum = schema.exclusiveMaximum;
	if (schema.exclusiveMinimum !== void 0) irSchema.exclusiveMinimum = schema.exclusiveMinimum;
	if (schema.format) irSchema.format = schema.format;
	if (schema.maximum !== void 0) irSchema.maximum = schema.maximum;
	if (schema.maxItems !== void 0) irSchema.maxItems = schema.maxItems;
	if (schema.maxLength !== void 0) irSchema.maxLength = schema.maxLength;
	if (schema.minimum !== void 0) irSchema.minimum = schema.minimum;
	if (schema.minItems !== void 0) irSchema.minItems = schema.minItems;
	if (schema.minLength !== void 0) irSchema.minLength = schema.minLength;
	if (schema.pattern) irSchema.pattern = schema.pattern;
	if (schema.readOnly) irSchema.accessScope = "read";
	else if (schema.writeOnly) irSchema.accessScope = "write";
};
const parseArray = ({ context, irSchema = {}, schema, state }) => {
	if (schema.prefixItems && schema.prefixItems.length || schema.maxItems && schema.maxItems === schema.minItems || schema.const !== void 0) irSchema.type = "tuple";
	else irSchema.type = "array";
	let schemaItems = [];
	for (const item of schema.prefixItems ?? []) {
		const irItemSchema = schemaToIrSchema({
			context,
			schema: item,
			state
		});
		schemaItems.push(irItemSchema);
	}
	if (schema.items) {
		const irItemsSchema = schemaToIrSchema({
			context,
			schema: schema.items,
			state
		});
		if (!schemaItems.length && schema.maxItems && schema.maxItems === schema.minItems) schemaItems = Array(schema.maxItems).fill(irItemsSchema);
		else {
			const ofArray = schema.items.allOf || schema.items.anyOf || schema.items.oneOf;
			if (ofArray && ofArray.length > 1 && !getSchemaTypes({ schema: schema.items }).includes("null")) irSchema = {
				...irSchema,
				...irItemsSchema
			};
			else schemaItems.push(irItemsSchema);
		}
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		schema: irSchema
	});
	return irSchema;
};
const parseBoolean = ({ irSchema = {} }) => {
	irSchema.type = "boolean";
	return irSchema;
};
const parseNull = ({ irSchema = {} }) => {
	irSchema.type = "null";
	return irSchema;
};
const parseNumber = ({ irSchema = {}, schema }) => {
	irSchema.type = schema.type;
	return irSchema;
};
const parseObject = ({ context, irSchema = {}, schema, state }) => {
	irSchema.type = "object";
	const schemaProperties = {};
	for (const name in schema.properties) {
		const property = schema.properties[name];
		if (typeof property === "boolean") {} else schemaProperties[name] = schemaToIrSchema({
			context,
			schema: property,
			state
		});
	}
	if (Object.keys(schemaProperties).length) irSchema.properties = schemaProperties;
	if (schema.additionalProperties === void 0) {
		if (!irSchema.properties) irSchema.additionalProperties = { type: "unknown" };
	} else if (typeof schema.additionalProperties === "boolean") {
		if (!(state.inAllOf && schema.additionalProperties === false && (!schema.properties || !Object.keys(schema.properties).length) && (!schema.patternProperties || !Object.keys(schema.patternProperties).length))) irSchema.additionalProperties = { type: schema.additionalProperties ? "unknown" : "never" };
	} else irSchema.additionalProperties = schemaToIrSchema({
		context,
		schema: schema.additionalProperties,
		state
	});
	if (schema.patternProperties) {
		const patternProperties = {};
		for (const pattern in schema.patternProperties) {
			const patternSchema = schema.patternProperties[pattern];
			patternProperties[pattern] = schemaToIrSchema({
				context,
				schema: patternSchema,
				state
			});
		}
		if (Object.keys(patternProperties).length) irSchema.patternProperties = patternProperties;
	}
	if (schema.propertyNames) irSchema.propertyNames = schemaToIrSchema({
		context,
		schema: schema.propertyNames,
		state
	});
	if (schema.required) irSchema.required = schema.required;
	return irSchema;
};
const parseString = ({ irSchema = {} }) => {
	irSchema.type = "string";
	return irSchema;
};
const parseExtensions = ({ source: source$2, target }) => {
	for (const key in source$2) if (key.startsWith("x-")) target[key] = source$2[key];
};
const initIrSchema = ({ schema }) => {
	const irSchema = {};
	parseSchemaJsDoc({
		irSchema,
		schema
	});
	parseExtensions({
		source: schema,
		target: irSchema
	});
	return irSchema;
};
const parseAllOf = ({ context, schema, state }) => {
	let irSchema = initIrSchema({ schema });
	parseSchemaMeta({
		irSchema,
		schema
	});
	const schemaItems = [];
	const schemaTypes = getSchemaTypes({ schema });
	const compositionSchemas = schema.allOf;
	const discriminatorsToAdd = [];
	const addedDiscriminators = /* @__PURE__ */ new Set();
	for (const compositionSchema of compositionSchemas) {
		const originalInAllOf = state.inAllOf;
		if (!("$ref" in compositionSchema)) state.inAllOf = true;
		const irCompositionSchema = schemaToIrSchema({
			context,
			schema: compositionSchema,
			state
		});
		state.inAllOf = originalInAllOf;
		if (state.inAllOf === void 0) delete state.inAllOf;
		if (schema.required) if (irCompositionSchema.required) irCompositionSchema.required = [...irCompositionSchema.required, ...schema.required];
		else irCompositionSchema.required = schema.required;
		schemaItems.push(irCompositionSchema);
		if (compositionSchema.$ref) {
			const ref$41 = context.resolveRef(compositionSchema.$ref);
			if (state.$ref) {
				const discriminators = findDiscriminatorsInSchema({
					context,
					schema: ref$41
				});
				for (const { discriminator, oneOf } of discriminators) {
					if (addedDiscriminators.has(discriminator.propertyName)) continue;
					const values = discriminatorValues(state.$ref, discriminator.mapping, oneOf ? () => oneOf.some((o) => "$ref" in o && o.$ref === state.$ref) : void 0);
					if (values.length > 0) {
						const isRequired = discriminators.some((d) => d.discriminator.propertyName === discriminator.propertyName && (ref$41.required?.includes(d.discriminator.propertyName) || ref$41.allOf && ref$41.allOf.some((item) => {
							return (item.$ref ? context.resolveRef(item.$ref) : item).required?.includes(d.discriminator.propertyName);
						})));
						discriminatorsToAdd.push({
							discriminator,
							isRequired,
							values
						});
						addedDiscriminators.add(discriminator.propertyName);
					}
				}
			}
		}
	}
	for (const { discriminator, isRequired, values } of discriminatorsToAdd) {
		const allValues = getAllDiscriminatorValues({
			discriminator,
			schemaRef: state.$ref
		});
		const valueSchemas = (allValues.length > 0 ? allValues : values).map((value) => ({
			const: value,
			type: "string"
		}));
		const discriminatorProperty = valueSchemas.length > 1 ? {
			items: valueSchemas,
			logicalOperator: "or"
		} : valueSchemas[0];
		for (const item of schemaItems) if (item.$ref || item.symbolRef) {
			if ((() => {
				if (!item.$ref) return false;
				try {
					const refSchema = context.resolveRef(item.$ref);
					return refSchema.properties?.[discriminator.propertyName] !== void 0 || refSchema.allOf && refSchema.allOf.some((allOfItem) => {
						return (allOfItem.$ref ? context.resolveRef(allOfItem.$ref) : allOfItem).properties?.[discriminator.propertyName] !== void 0;
					});
				} catch {
					return false;
				}
			})()) {
				if (!item.omit) item.omit = [discriminator.propertyName];
				else if (!item.omit.includes(discriminator.propertyName)) item.omit = [...item.omit, discriminator.propertyName];
			}
		}
		let inlineSchema;
		for (let i = schemaItems.length - 1; i >= 0; i--) {
			const item = schemaItems[i];
			if (item.type === "object" || item.properties) {
				inlineSchema = item;
				break;
			}
		}
		if (inlineSchema) {
			if (!inlineSchema.properties) inlineSchema.properties = {};
			inlineSchema.properties[discriminator.propertyName] = discriminatorProperty;
			if (isRequired) {
				if (!inlineSchema.required) inlineSchema.required = [];
				if (!inlineSchema.required.includes(discriminator.propertyName)) inlineSchema.required = [...inlineSchema.required, discriminator.propertyName];
			}
		} else {
			const irDiscriminatorSchema = {
				properties: { [discriminator.propertyName]: discriminatorProperty },
				type: "object"
			};
			if (isRequired) irDiscriminatorSchema.required = [discriminator.propertyName];
			schemaItems.push(irDiscriminatorSchema);
		}
	}
	if (schemaTypes.includes("object")) {
		const irObjectSchema = parseOneType({
			context,
			schema: {
				...schema,
				type: "object"
			},
			state
		});
		if (irObjectSchema.properties) {
			for (const requiredProperty of irObjectSchema.required ?? []) if (!irObjectSchema.properties[requiredProperty]) for (const compositionSchema of compositionSchemas) {
				const finalCompositionSchema = compositionSchema.$ref ? context.resolveRef(compositionSchema.$ref) : compositionSchema;
				if (getSchemaTypes({ schema: finalCompositionSchema }).includes("object")) {
					const irCompositionSchema = parseOneType({
						context,
						schema: {
							...finalCompositionSchema,
							type: "object"
						},
						state
					});
					if (irCompositionSchema.properties?.[requiredProperty]) {
						irObjectSchema.properties[requiredProperty] = irCompositionSchema.properties[requiredProperty];
						break;
					}
				}
			}
			schemaItems.push(irObjectSchema);
		}
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		logicalOperator: "and",
		mutateSchemaOneItem: true,
		schema: irSchema
	});
	if (schemaTypes.includes("null")) {
		const nestedItems = [{ type: "null" }];
		if (schemaItems.length) nestedItems.unshift(irSchema);
		irSchema = {
			items: nestedItems,
			logicalOperator: "or"
		};
	}
	return irSchema;
};
const parseAnyOf = ({ context, schema, state }) => {
	let irSchema = initIrSchema({ schema });
	parseSchemaMeta({
		irSchema,
		schema
	});
	const schemaItems = [];
	const schemaTypes = getSchemaTypes({ schema });
	const compositionSchemas = schema.anyOf;
	for (const compositionSchema of compositionSchemas) {
		let irCompositionSchema = schemaToIrSchema({
			context,
			schema: compositionSchema,
			state
		});
		if (schema.discriminator && irCompositionSchema.$ref != null) {
			const valueSchemas = discriminatorValues(irCompositionSchema.$ref, schema.discriminator.mapping).map((value) => ({
				const: value,
				type: "string"
			}));
			irCompositionSchema = {
				items: [{
					properties: { [schema.discriminator.propertyName]: valueSchemas.length > 1 ? {
						items: valueSchemas,
						logicalOperator: "or"
					} : valueSchemas[0] },
					type: "object"
				}, irCompositionSchema],
				logicalOperator: "and"
			};
		}
		schemaItems.push(irCompositionSchema);
	}
	if (schemaTypes.includes("null")) schemaItems.push({ type: "null" });
	irSchema = addItemsToSchema({
		items: schemaItems,
		mutateSchemaOneItem: true,
		schema: irSchema
	});
	if (schemaTypes.includes("object")) {
		const irObjectSchema = parseOneType({
			context,
			schema: {
				...schema,
				type: "object"
			},
			state
		});
		if (irObjectSchema.properties) irSchema = {
			items: [irSchema, irObjectSchema],
			logicalOperator: "and"
		};
	}
	return irSchema;
};
const parseEnum = ({ context, schema, state }) => {
	let irSchema = initIrSchema({ schema });
	irSchema.type = "enum";
	const schemaItems = [];
	const schemaTypes = getSchemaTypes({ schema });
	for (const [index, enumValue] of schema.enum.entries()) {
		const typeOfEnumValue = typeof enumValue;
		let enumType;
		if (typeOfEnumValue === "string" || typeOfEnumValue === "number" || typeOfEnumValue === "boolean") enumType = typeOfEnumValue;
		else if (typeOfEnumValue === "object" && Array.isArray(enumValue)) enumType = "array";
		else if (enumValue === null) {
			if (schemaTypes.includes("null")) enumType = "null";
		} else console.warn("ðŸš¨", `unhandled "${typeOfEnumValue}" typeof value "${enumValue}" for enum`, schema.enum);
		if (!enumType) continue;
		const irTypeSchema = parseOneType({
			context,
			schema: {
				const: enumValue,
				description: schema["x-enum-descriptions"]?.[index],
				title: schema["x-enum-varnames"]?.[index] ?? schema["x-enumNames"]?.[index],
				type: enumType
			},
			state
		});
		schemaItems.push(irTypeSchema);
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		schema: irSchema
	});
	return irSchema;
};
const parseOneOf = ({ context, schema, state }) => {
	let irSchema = initIrSchema({ schema });
	parseSchemaMeta({
		irSchema,
		schema
	});
	let schemaItems = [];
	const schemaTypes = getSchemaTypes({ schema });
	const compositionSchemas = schema.oneOf;
	for (const compositionSchema of compositionSchemas) {
		let irCompositionSchema = schemaToIrSchema({
			context,
			schema: compositionSchema,
			state
		});
		if (schema.discriminator && irCompositionSchema.$ref != null) {
			const valueSchemas = discriminatorValues(irCompositionSchema.$ref, schema.discriminator.mapping).map((value) => ({
				const: value,
				type: "string"
			}));
			irCompositionSchema = {
				items: [{
					properties: { [schema.discriminator.propertyName]: valueSchemas.length > 1 ? {
						items: valueSchemas,
						logicalOperator: "or"
					} : valueSchemas[0] },
					required: [schema.discriminator.propertyName],
					type: "object"
				}, irCompositionSchema],
				logicalOperator: "and"
			};
		}
		if (irCompositionSchema.logicalOperator === "or" && irCompositionSchema.type !== "array" && irCompositionSchema.items) schemaItems = schemaItems.concat(irCompositionSchema.items);
		else schemaItems.push(irCompositionSchema);
	}
	if (schemaTypes.includes("null")) schemaItems.push({ type: "null" });
	irSchema = addItemsToSchema({
		items: schemaItems,
		mutateSchemaOneItem: true,
		schema: irSchema
	});
	if (schemaTypes.includes("object")) {
		const irObjectSchema = parseOneType({
			context,
			schema: {
				...schema,
				type: "object"
			},
			state
		});
		if (irObjectSchema.properties) irSchema = {
			items: [irSchema, irObjectSchema],
			logicalOperator: "and"
		};
	}
	return irSchema;
};
const parseRef = ({ context, schema, state }) => {
	if (!isTopLevelComponentRef(schema.$ref)) {
		if (!state.circularReferenceTracker.has(schema.$ref)) {
			const refSchema = context.resolveRef(schema.$ref);
			const originalRef = state.$ref;
			state.$ref = schema.$ref;
			const irSchema$1 = schemaToIrSchema({
				context,
				schema: refSchema,
				state
			});
			state.$ref = originalRef;
			return irSchema$1;
		}
	}
	let irSchema = initIrSchema({ schema });
	parseSchemaMeta({
		irSchema,
		schema
	});
	const irRefSchema = {};
	irRefSchema.$ref = decodeURI(schema.$ref);
	if (!state.circularReferenceTracker.has(schema.$ref)) {
		const refSchema = context.resolveRef(schema.$ref);
		const originalRef = state.$ref;
		state.$ref = schema.$ref;
		schemaToIrSchema({
			context,
			schema: refSchema,
			state
		});
		state.$ref = originalRef;
	}
	const schemaItems = [];
	schemaItems.push(irRefSchema);
	if (schema.type && typeof schema.type !== "string") {
		if (schema.type.includes("null")) schemaItems.push({ type: "null" });
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		mutateSchemaOneItem: true,
		schema: irSchema
	});
	return irSchema;
};
const parseOneType = ({ context, irSchema, schema, state }) => {
	if (!irSchema) {
		irSchema = initIrSchema({ schema });
		parseSchemaMeta({
			irSchema,
			schema
		});
	}
	switch (schema.type) {
		case "array": return parseArray({
			context,
			irSchema,
			schema,
			state
		});
		case "boolean": return parseBoolean({
			context,
			irSchema,
			schema
		});
		case "integer":
		case "number": return parseNumber({
			context,
			irSchema,
			schema
		});
		case "null": return parseNull({
			context,
			irSchema,
			schema
		});
		case "object": return parseObject({
			context,
			irSchema,
			schema,
			state
		});
		case "string": return parseString({
			context,
			irSchema,
			schema
		});
		default: return parseUnknown({
			context,
			irSchema,
			schema
		});
	}
};
const parseManyTypes = ({ context, irSchema, schema, state }) => {
	if (!irSchema) irSchema = initIrSchema({ schema });
	const typeIrSchema = {};
	parseSchemaMeta({
		irSchema: typeIrSchema,
		schema
	});
	if (schema.type.includes("null") && typeIrSchema.default === null) delete typeIrSchema.default;
	const schemaItems = [];
	for (const type of schema.type) if (type === "null") schemaItems.push({ type: "null" });
	else {
		const irTypeSchema = parseOneType({
			context,
			irSchema: { ...typeIrSchema },
			schema: {
				...schema,
				type
			},
			state
		});
		schemaItems.push(irTypeSchema);
	}
	irSchema = addItemsToSchema({
		items: schemaItems,
		schema: irSchema
	});
	return irSchema;
};
const parseType = ({ context, schema, state }) => {
	const irSchema = initIrSchema({ schema });
	parseSchemaMeta({
		irSchema,
		schema
	});
	const schemaTypes = getSchemaTypes({ schema });
	if (schemaTypes.length === 1) return parseOneType({
		context,
		irSchema,
		schema: {
			...schema,
			type: schemaTypes[0]
		},
		state
	});
	return parseManyTypes({
		context,
		irSchema,
		schema: {
			...schema,
			type: schemaTypes
		},
		state
	});
};
const parseUnknown = ({ irSchema, schema }) => {
	if (!irSchema) irSchema = initIrSchema({ schema });
	irSchema.type = "unknown";
	parseSchemaMeta({
		irSchema,
		schema
	});
	return irSchema;
};
const schemaToIrSchema = ({ context, schema, state }) => {
	if (!state) state = { circularReferenceTracker: /* @__PURE__ */ new Set() };
	if (state.$ref) state.circularReferenceTracker.add(state.$ref);
	if (schema.$ref) return parseRef({
		context,
		schema,
		state
	});
	if (schema.enum) return parseEnum({
		context,
		schema,
		state
	});
	if (schema.allOf) return parseAllOf({
		context,
		schema,
		state
	});
	if (schema.anyOf) return parseAnyOf({
		context,
		schema,
		state
	});
	if (schema.oneOf) return parseOneOf({
		context,
		schema,
		state
	});
	if (schema.type || schema.properties) return parseType({
		context,
		schema,
		state
	});
	return parseUnknown({
		context,
		schema
	});
};
const parseSchema = ({ $ref, context, schema }) => {
	if (!context.ir.components) context.ir.components = {};
	if (!context.ir.components.schemas) context.ir.components.schemas = {};
	context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({
		context,
		schema,
		state: {
			$ref,
			circularReferenceTracker: /* @__PURE__ */ new Set()
		}
	});
};

//#endregion
//#region src/openApi/3.1.x/parser/pagination.ts
const isPaginationType = (schemaTypes) => schemaTypes.includes("boolean") || schemaTypes.includes("integer") || schemaTypes.includes("number") || schemaTypes.includes("string");
const paginationField = ({ context, name, schema }) => {
	if (getPaginationKeywordsRegExp(context.config.parser.pagination).test(name)) return true;
	if (schema.$ref) {
		const ref$41 = context.resolveRef(schema.$ref);
		if ("content" in ref$41 || "in" in ref$41) {
			let refSchema;
			if ("in" in ref$41) refSchema = ref$41.schema;
			if (!refSchema) {
				const contents = mediaTypeObjects({ content: ref$41.content });
				const content = contents.find((content$1) => content$1.type === "json") || contents[0];
				if (content?.schema) refSchema = content.schema;
			}
			if (!refSchema) return false;
			return paginationField({
				context,
				name,
				schema: refSchema
			});
		}
		return paginationField({
			context,
			name,
			schema: ref$41
		});
	}
	for (const name$1 in schema.properties) if (getPaginationKeywordsRegExp(context.config.parser.pagination).test(name$1)) {
		const property = schema.properties[name$1];
		if (typeof property !== "boolean") {
			const schemaTypes = getSchemaTypes({ schema: property });
			if (!schemaTypes.length) {
				const nonNullCompositionSchemas = (property.anyOf ?? property.oneOf ?? []).filter((schema$1) => schema$1.type !== "null");
				if (nonNullCompositionSchemas.length === 1) {
					if (isPaginationType(getSchemaTypes({ schema: nonNullCompositionSchemas[0] }))) return name$1;
				}
			}
			if (isPaginationType(schemaTypes)) return name$1;
		}
	}
	for (const allOf of schema.allOf ?? []) {
		const pagination = paginationField({
			context,
			name,
			schema: allOf
		});
		if (pagination) return pagination;
	}
	return false;
};

//#endregion
//#region src/openApi/3.1.x/parser/operation.ts
const parseOperationJsDoc = ({ irOperation, operation }) => {
	if (operation.deprecated !== void 0) irOperation.deprecated = operation.deprecated;
	if (operation.description) irOperation.description = operation.description;
	if (operation.summary) irOperation.summary = operation.summary;
	if (operation.tags?.length) irOperation.tags = operation.tags;
};
const initIrOperation = ({ context, method, operation, path: path$10, state }) => {
	const irOperation = {
		id: operationToId({
			context,
			id: operation.operationId,
			method,
			path: path$10,
			state
		}),
		method,
		path: path$10
	};
	if (operation.operationId) irOperation.operationId = operation.operationId;
	parseOperationJsDoc({
		irOperation,
		operation
	});
	parseExtensions({
		source: operation,
		target: irOperation
	});
	return irOperation;
};
const operationToIrOperation = ({ context, method, operation, path: path$10, securitySchemesMap, state }) => {
	const irOperation = initIrOperation({
		context,
		method,
		operation,
		path: path$10,
		state
	});
	if (operation.parameters) irOperation.parameters = operation.parameters;
	if (operation.requestBody) {
		const requestBody = "$ref" in operation.requestBody ? context.resolveRef(operation.requestBody.$ref) : operation.requestBody;
		const contents = mediaTypeObjects({ content: requestBody.content });
		const content = contents.find((content$1) => content$1.type === "json") || contents[0];
		if (content) {
			const pagination = paginationField({
				context,
				name: "",
				schema: {
					description: requestBody.description,
					...content.schema
				}
			});
			irOperation.body = {
				mediaType: content.mediaType,
				schema: schemaToIrSchema({
					context,
					schema: {
						description: requestBody.description,
						..."$ref" in operation.requestBody ? operation.requestBody : content.schema
					},
					state: void 0
				})
			};
			if (pagination) irOperation.body.pagination = pagination;
			if (requestBody.required) irOperation.body.required = requestBody.required;
			if (content.type) irOperation.body.type = content.type;
		}
	}
	for (const name in operation.responses) {
		if (name.startsWith("x-")) continue;
		if (!irOperation.responses) irOperation.responses = {};
		const response = operation.responses[name];
		const responseObject = "$ref" in response ? context.resolveRef(response.$ref) : response;
		const contents = mediaTypeObjects({ content: responseObject.content });
		const content = contents.find((content$1) => content$1.type === "json") || contents[0];
		if (content) irOperation.responses[name] = {
			mediaType: content.mediaType,
			schema: schemaToIrSchema({
				context,
				schema: {
					description: responseObject.description,
					...contentToSchema({ content })
				},
				state: void 0
			})
		};
		else irOperation.responses[name] = { schema: {
			description: responseObject.description,
			type: name === "204" ? "void" : "unknown"
		} };
	}
	if (operation.security) {
		const securitySchemeObjects = /* @__PURE__ */ new Map();
		for (const securityRequirementObject of operation.security) for (const name in securityRequirementObject) {
			const securitySchemeObject = securitySchemesMap.get(name);
			if (!securitySchemeObject) continue;
			securitySchemeObjects.set(name, securitySchemeObject);
		}
		if (securitySchemeObjects.size) irOperation.security = Array.from(securitySchemeObjects.values());
	}
	return irOperation;
};
const parseOperationObject = ({ context, method, operation, path: path$10, securitySchemesMap, state }) => {
	if (operation.servers) context.ir.servers = [...context.ir.servers ?? [], ...operation.servers];
	return { parsed: operationToIrOperation({
		context,
		method,
		operation,
		path: path$10,
		securitySchemesMap,
		state
	}) };
};
const parsePathOperation = ({ context, method, path: path$10, ...options }) => {
	if (!context.ir.paths) context.ir.paths = {};
	if (!context.ir.paths[path$10]) context.ir.paths[path$10] = {};
	const { parsed } = parseOperationObject({
		context,
		method,
		path: path$10,
		...options
	});
	context.ir.paths[path$10][method] = parsed;
};
const parseWebhookOperation = ({ context, key, method, ...options }) => {
	if (!context.ir.webhooks) context.ir.webhooks = {};
	if (!context.ir.webhooks[key]) context.ir.webhooks[key] = {};
	const { parsed } = parseOperationObject({
		context,
		method,
		path: key,
		...options
	});
	context.ir.webhooks[key][method] = parsed;
};

//#endregion
//#region src/openApi/3.1.x/parser/parameter.ts
/**
* Returns default parameter `allowReserved` based on value of `in`.
*/
const defaultAllowReserved = (_in) => {
	switch (_in) {
		case "query": return false;
		default: return;
	}
};
/**
* Returns default parameter `explode` based on value of `style`.
*/
const defaultExplode = (style) => {
	switch (style) {
		case "deepObject":
		case "form": return true;
		default: return false;
	}
};
/**
* Returns default parameter `style` based on value of `in`.
*/
const defaultStyle = (_in) => {
	switch (_in) {
		case "header":
		case "path": return "simple";
		case "cookie":
		case "query": return "form";
	}
};
const parametersArrayToObject = ({ context, parameters }) => {
	if (!parameters || !Object.keys(parameters).length) return;
	const parametersObject = {};
	for (const parameterOrReference of parameters) {
		const parameter = "$ref" in parameterOrReference ? context.dereference(parameterOrReference) : parameterOrReference;
		if (!parametersObject[parameter.in]) parametersObject[parameter.in] = {};
		parametersObject[parameter.in][parameter.name.toLocaleLowerCase()] = parameterToIrParameter({
			$ref: `#/todo/real/path/to/parameter/${parameter.name}`,
			context,
			parameter
		});
	}
	return parametersObject;
};
const parameterToIrParameter = ({ $ref, context, parameter }) => {
	let schema = parameter.schema;
	if (!schema) {
		const contents = mediaTypeObjects({ content: parameter.content });
		const content = contents.find((content$1) => content$1.type === "json") || contents[0];
		if (content) schema = content.schema;
	}
	const finalSchema = {
		deprecated: parameter.deprecated,
		description: parameter.description,
		...schema
	};
	const pagination = paginationField({
		context,
		name: parameter.name,
		schema: finalSchema
	});
	const style = parameter.style || defaultStyle(parameter.in);
	const explode = parameter.explode !== void 0 ? parameter.explode : defaultExplode(style);
	const irParameter = {
		allowReserved: parameter.allowReserved !== void 0 ? parameter.allowReserved : defaultAllowReserved(parameter.in),
		explode,
		location: parameter.in,
		name: parameter.name,
		schema: schemaToIrSchema({
			context,
			schema: finalSchema,
			state: {
				$ref,
				circularReferenceTracker: /* @__PURE__ */ new Set()
			}
		}),
		style
	};
	if (parameter.deprecated) irParameter.deprecated = parameter.deprecated;
	if (parameter.description) irParameter.description = parameter.description;
	if (pagination) irParameter.pagination = pagination;
	if (parameter.required) irParameter.required = parameter.required;
	parseExtensions({
		source: parameter,
		target: irParameter
	});
	return irParameter;
};
const parseParameter = ({ $ref, context, parameter }) => {
	if (!context.ir.components) context.ir.components = {};
	if (!context.ir.components.parameters) context.ir.components.parameters = {};
	context.ir.components.parameters[refToName($ref)] = parameterToIrParameter({
		$ref,
		context,
		parameter
	});
};

//#endregion
//#region src/openApi/3.1.x/parser/requestBody.ts
const requestBodyToIrRequestBody = ({ $ref, context, requestBody }) => {
	const contents = mediaTypeObjects({ content: requestBody.content });
	const content = contents.find((content$1) => content$1.type === "json") || contents[0];
	const schema = content ? content.schema : void 0;
	const irRequestBody = { schema: schemaToIrSchema({
		context,
		schema: {
			description: requestBody.description,
			...schema
		},
		state: {
			$ref,
			circularReferenceTracker: /* @__PURE__ */ new Set()
		}
	}) };
	if (requestBody.description) irRequestBody.description = requestBody.description;
	if (requestBody.required) irRequestBody.required = requestBody.required;
	return irRequestBody;
};
const parseRequestBody = ({ $ref, context, requestBody }) => {
	if (!context.ir.components) context.ir.components = {};
	if (!context.ir.components.requestBodies) context.ir.components.requestBodies = {};
	context.ir.components.requestBodies[refToName($ref)] = requestBodyToIrRequestBody({
		$ref,
		context,
		requestBody
	});
};

//#endregion
//#region src/openApi/3.1.x/parser/server.ts
const parseServers = ({ context }) => {
	if (context.spec.servers) {
		context.ir.servers = context.spec.servers;
		return;
	}
	for (const input of context.config.input) if (typeof input.path === "string") {
		const url = parseUrl(input.path);
		context.ir.servers = [{ url: `${url.protocol ? `${url.protocol}://` : ""}${url.host}${url.port ? `:${url.port}` : ""}` }];
	}
	if (!context.ir.servers) context.ir.servers = [{ url: "/" }];
};

//#endregion
//#region src/openApi/3.1.x/parser/validate.ts
const validateOpenApiSpec = (spec, logger) => {
	const eventValidate = logger.timeEvent("validate");
	const issues = [];
	const operationIds = /* @__PURE__ */ new Map();
	if (spec.paths) for (const entry of Object.entries(spec.paths)) {
		const path$10 = entry[0];
		const pathItem = entry[1];
		for (const method of httpMethods) {
			const operation = pathItem[method];
			if (!operation) continue;
			const operationKey = createOperationKey({
				method,
				path: path$10
			});
			if (operation.operationId) if (!operationIds.has(operation.operationId)) operationIds.set(operation.operationId, operationKey);
			else issues.push({
				code: "duplicate_key",
				context: {
					key: "operationId",
					value: operation.operationId
				},
				message: "Duplicate `operationId` found. Each `operationId` must be unique.",
				path: [
					"paths",
					path$10,
					method,
					"operationId"
				],
				severity: "error"
			});
		}
	}
	if (spec.servers) {
		if (typeof spec.servers !== "object" || !Array.isArray(spec.servers)) issues.push({
			code: "invalid_type",
			message: "`servers` must be an array.",
			path: [],
			severity: "error"
		});
		for (let index = 0; index < spec.servers.length; index++) {
			const server = spec.servers[index];
			if (!server || typeof server !== "object") issues.push({
				code: "invalid_type",
				context: {
					actual: typeof server,
					expected: "object"
				},
				message: "Each entry in `servers` must be an object.",
				path: ["servers", index],
				severity: "error"
			});
			else if (!server.url) issues.push({
				code: "missing_required_field",
				context: { field: "url" },
				message: "Missing required field `url` in server object.",
				path: ["servers", index],
				severity: "error"
			});
		}
	}
	eventValidate.timeEnd();
	return {
		issues,
		valid: !issues.some((issue) => issue.severity === "error")
	};
};

//#endregion
//#region src/openApi/3.1.x/parser/webhook.ts
const parseWebhooks = ({ context, securitySchemesMap }) => {
	const state = { ids: /* @__PURE__ */ new Map() };
	for (const key in context.spec.webhooks) {
		const webhook = context.spec.webhooks[key];
		const finalWebhook = "$ref" in webhook ? {
			...context.resolveRef(webhook.$ref),
			...webhook
		} : webhook;
		const operationArgs = {
			context,
			key,
			operation: {
				description: finalWebhook.description,
				parameters: parametersArrayToObject({
					context,
					parameters: finalWebhook.parameters
				}),
				security: context.spec.security,
				servers: finalWebhook.servers,
				summary: finalWebhook.summary
			},
			securitySchemesMap,
			state
		};
		if (finalWebhook.delete) parseWebhookOperation({
			...operationArgs,
			method: "delete",
			operation: {
				...operationArgs.operation,
				...finalWebhook.delete,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalWebhook.delete.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalWebhook.get) parseWebhookOperation({
			...operationArgs,
			method: "get",
			operation: {
				...operationArgs.operation,
				...finalWebhook.get,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalWebhook.get.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalWebhook.head) parseWebhookOperation({
			...operationArgs,
			method: "head",
			operation: {
				...operationArgs.operation,
				...finalWebhook.head,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalWebhook.head.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalWebhook.options) parseWebhookOperation({
			...operationArgs,
			method: "options",
			operation: {
				...operationArgs.operation,
				...finalWebhook.options,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalWebhook.options.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalWebhook.patch) parseWebhookOperation({
			...operationArgs,
			method: "patch",
			operation: {
				...operationArgs.operation,
				...finalWebhook.patch,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalWebhook.patch.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalWebhook.post) parseWebhookOperation({
			...operationArgs,
			method: "post",
			operation: {
				...operationArgs.operation,
				...finalWebhook.post,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalWebhook.post.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalWebhook.put) parseWebhookOperation({
			...operationArgs,
			method: "put",
			operation: {
				...operationArgs.operation,
				...finalWebhook.put,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalWebhook.put.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalWebhook.trace) parseWebhookOperation({
			...operationArgs,
			method: "trace",
			operation: {
				...operationArgs.operation,
				...finalWebhook.trace,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalWebhook.trace.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
	}
};

//#endregion
//#region src/openApi/3.1.x/parser/index.ts
const parseV3_1_X = (context) => {
	if (context.config.parser.validate_EXPERIMENTAL) handleValidatorResult({
		context,
		result: validateOpenApiSpec(context.spec, context.logger)
	});
	if (hasFilters(context.config.parser.filters)) {
		const filters = createFilters(context.config.parser.filters, context.spec, context.logger);
		const { graph } = buildGraph(context.spec, context.logger);
		const { resourceMetadata } = buildResourceMetadata(graph, context.logger);
		filterSpec({
			...createFilteredDependencies({
				filters,
				logger: context.logger,
				resourceMetadata
			}),
			logger: context.logger,
			preserveOrder: filters.preserveOrder,
			spec: context.spec
		});
	}
	transformOpenApiSpec({ context });
	const state = { ids: /* @__PURE__ */ new Map() };
	const securitySchemesMap = /* @__PURE__ */ new Map();
	if (context.spec.components) {
		for (const name in context.spec.components.securitySchemes) {
			const securityOrReference = context.spec.components.securitySchemes[name];
			const securitySchemeObject = "$ref" in securityOrReference ? context.resolveRef(securityOrReference.$ref) : securityOrReference;
			securitySchemesMap.set(name, securitySchemeObject);
		}
		for (const name in context.spec.components.parameters) {
			const $ref = `#/components/parameters/${name}`;
			const parameterOrReference = context.spec.components.parameters[name];
			parseParameter({
				$ref,
				context,
				parameter: "$ref" in parameterOrReference ? context.resolveRef(parameterOrReference.$ref) : parameterOrReference
			});
		}
		for (const name in context.spec.components.requestBodies) {
			const $ref = `#/components/requestBodies/${name}`;
			const requestBodyOrReference = context.spec.components.requestBodies[name];
			parseRequestBody({
				$ref,
				context,
				requestBody: "$ref" in requestBodyOrReference ? context.resolveRef(requestBodyOrReference.$ref) : requestBodyOrReference
			});
		}
		for (const name in context.spec.components.schemas) {
			const $ref = `#/components/schemas/${name}`;
			const schema = context.spec.components.schemas[name];
			parseSchema({
				$ref,
				context,
				schema
			});
		}
	}
	parseServers({ context });
	for (const path$10 in context.spec.paths) {
		if (path$10.startsWith("x-")) continue;
		const pathItem = context.spec.paths[path$10];
		const finalPathItem = pathItem.$ref ? {
			...context.resolveRef(pathItem.$ref),
			...pathItem
		} : pathItem;
		const operationArgs = {
			context,
			operation: {
				description: finalPathItem.description,
				parameters: parametersArrayToObject({
					context,
					parameters: finalPathItem.parameters
				}),
				security: context.spec.security,
				servers: finalPathItem.servers,
				summary: finalPathItem.summary
			},
			path: path$10,
			securitySchemesMap,
			state
		};
		if (finalPathItem.delete) parsePathOperation({
			...operationArgs,
			method: "delete",
			operation: {
				...operationArgs.operation,
				...finalPathItem.delete,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalPathItem.delete.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.get) parsePathOperation({
			...operationArgs,
			method: "get",
			operation: {
				...operationArgs.operation,
				...finalPathItem.get,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalPathItem.get.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.head) parsePathOperation({
			...operationArgs,
			method: "head",
			operation: {
				...operationArgs.operation,
				...finalPathItem.head,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalPathItem.head.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.options) parsePathOperation({
			...operationArgs,
			method: "options",
			operation: {
				...operationArgs.operation,
				...finalPathItem.options,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalPathItem.options.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.patch) parsePathOperation({
			...operationArgs,
			method: "patch",
			operation: {
				...operationArgs.operation,
				...finalPathItem.patch,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalPathItem.patch.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.post) parsePathOperation({
			...operationArgs,
			method: "post",
			operation: {
				...operationArgs.operation,
				...finalPathItem.post,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalPathItem.post.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.put) parsePathOperation({
			...operationArgs,
			method: "put",
			operation: {
				...operationArgs.operation,
				...finalPathItem.put,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalPathItem.put.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
		if (finalPathItem.trace) parsePathOperation({
			...operationArgs,
			method: "trace",
			operation: {
				...operationArgs.operation,
				...finalPathItem.trace,
				parameters: mergeParametersObjects({
					source: parametersArrayToObject({
						context,
						parameters: finalPathItem.trace.parameters
					}),
					target: operationArgs.operation.parameters
				})
			}
		});
	}
	parseWebhooks({
		context,
		securitySchemesMap
	});
};

//#endregion
//#region src/openApi/index.ts
/**
* @internal
* Parse the resolved OpenAPI specification. This will populate and return
* `context` with intermediate representation obtained from the parsed spec.
*/
const parseOpenApiSpec = ({ config, dependencies, logger, spec }) => {
	const context = new Context({
		config,
		dependencies,
		logger,
		spec
	});
	if ("swagger" in context.spec) {
		parseV2_0_X(context);
		return context;
	}
	if (satisfies(context.spec.openapi, ">=3.0.0 <3.1.0")) {
		parseV3_0_X(context);
		return context;
	}
	if (satisfies(context.spec.openapi, ">=3.1.0")) {
		parseV3_1_X(context);
		return context;
	}
	throw new Error("Unsupported OpenAPI specification");
};

//#endregion
Object.defineProperty(exports, '$', {
  enumerable: true,
  get: function () {
    return $;
  }
});
Object.defineProperty(exports, 'ConfigError', {
  enumerable: true,
  get: function () {
    return ConfigError;
  }
});
Object.defineProperty(exports, 'ConfigValidationError', {
  enumerable: true,
  get: function () {
    return ConfigValidationError;
  }
});
Object.defineProperty(exports, 'JobError', {
  enumerable: true,
  get: function () {
    return JobError;
  }
});
Object.defineProperty(exports, 'OperationPath', {
  enumerable: true,
  get: function () {
    return OperationPath;
  }
});
Object.defineProperty(exports, 'OperationStrategy', {
  enumerable: true,
  get: function () {
    return OperationStrategy;
  }
});
Object.defineProperty(exports, 'TsDsl', {
  enumerable: true,
  get: function () {
    return TsDsl;
  }
});
Object.defineProperty(exports, 'TsDslContext', {
  enumerable: true,
  get: function () {
    return TsDslContext;
  }
});
Object.defineProperty(exports, 'TypeScriptRenderer', {
  enumerable: true,
  get: function () {
    return TypeScriptRenderer;
  }
});
Object.defineProperty(exports, '__toESM', {
  enumerable: true,
  get: function () {
    return __toESM;
  }
});
Object.defineProperty(exports, 'buildGraph', {
  enumerable: true,
  get: function () {
    return buildGraph;
  }
});
Object.defineProperty(exports, 'clientDefaultConfig', {
  enumerable: true,
  get: function () {
    return clientDefaultConfig;
  }
});
Object.defineProperty(exports, 'clientDefaultMeta', {
  enumerable: true,
  get: function () {
    return clientDefaultMeta;
  }
});
Object.defineProperty(exports, 'clientPluginHandler', {
  enumerable: true,
  get: function () {
    return clientPluginHandler;
  }
});
Object.defineProperty(exports, 'ctx', {
  enumerable: true,
  get: function () {
    return ctx;
  }
});
Object.defineProperty(exports, 'defaultPaginationKeywords', {
  enumerable: true,
  get: function () {
    return defaultPaginationKeywords;
  }
});
Object.defineProperty(exports, 'defaultPlugins', {
  enumerable: true,
  get: function () {
    return defaultPlugins;
  }
});
Object.defineProperty(exports, 'definePluginConfig', {
  enumerable: true,
  get: function () {
    return definePluginConfig;
  }
});
Object.defineProperty(exports, 'generateClientBundle', {
  enumerable: true,
  get: function () {
    return generateClientBundle;
  }
});
Object.defineProperty(exports, 'getClientPlugin', {
  enumerable: true,
  get: function () {
    return getClientPlugin;
  }
});
Object.defineProperty(exports, 'getLogs', {
  enumerable: true,
  get: function () {
    return getLogs;
  }
});
Object.defineProperty(exports, 'getSpec', {
  enumerable: true,
  get: function () {
    return getSpec;
  }
});
Object.defineProperty(exports, 'keywords', {
  enumerable: true,
  get: function () {
    return keywords;
  }
});
Object.defineProperty(exports, 'loadPackageJson', {
  enumerable: true,
  get: function () {
    return loadPackageJson;
  }
});
Object.defineProperty(exports, 'logCrashReport', {
  enumerable: true,
  get: function () {
    return logCrashReport;
  }
});
Object.defineProperty(exports, 'openGitHubIssueWithCrashReport', {
  enumerable: true,
  get: function () {
    return openGitHubIssueWithCrashReport;
  }
});
Object.defineProperty(exports, 'parseOpenApiSpec', {
  enumerable: true,
  get: function () {
    return parseOpenApiSpec;
  }
});
Object.defineProperty(exports, 'postprocessOutput', {
  enumerable: true,
  get: function () {
    return postprocessOutput;
  }
});
Object.defineProperty(exports, 'printCrashReport', {
  enumerable: true,
  get: function () {
    return printCrashReport;
  }
});
Object.defineProperty(exports, 'regexp', {
  enumerable: true,
  get: function () {
    return regexp;
  }
});
Object.defineProperty(exports, 'reserved', {
  enumerable: true,
  get: function () {
    return reserved;
  }
});
Object.defineProperty(exports, 'resolveJobs', {
  enumerable: true,
  get: function () {
    return resolveJobs;
  }
});
Object.defineProperty(exports, 'shouldReportCrash', {
  enumerable: true,
  get: function () {
    return shouldReportCrash;
  }
});
Object.defineProperty(exports, 'toCase', {
  enumerable: true,
  get: function () {
    return toCase;
  }
});
//# sourceMappingURL=openApi-Dy5wknYZ.cjs.map