{"version":3,"file":"src-YIQMkx2V.mjs","names":["path","path","result: Pick<\n    Partial<Input>,\n    | 'api_key'\n    | 'branch'\n    | 'commit_sha'\n    | 'organization'\n    | 'project'\n    | 'registry'\n    | 'tags'\n    | 'version'\n  > &\n    Pick<Input, 'path'>","path","queryParams: Array<string>","lines: Array<string>","createClient","watches: ReadonlyArray<WatchValues>","context: Context | undefined","data","lines: Array<string>","jobs: Configs['jobs']","pCreateClient"],"sources":["../src/config/engine.ts","../src/ir/intents.ts","../src/generate/output.ts","../src/openApi/shared/utils/patch.ts","../src/createClient.ts","../src/utils/cli.ts","../src/generate.ts","../src/utils/exports.ts","../src/index.ts"],"sourcesContent":["import { ConfigError } from '~/error';\n\nexport const checkNodeVersion = () => {\n  if (typeof Bun !== 'undefined') {\n    const [major] = Bun.version.split('.').map(Number);\n    if (major! < 1) {\n      throw new ConfigError(\n        `Unsupported Bun version ${Bun.version}. Please use Bun 1.0.0 or newer.`,\n      );\n    }\n  } else if (typeof process !== 'undefined' && process.versions?.node) {\n    const [major] = process.versions.node.split('.').map(Number);\n    if (major! < 20) {\n      throw new ConfigError(\n        `Unsupported Node version ${process.versions.node}. Please use Node 20 or newer.`,\n      );\n    }\n  }\n};\n","import type { MaybePromise } from '@hey-api/types';\n\nimport type { CodeSampleObject } from '~/openApi/shared/types';\n\nimport type { IR } from './types';\n\nexport interface ExampleIntent {\n  run(ctx: IntentContext): MaybePromise<void>;\n}\n\nexport class IntentContext<Spec extends Record<string, any> = any> {\n  private spec: Spec;\n\n  constructor(spec: Spec) {\n    this.spec = spec;\n  }\n\n  private getOperation(\n    path: string,\n    method: string,\n  ): Record<string, any> | undefined {\n    const paths = (this.spec as any).paths;\n    if (!paths) return;\n    return paths[path]?.[method];\n  }\n\n  setExample(operation: IR.OperationObject, example: CodeSampleObject): void {\n    const source = this.getOperation(operation.path, operation.method);\n    if (!source) return;\n    source['x-codeSamples'] ||= [];\n    source['x-codeSamples'].push(example);\n  }\n}\n","import fs from 'node:fs';\nimport path from 'node:path';\n\nimport type { Context } from '~/ir/context';\nimport { IntentContext } from '~/ir/intents';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\n\nimport { generateClientBundle } from './client';\n\nexport const generateOutput = async ({ context }: { context: Context }) => {\n  const outputPath = path.resolve(context.config.output.path);\n\n  if (context.config.output.clean) {\n    if (fs.existsSync(outputPath)) {\n      fs.rmSync(outputPath, { force: true, recursive: true });\n    }\n  }\n\n  const client = getClientPlugin(context.config);\n  if (\n    'bundle' in client.config &&\n    client.config.bundle &&\n    !context.config.dryRun\n  ) {\n    // not proud of this one\n    // @ts-expect-error\n    context.config._FRAGILE_CLIENT_BUNDLE_RENAMED = generateClientBundle({\n      meta: {\n        importFileExtension: context.config.output.importFileExtension,\n      },\n      outputPath,\n      // @ts-expect-error\n      plugin: client,\n      project: context.gen,\n    });\n  }\n\n  for (const plugin of context.registerPlugins()) {\n    await plugin.run();\n  }\n\n  context.gen.plan();\n\n  const ctx = new IntentContext(context.spec);\n  for (const intent of context.intents) {\n    await intent.run(ctx);\n  }\n\n  for (const file of context.gen.render()) {\n    const filePath = path.resolve(outputPath, file.path);\n    const dir = path.dirname(filePath);\n    if (!context.config.dryRun) {\n      fs.mkdirSync(dir, { recursive: true });\n      fs.writeFileSync(filePath, file.content, { encoding: 'utf8' });\n    }\n  }\n\n  const { source } = context.config.output;\n  if (source.enabled) {\n    const sourcePath =\n      source.path === null ? undefined : path.resolve(outputPath, source.path);\n    if (!context.config.dryRun && sourcePath && sourcePath !== outputPath) {\n      fs.mkdirSync(sourcePath, { recursive: true });\n    }\n    const serialized = await source.serialize(context.spec);\n    // TODO: handle yaml (convert before writing)\n    if (!context.config.dryRun && sourcePath) {\n      fs.writeFileSync(\n        path.resolve(sourcePath, `${source.fileName}.${source.extension}`),\n        serialized,\n        { encoding: 'utf8' },\n      );\n    }\n    if (source.callback) {\n      await source.callback(serialized);\n    }\n  }\n};\n","import type { OpenApi } from '~/openApi/types';\n\nimport type { Patch } from '../../../types/parser';\n\nexport const patchOpenApiSpec = ({\n  patchOptions,\n  spec: _spec,\n}: {\n  patchOptions: Patch | undefined;\n  spec: unknown;\n}) => {\n  if (!patchOptions) {\n    return;\n  }\n\n  const spec = _spec as OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X;\n\n  if ('swagger' in spec) {\n    if (patchOptions.version && spec.swagger) {\n      spec.swagger = (\n        typeof patchOptions.version === 'string'\n          ? patchOptions.version\n          : patchOptions.version(spec.swagger)\n      ) as typeof spec.swagger;\n    }\n\n    if (patchOptions.meta && spec.info) {\n      patchOptions.meta(spec.info);\n    }\n\n    if (patchOptions.schemas && spec.definitions) {\n      for (const key in patchOptions.schemas) {\n        const schema = spec.definitions[key];\n        if (!schema || typeof schema !== 'object') continue;\n\n        const patchFn = patchOptions.schemas[key]!;\n        patchFn(schema);\n      }\n    }\n\n    if (patchOptions.operations && spec.paths) {\n      for (const key in patchOptions.operations) {\n        const [method, path] = key.split(' ');\n        if (!method || !path) continue;\n\n        const pathItem = spec.paths[path as keyof typeof spec.paths];\n        if (!pathItem) continue;\n\n        const operation =\n          pathItem[method.toLocaleLowerCase() as keyof typeof pathItem] ||\n          pathItem[method.toLocaleUpperCase() as keyof typeof pathItem];\n        if (!operation || typeof operation !== 'object') continue;\n\n        const patchFn = patchOptions.operations[key]!;\n        patchFn(operation as any);\n      }\n    }\n    return;\n  }\n\n  if (patchOptions.version && spec.openapi) {\n    spec.openapi = (\n      typeof patchOptions.version === 'string'\n        ? patchOptions.version\n        : patchOptions.version(spec.openapi)\n    ) as typeof spec.openapi;\n  }\n\n  if (patchOptions.meta && spec.info) {\n    patchOptions.meta(spec.info);\n  }\n\n  if (spec.components) {\n    if (patchOptions.schemas && spec.components.schemas) {\n      for (const key in patchOptions.schemas) {\n        const schema = spec.components.schemas[key];\n        if (!schema || typeof schema !== 'object') continue;\n\n        const patchFn = patchOptions.schemas[key]!;\n        patchFn(schema as Parameters<typeof patchFn>[0]);\n      }\n    }\n\n    if (patchOptions.parameters && spec.components.parameters) {\n      for (const key in patchOptions.parameters) {\n        const schema = spec.components.parameters[key];\n        if (!schema || typeof schema !== 'object') continue;\n\n        const patchFn = patchOptions.parameters[key]!;\n        patchFn(schema);\n      }\n    }\n\n    if (patchOptions.requestBodies && spec.components.requestBodies) {\n      for (const key in patchOptions.requestBodies) {\n        const schema = spec.components.requestBodies[key];\n        if (!schema || typeof schema !== 'object') continue;\n\n        const patchFn = patchOptions.requestBodies[key]!;\n        patchFn(schema);\n      }\n    }\n\n    if (patchOptions.responses && spec.components.responses) {\n      for (const key in patchOptions.responses) {\n        const schema = spec.components.responses[key];\n        if (!schema || typeof schema !== 'object') continue;\n\n        const patchFn = patchOptions.responses[key]!;\n        patchFn(schema);\n      }\n    }\n  }\n\n  if (patchOptions.operations && spec.paths) {\n    for (const key in patchOptions.operations) {\n      const [method, path] = key.split(' ');\n      if (!method || !path) continue;\n\n      const pathItem = spec.paths[path as keyof typeof spec.paths];\n      if (!pathItem) continue;\n\n      const operation =\n        pathItem[method.toLocaleLowerCase() as keyof typeof pathItem] ||\n        pathItem[method.toLocaleUpperCase() as keyof typeof pathItem];\n      if (!operation || typeof operation !== 'object') continue;\n\n      const patchFn = patchOptions.operations[key]!;\n      patchFn(operation as any);\n    }\n  }\n};\n","import path from 'node:path';\n\nimport type { Logger } from '@hey-api/codegen-core';\nimport { $RefParser } from '@hey-api/json-schema-ref-parser';\nimport colors from 'ansi-colors';\n\nimport { postprocessOutput } from '~/config/output';\nimport type { Config } from '~/config/types';\nimport { generateOutput } from '~/generate/output';\nimport { getSpec } from '~/getSpec';\nimport type { Context } from '~/ir/context';\nimport { parseOpenApiSpec } from '~/openApi';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { patchOpenApiSpec } from '~/openApi/shared/utils/patch';\nimport type { Input } from '~/types/input';\nimport type { WatchValues } from '~/types/types';\n\nexport const compileInputPath = (input: Omit<Input, 'watch'>) => {\n  const result: Pick<\n    Partial<Input>,\n    | 'api_key'\n    | 'branch'\n    | 'commit_sha'\n    | 'organization'\n    | 'project'\n    | 'registry'\n    | 'tags'\n    | 'version'\n  > &\n    Pick<Input, 'path'> = {\n    ...input,\n    path: '',\n  };\n\n  if (\n    input.path &&\n    (typeof input.path !== 'string' || input.registry !== 'hey-api')\n  ) {\n    result.path = input.path;\n    return result;\n  }\n\n  const [basePath, baseQuery] = input.path.split('?');\n  const queryParts = (baseQuery || '').split('&');\n  const queryPath = queryParts.map((part) => part.split('='));\n\n  let path = basePath || '';\n  if (path.endsWith('/')) {\n    path = path.slice(0, path.length - 1);\n  }\n\n  const [, pathUrl] = path.split('://');\n  const [baseUrl, organization, project] = (pathUrl || '').split('/');\n  result.organization = organization || input.organization;\n  result.project = project || input.project;\n\n  const queryParams: Array<string> = [];\n\n  const kApiKey = 'api_key';\n  result.api_key =\n    queryPath.find(([key]) => key === kApiKey)?.[1] ||\n    input.api_key ||\n    process.env.HEY_API_TOKEN;\n  if (result.api_key) {\n    queryParams.push(`${kApiKey}=${result.api_key}`);\n  }\n\n  const kBranch = 'branch';\n  result.branch =\n    queryPath.find(([key]) => key === kBranch)?.[1] || input.branch;\n  if (result.branch) {\n    queryParams.push(`${kBranch}=${result.branch}`);\n  }\n\n  const kCommitSha = 'commit_sha';\n  result.commit_sha =\n    queryPath.find(([key]) => key === kCommitSha)?.[1] || input.commit_sha;\n  if (result.commit_sha) {\n    queryParams.push(`${kCommitSha}=${result.commit_sha}`);\n  }\n\n  const kTags = 'tags';\n  result.tags =\n    queryPath.find(([key]) => key === kTags)?.[1]?.split(',') || input.tags;\n  if (result.tags?.length) {\n    queryParams.push(`${kTags}=${result.tags.join(',')}`);\n  }\n\n  const kVersion = 'version';\n  result.version =\n    queryPath.find(([key]) => key === kVersion)?.[1] || input.version;\n  if (result.version) {\n    queryParams.push(`${kVersion}=${result.version}`);\n  }\n\n  if (!result.organization) {\n    throw new Error(\n      'missing organization - from which Hey API Platform organization do you want to generate your output?',\n    );\n  }\n\n  if (!result.project) {\n    throw new Error(\n      'missing project - from which Hey API Platform project do you want to generate your output?',\n    );\n  }\n\n  const query = queryParams.join('&');\n  const platformUrl = baseUrl || 'get.heyapi.dev';\n  const isLocalhost = platformUrl.startsWith('localhost');\n  const platformUrlWithProtocol = [\n    isLocalhost ? 'http' : 'https',\n    platformUrl,\n  ].join('://');\n  const compiledPath = isLocalhost\n    ? [\n        platformUrlWithProtocol,\n        'v1',\n        'get',\n        result.organization,\n        result.project,\n      ].join('/')\n    : [platformUrlWithProtocol, result.organization, result.project].join('/');\n  result.path = query ? `${compiledPath}?${query}` : compiledPath;\n\n  return result;\n};\n\nconst logInputPaths = (\n  inputPaths: ReadonlyArray<ReturnType<typeof compileInputPath>>,\n  jobIndex: number,\n) => {\n  const lines: Array<string> = [];\n\n  const jobPrefix = colors.gray(`[Job ${jobIndex + 1}] `);\n  const count = inputPaths.length;\n  const baseString = colors.cyan(\n    `Generating from ${count} ${count === 1 ? 'input' : 'inputs'}:`,\n  );\n  lines.push(`${jobPrefix}⏳ ${baseString}`);\n\n  inputPaths.forEach((inputPath, index) => {\n    const itemPrefixStr = `  [${index + 1}] `;\n    const itemPrefix = colors.cyan(itemPrefixStr);\n    const detailIndent = ' '.repeat(itemPrefixStr.length);\n\n    if (typeof inputPath.path !== 'string') {\n      lines.push(`${jobPrefix}${itemPrefix}raw OpenAPI specification`);\n      return;\n    }\n\n    switch (inputPath.registry) {\n      case 'hey-api': {\n        const baseInput = [inputPath.organization, inputPath.project]\n          .filter(Boolean)\n          .join('/');\n        lines.push(`${jobPrefix}${itemPrefix}${baseInput}`);\n        if (inputPath.branch) {\n          lines.push(\n            `${jobPrefix}${detailIndent}${colors.gray('branch:')} ${colors.green(\n              inputPath.branch,\n            )}`,\n          );\n        }\n        if (inputPath.commit_sha) {\n          lines.push(\n            `${jobPrefix}${detailIndent}${colors.gray('commit:')} ${colors.green(\n              inputPath.commit_sha,\n            )}`,\n          );\n        }\n        if (inputPath.tags?.length) {\n          lines.push(\n            `${jobPrefix}${detailIndent}${colors.gray('tags:')} ${colors.green(\n              inputPath.tags.join(', '),\n            )}`,\n          );\n        }\n        if (inputPath.version) {\n          lines.push(\n            `${jobPrefix}${detailIndent}${colors.gray('version:')} ${colors.green(\n              inputPath.version,\n            )}`,\n          );\n        }\n        lines.push(\n          `${jobPrefix}${detailIndent}${colors.gray('registry:')} ${colors.green('Hey API')}`,\n        );\n        break;\n      }\n      case 'readme': {\n        const baseInput = [inputPath.organization, inputPath.project]\n          .filter(Boolean)\n          .join('/');\n        if (!baseInput) {\n          lines.push(`${jobPrefix}${itemPrefix}${inputPath.path}`);\n        } else {\n          lines.push(`${jobPrefix}${itemPrefix}${baseInput}`);\n        }\n        // @ts-expect-error\n        if (inputPath.uuid) {\n          lines.push(\n            `${jobPrefix}${detailIndent}${colors.gray('uuid:')} ${colors.green(\n              // @ts-expect-error\n              inputPath.uuid,\n            )}`,\n          );\n        }\n        lines.push(\n          `${jobPrefix}${detailIndent}${colors.gray('registry:')} ${colors.green('ReadMe')}`,\n        );\n        break;\n      }\n      case 'scalar': {\n        const baseInput = [inputPath.organization, inputPath.project]\n          .filter(Boolean)\n          .join('/');\n        lines.push(`${jobPrefix}${itemPrefix}${baseInput}`);\n        lines.push(\n          `${jobPrefix}${detailIndent}${colors.gray('registry:')} ${colors.green('Scalar')}`,\n        );\n        break;\n      }\n      default:\n        lines.push(`${jobPrefix}${itemPrefix}${inputPath.path}`);\n        break;\n    }\n  });\n\n  for (const line of lines) {\n    console.log(line);\n  }\n};\n\nexport const createClient = async ({\n  config,\n  dependencies,\n  jobIndex,\n  logger,\n  watches: _watches,\n}: {\n  config: Config;\n  dependencies: Record<string, string>;\n  jobIndex: number;\n  logger: Logger;\n  /**\n   * Always undefined on the first run, defined on subsequent runs.\n   */\n  watches?: ReadonlyArray<WatchValues>;\n}): Promise<Context | undefined> => {\n  const watches: ReadonlyArray<WatchValues> =\n    _watches ||\n    Array.from({ length: config.input.length }, () => ({\n      headers: new Headers(),\n    }));\n\n  const inputPaths = config.input.map((input) => compileInputPath(input));\n\n  // on first run, print the message as soon as possible\n  if (config.logs.level !== 'silent' && !_watches) {\n    logInputPaths(inputPaths, jobIndex);\n  }\n\n  const getSpecData = async (input: Input, index: number) => {\n    const eventSpec = logger.timeEvent('spec');\n    const { arrayBuffer, error, resolvedInput, response } = await getSpec({\n      fetchOptions: input.fetch,\n      inputPath: inputPaths[index]!.path,\n      timeout: input.watch.timeout,\n      watch: watches[index]!,\n    });\n    eventSpec.timeEnd();\n\n    // throw on first run if there's an error to preserve user experience\n    // if in watch mode, subsequent errors won't throw to gracefully handle\n    // cases where server might be reloading\n    if (error && !_watches) {\n      throw new Error(\n        `Request failed with status ${response.status}: ${response.statusText}`,\n      );\n    }\n\n    return { arrayBuffer, resolvedInput };\n  };\n  const specData = (\n    await Promise.all(\n      config.input.map((input, index) => getSpecData(input, index)),\n    )\n  ).filter((data) => data.arrayBuffer || data.resolvedInput);\n\n  let context: Context | undefined;\n\n  if (specData.length) {\n    const refParser = new $RefParser();\n    const data =\n      specData.length > 1\n        ? await refParser.bundleMany({\n            arrayBuffer: specData.map((data) => data.arrayBuffer!),\n            pathOrUrlOrSchemas: [],\n            resolvedInputs: specData.map((data) => data.resolvedInput!),\n          })\n        : await refParser.bundle({\n            arrayBuffer: specData[0]!.arrayBuffer,\n            pathOrUrlOrSchema: undefined,\n            resolvedInput: specData[0]!.resolvedInput,\n          });\n\n    // on subsequent runs in watch mode, print the message only if we know we're\n    // generating the output\n    if (config.logs.level !== 'silent' && _watches) {\n      console.clear();\n      logInputPaths(inputPaths, jobIndex);\n    }\n\n    const eventInputPatch = logger.timeEvent('input.patch');\n    patchOpenApiSpec({ patchOptions: config.parser.patch, spec: data });\n    eventInputPatch.timeEnd();\n\n    const eventParser = logger.timeEvent('parser');\n    context = parseOpenApiSpec({ config, dependencies, logger, spec: data });\n    context.graph = buildGraph(context.ir, logger).graph;\n    eventParser.timeEnd();\n\n    const eventGenerator = logger.timeEvent('generator');\n    await generateOutput({ context });\n    eventGenerator.timeEnd();\n\n    const eventPostprocess = logger.timeEvent('postprocess');\n    if (!config.dryRun) {\n      const jobPrefix = colors.gray(`[Job ${jobIndex + 1}] `);\n      postprocessOutput(config.output, jobPrefix);\n\n      if (config.logs.level !== 'silent') {\n        const outputPath = process.env.INIT_CWD\n          ? `./${path.relative(process.env.INIT_CWD, config.output.path)}`\n          : config.output.path;\n        console.log(\n          `${jobPrefix}${colors.green('✅ Done!')} Your output is in ${colors.cyanBright(outputPath)}`,\n        );\n      }\n    }\n    eventPostprocess.timeEnd();\n  }\n\n  const watchedInput = config.input.find(\n    (input, index) =>\n      input.watch.enabled && typeof inputPaths[index]!.path === 'string',\n  );\n\n  if (watchedInput) {\n    setTimeout(() => {\n      createClient({\n        config,\n        dependencies,\n        jobIndex,\n        logger,\n        watches,\n      });\n    }, watchedInput.watch.interval);\n  }\n\n  return context;\n};\n","import colors from 'ansi-colors';\n\nimport { loadPackageJson } from '~/generate/tsConfig';\n\nconst textAscii = `\n888   |                           e      888~-_   888\n888___|  e88~~8e  Y88b  /        d8b     888   \\\\  888\n888   | d888  88b  Y888/        /Y88b    888    | 888\n888   | 8888__888   Y8/        /  Y88b   888   /  888\n888   | Y888    ,    Y        /____Y88b  888_-~   888\n888   |  \"88___/    /        /      Y88b 888      888\n                  _/\n`;\n\nconst asciiToLines = (\n  ascii: string,\n  options?: {\n    padding?: number;\n  },\n) => {\n  const lines: Array<string> = [];\n  const padding = Array.from<string>({ length: options?.padding ?? 0 }).fill(\n    '',\n  );\n  lines.push(...padding);\n  let maxLineLength = 0;\n  let line = '';\n  for (const char of ascii) {\n    if (char === '\\n') {\n      if (line) {\n        lines.push(line);\n        maxLineLength = Math.max(maxLineLength, line.length);\n        line = '';\n      }\n    } else {\n      line += char;\n    }\n  }\n  lines.push(...padding);\n  return { lines, maxLineLength };\n};\n\n// TODO: show ascii logo only in `--help` and `--version` commands\nexport function printCliIntro(showLogo: boolean = false): void {\n  const packageJson = loadPackageJson();\n  if (showLogo) {\n    const text = asciiToLines(textAscii, { padding: 1 });\n    for (const line of text.lines) {\n      console.log(colors.cyan(line));\n    }\n  }\n  console.log(colors.gray(`${packageJson.name} v${packageJson.version}`));\n  console.log('');\n}\n","import { Logger } from '@hey-api/codegen-core';\nimport type { LazyOrAsync, MaybeArray } from '@hey-api/types';\n\nimport { checkNodeVersion } from '~/config/engine';\nimport type { Configs } from '~/config/init';\nimport { resolveJobs } from '~/config/init';\nimport { getLogs } from '~/config/logs';\nimport type { UserConfig } from '~/config/types';\nimport { createClient as pCreateClient } from '~/createClient';\nimport {\n  ConfigValidationError,\n  JobError,\n  logCrashReport,\n  openGitHubIssueWithCrashReport,\n  printCrashReport,\n  shouldReportCrash,\n} from '~/error';\nimport type { Context } from '~/ir/context';\nimport { printCliIntro } from '~/utils/cli';\n\n/**\n * Generate a client from the provided configuration.\n *\n * @param userConfig User provided {@link UserConfig} configuration(s).\n */\nexport async function createClient(\n  userConfig?: LazyOrAsync<MaybeArray<UserConfig>>,\n  logger = new Logger(),\n): Promise<ReadonlyArray<Context>> {\n  const resolvedConfig =\n    typeof userConfig === 'function' ? await userConfig() : userConfig;\n  const userConfigs = resolvedConfig\n    ? resolvedConfig instanceof Array\n      ? resolvedConfig\n      : [resolvedConfig]\n    : [];\n\n  let rawLogs = userConfigs.find(\n    (config) => getLogs(config).level !== 'silent',\n  )?.logs;\n  if (typeof rawLogs === 'string') {\n    rawLogs = getLogs({ logs: rawLogs });\n  }\n\n  let jobs: Configs['jobs'] = [];\n\n  try {\n    checkNodeVersion();\n\n    const eventCreateClient = logger.timeEvent('createClient');\n\n    const eventConfig = logger.timeEvent('config');\n    const resolved = await resolveJobs({ logger, userConfigs });\n    const dependencies = resolved.dependencies;\n    jobs = resolved.jobs;\n    const printIntro = jobs.some((job) => job.config.logs.level !== 'silent');\n    if (printIntro) printCliIntro();\n    eventConfig.timeEnd();\n\n    const configErrors = jobs.flatMap((job) =>\n      job.errors.map((error) => ({ error, jobIndex: job.index })),\n    );\n    if (configErrors.length > 0) {\n      throw new ConfigValidationError(configErrors);\n    }\n\n    const outputs = await Promise.all(\n      jobs.map(async (job) => {\n        try {\n          return await pCreateClient({\n            config: job.config,\n            dependencies,\n            jobIndex: job.index,\n            logger,\n          });\n        } catch (error) {\n          throw new JobError('', {\n            error,\n            jobIndex: job.index,\n          });\n        }\n      }),\n    );\n    const contexts = outputs.filter((ctx): ctx is Context => ctx !== undefined);\n\n    eventCreateClient.timeEnd();\n\n    logger.report(jobs.some((job) => job.config.logs.level === 'debug'));\n\n    return contexts;\n  } catch (error) {\n    const logs =\n      jobs.find((job) => job.config.logs.level !== 'silent')?.config.logs ??\n      jobs[0]?.config.logs ??\n      rawLogs;\n    const dryRun =\n      jobs.some((job) => job.config.dryRun) ??\n      userConfigs.some((config) => config.dryRun) ??\n      false;\n    const logPath =\n      logs?.file && !dryRun\n        ? logCrashReport(error, logs.path ?? '')\n        : undefined;\n    if (!logs || logs.level !== 'silent') {\n      printCrashReport({ error, logPath });\n      const isInteractive =\n        jobs.some((job) => job.config.interactive) ??\n        userConfigs.some((config) => config.interactive) ??\n        false;\n      if (await shouldReportCrash({ error, isInteractive })) {\n        await openGitHubIssueWithCrashReport(error);\n      }\n    }\n\n    throw error;\n  }\n}\n","import type { Casing } from './naming';\nimport { toCase } from './naming';\n\n/**\n * Utilities shared across the package.\n */\nexport const utils = {\n  /**\n   * @deprecated use `toCase` instead\n   */\n  stringCase({\n    case: casing,\n    stripLeadingSeparators,\n    value,\n  }: {\n    readonly case: Casing | undefined;\n    /**\n     * If leading separators have a semantic meaning, we might not want to\n     * remove them.\n     */\n    stripLeadingSeparators?: boolean;\n    value: string;\n  }) {\n    return toCase(value, casing, { stripLeadingSeparators });\n  },\n  /**\n   * Converts the given string to the specified casing.\n   */\n  toCase,\n};\n","// OVERRIDES\n// hard-coded here because build process doesn't pick up overrides from separate files\nimport '@hey-api/codegen-core';\n\ndeclare module '@hey-api/codegen-core' {\n  interface ProjectRenderMeta {\n    /**\n     * If specified, this will be the file extension used when importing\n     * other modules. By default, we don't add a file extension and let the\n     * runtime resolve it.\n     *\n     * @default null\n     */\n    importFileExtension?: (string & {}) | null;\n  }\n\n  interface SymbolMeta {\n    category?:\n      | 'client'\n      | 'external'\n      | 'hook'\n      | 'schema'\n      | 'sdk'\n      | 'transform'\n      | 'type'\n      | 'utility'\n      | (string & {});\n    /**\n     * Path to the resource this symbol represents.\n     */\n    path?: ReadonlyArray<string | number>;\n    /**\n     * Name of the plugin that registered this symbol.\n     */\n    pluginName?: string;\n    resource?:\n      | 'client'\n      | 'definition'\n      | 'operation'\n      | 'webhook'\n      | (string & {});\n    resourceId?: string;\n    role?:\n      | 'data'\n      | 'error'\n      | 'errors'\n      | 'options'\n      | 'response'\n      | 'responses'\n      | (string & {});\n    /**\n     * Tags associated with this symbol.\n     */\n    tags?: ReadonlyArray<string>;\n    tool?:\n      | 'angular'\n      | 'arktype'\n      | 'fastify'\n      | 'json-schema'\n      | 'sdk'\n      | 'typescript'\n      | 'valibot'\n      | 'zod'\n      | (string & {});\n    variant?: 'container' | (string & {});\n  }\n}\n// END OVERRIDES\n\nimport type { LazyOrAsync, MaybeArray } from '@hey-api/types';\nimport colors from 'ansi-colors';\n// @ts-expect-error\nimport colorSupport from 'color-support';\n\nimport type { UserConfig } from '~/config/types';\n\ncolors.enabled = colorSupport().hasBasic;\n\nexport { createClient } from '~/generate';\n\n/**\n * Type helper for configuration object, returns {@link MaybeArray<UserConfig>} object(s)\n */\nexport async function defineConfig<T extends MaybeArray<UserConfig>>(\n  config: LazyOrAsync<T>,\n): Promise<T> {\n  return typeof config === 'function' ? await config() : config;\n}\n\nexport { Logger } from '@hey-api/codegen-core';\nexport { defaultPaginationKeywords } from '~/config/parser';\nexport { defaultPlugins } from '~/config/plugins';\nexport type { UserConfig } from '~/config/types';\nexport type { IR } from '~/ir/types';\nexport { OperationPath, OperationStrategy } from '~/openApi/shared/locations';\nexport type {\n  OpenApi,\n  OpenApiMetaObject,\n  OpenApiOperationObject,\n  OpenApiParameterObject,\n  OpenApiRequestBodyObject,\n  OpenApiResponseObject,\n  OpenApiSchemaObject,\n} from '~/openApi/types';\nexport type { DefinePlugin, Plugin } from '~/plugins';\nexport type { AngularClient } from '~/plugins/@hey-api/client-angular';\nexport type { AxiosClient } from '~/plugins/@hey-api/client-axios';\nexport {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nexport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nexport type { Client } from '~/plugins/@hey-api/client-core/types';\nexport type { FetchClient } from '~/plugins/@hey-api/client-fetch';\nexport type { NextClient } from '~/plugins/@hey-api/client-next';\nexport type { NuxtClient } from '~/plugins/@hey-api/client-nuxt';\nexport type { OfetchClient } from '~/plugins/@hey-api/client-ofetch';\nexport type { ExpressionTransformer } from '~/plugins/@hey-api/transformers/expressions';\nexport type { TypeTransformer } from '~/plugins/@hey-api/transformers/types';\nexport { definePluginConfig } from '~/plugins/shared/utils/config';\nexport * from '~/ts-dsl';\nexport { utils } from '~/utils/exports';\n"],"mappings":";;;;;;;;;;AAEA,MAAa,yBAAyB;AACpC,KAAI,OAAO,QAAQ,aAAa;EAC9B,MAAM,CAAC,SAAS,IAAI,QAAQ,MAAM,IAAI,CAAC,IAAI,OAAO;AAClD,MAAI,QAAS,EACX,OAAM,IAAI,YACR,2BAA2B,IAAI,QAAQ,kCACxC;YAEM,OAAO,YAAY,eAAe,QAAQ,UAAU,MAAM;EACnE,MAAM,CAAC,SAAS,QAAQ,SAAS,KAAK,MAAM,IAAI,CAAC,IAAI,OAAO;AAC5D,MAAI,QAAS,GACX,OAAM,IAAI,YACR,4BAA4B,QAAQ,SAAS,KAAK,gCACnD;;;;;;ACLP,IAAa,gBAAb,MAAmE;CACjE,AAAQ;CAER,YAAY,MAAY;AACtB,OAAK,OAAO;;CAGd,AAAQ,aACN,QACA,QACiC;EACjC,MAAM,QAAS,KAAK,KAAa;AACjC,MAAI,CAAC,MAAO;AACZ,SAAO,MAAMA,UAAQ;;CAGvB,WAAW,WAA+B,SAAiC;EACzE,MAAM,SAAS,KAAK,aAAa,UAAU,MAAM,UAAU,OAAO;AAClE,MAAI,CAAC,OAAQ;AACb,SAAO,qBAAqB,EAAE;AAC9B,SAAO,iBAAiB,KAAK,QAAQ;;;;;;ACrBzC,MAAa,iBAAiB,OAAO,EAAE,cAAoC;CACzE,MAAM,aAAa,KAAK,QAAQ,QAAQ,OAAO,OAAO,KAAK;AAE3D,KAAI,QAAQ,OAAO,OAAO,OACxB;MAAI,GAAG,WAAW,WAAW,CAC3B,IAAG,OAAO,YAAY;GAAE,OAAO;GAAM,WAAW;GAAM,CAAC;;CAI3D,MAAM,SAAS,gBAAgB,QAAQ,OAAO;AAC9C,KACE,YAAY,OAAO,UACnB,OAAO,OAAO,UACd,CAAC,QAAQ,OAAO,OAIhB,SAAQ,OAAO,iCAAiC,qBAAqB;EACnE,MAAM,EACJ,qBAAqB,QAAQ,OAAO,OAAO,qBAC5C;EACD;EAEA,QAAQ;EACR,SAAS,QAAQ;EAClB,CAAC;AAGJ,MAAK,MAAM,UAAU,QAAQ,iBAAiB,CAC5C,OAAM,OAAO,KAAK;AAGpB,SAAQ,IAAI,MAAM;CAElB,MAAM,MAAM,IAAI,cAAc,QAAQ,KAAK;AAC3C,MAAK,MAAM,UAAU,QAAQ,QAC3B,OAAM,OAAO,IAAI,IAAI;AAGvB,MAAK,MAAM,QAAQ,QAAQ,IAAI,QAAQ,EAAE;EACvC,MAAM,WAAW,KAAK,QAAQ,YAAY,KAAK,KAAK;EACpD,MAAM,MAAM,KAAK,QAAQ,SAAS;AAClC,MAAI,CAAC,QAAQ,OAAO,QAAQ;AAC1B,MAAG,UAAU,KAAK,EAAE,WAAW,MAAM,CAAC;AACtC,MAAG,cAAc,UAAU,KAAK,SAAS,EAAE,UAAU,QAAQ,CAAC;;;CAIlE,MAAM,EAAE,WAAW,QAAQ,OAAO;AAClC,KAAI,OAAO,SAAS;EAClB,MAAM,aACJ,OAAO,SAAS,OAAO,SAAY,KAAK,QAAQ,YAAY,OAAO,KAAK;AAC1E,MAAI,CAAC,QAAQ,OAAO,UAAU,cAAc,eAAe,WACzD,IAAG,UAAU,YAAY,EAAE,WAAW,MAAM,CAAC;EAE/C,MAAM,aAAa,MAAM,OAAO,UAAU,QAAQ,KAAK;AAEvD,MAAI,CAAC,QAAQ,OAAO,UAAU,WAC5B,IAAG,cACD,KAAK,QAAQ,YAAY,GAAG,OAAO,SAAS,GAAG,OAAO,YAAY,EAClE,YACA,EAAE,UAAU,QAAQ,CACrB;AAEH,MAAI,OAAO,SACT,OAAM,OAAO,SAAS,WAAW;;;;;;ACtEvC,MAAa,oBAAoB,EAC/B,cACA,MAAM,YAIF;AACJ,KAAI,CAAC,aACH;CAGF,MAAM,OAAO;AAEb,KAAI,aAAa,MAAM;AACrB,MAAI,aAAa,WAAW,KAAK,QAC/B,MAAK,UACH,OAAO,aAAa,YAAY,WAC5B,aAAa,UACb,aAAa,QAAQ,KAAK,QAAQ;AAI1C,MAAI,aAAa,QAAQ,KAAK,KAC5B,cAAa,KAAK,KAAK,KAAK;AAG9B,MAAI,aAAa,WAAW,KAAK,YAC/B,MAAK,MAAM,OAAO,aAAa,SAAS;GACtC,MAAM,SAAS,KAAK,YAAY;AAChC,OAAI,CAAC,UAAU,OAAO,WAAW,SAAU;GAE3C,MAAM,UAAU,aAAa,QAAQ;AACrC,WAAQ,OAAO;;AAInB,MAAI,aAAa,cAAc,KAAK,MAClC,MAAK,MAAM,OAAO,aAAa,YAAY;GACzC,MAAM,CAAC,QAAQC,UAAQ,IAAI,MAAM,IAAI;AACrC,OAAI,CAAC,UAAU,CAACA,OAAM;GAEtB,MAAM,WAAW,KAAK,MAAMA;AAC5B,OAAI,CAAC,SAAU;GAEf,MAAM,YACJ,SAAS,OAAO,mBAAmB,KACnC,SAAS,OAAO,mBAAmB;AACrC,OAAI,CAAC,aAAa,OAAO,cAAc,SAAU;GAEjD,MAAM,UAAU,aAAa,WAAW;AACxC,WAAQ,UAAiB;;AAG7B;;AAGF,KAAI,aAAa,WAAW,KAAK,QAC/B,MAAK,UACH,OAAO,aAAa,YAAY,WAC5B,aAAa,UACb,aAAa,QAAQ,KAAK,QAAQ;AAI1C,KAAI,aAAa,QAAQ,KAAK,KAC5B,cAAa,KAAK,KAAK,KAAK;AAG9B,KAAI,KAAK,YAAY;AACnB,MAAI,aAAa,WAAW,KAAK,WAAW,QAC1C,MAAK,MAAM,OAAO,aAAa,SAAS;GACtC,MAAM,SAAS,KAAK,WAAW,QAAQ;AACvC,OAAI,CAAC,UAAU,OAAO,WAAW,SAAU;GAE3C,MAAM,UAAU,aAAa,QAAQ;AACrC,WAAQ,OAAwC;;AAIpD,MAAI,aAAa,cAAc,KAAK,WAAW,WAC7C,MAAK,MAAM,OAAO,aAAa,YAAY;GACzC,MAAM,SAAS,KAAK,WAAW,WAAW;AAC1C,OAAI,CAAC,UAAU,OAAO,WAAW,SAAU;GAE3C,MAAM,UAAU,aAAa,WAAW;AACxC,WAAQ,OAAO;;AAInB,MAAI,aAAa,iBAAiB,KAAK,WAAW,cAChD,MAAK,MAAM,OAAO,aAAa,eAAe;GAC5C,MAAM,SAAS,KAAK,WAAW,cAAc;AAC7C,OAAI,CAAC,UAAU,OAAO,WAAW,SAAU;GAE3C,MAAM,UAAU,aAAa,cAAc;AAC3C,WAAQ,OAAO;;AAInB,MAAI,aAAa,aAAa,KAAK,WAAW,UAC5C,MAAK,MAAM,OAAO,aAAa,WAAW;GACxC,MAAM,SAAS,KAAK,WAAW,UAAU;AACzC,OAAI,CAAC,UAAU,OAAO,WAAW,SAAU;GAE3C,MAAM,UAAU,aAAa,UAAU;AACvC,WAAQ,OAAO;;;AAKrB,KAAI,aAAa,cAAc,KAAK,MAClC,MAAK,MAAM,OAAO,aAAa,YAAY;EACzC,MAAM,CAAC,QAAQA,UAAQ,IAAI,MAAM,IAAI;AACrC,MAAI,CAAC,UAAU,CAACA,OAAM;EAEtB,MAAM,WAAW,KAAK,MAAMA;AAC5B,MAAI,CAAC,SAAU;EAEf,MAAM,YACJ,SAAS,OAAO,mBAAmB,KACnC,SAAS,OAAO,mBAAmB;AACrC,MAAI,CAAC,aAAa,OAAO,cAAc,SAAU;EAEjD,MAAM,UAAU,aAAa,WAAW;AACxC,UAAQ,UAAiB;;;;;;AC/G/B,MAAa,oBAAoB,UAAgC;CAC/D,MAAMC,SAWkB;EACtB,GAAG;EACH,MAAM;EACP;AAED,KACE,MAAM,SACL,OAAO,MAAM,SAAS,YAAY,MAAM,aAAa,YACtD;AACA,SAAO,OAAO,MAAM;AACpB,SAAO;;CAGT,MAAM,CAAC,UAAU,aAAa,MAAM,KAAK,MAAM,IAAI;CAEnD,MAAM,aADc,aAAa,IAAI,MAAM,IAAI,CAClB,KAAK,SAAS,KAAK,MAAM,IAAI,CAAC;CAE3D,IAAIC,SAAO,YAAY;AACvB,KAAIA,OAAK,SAAS,IAAI,CACpB,UAAOA,OAAK,MAAM,GAAGA,OAAK,SAAS,EAAE;CAGvC,MAAM,GAAG,WAAWA,OAAK,MAAM,MAAM;CACrC,MAAM,CAAC,SAAS,cAAc,YAAY,WAAW,IAAI,MAAM,IAAI;AACnE,QAAO,eAAe,gBAAgB,MAAM;AAC5C,QAAO,UAAU,WAAW,MAAM;CAElC,MAAMC,cAA6B,EAAE;CAErC,MAAM,UAAU;AAChB,QAAO,UACL,UAAU,MAAM,CAAC,SAAS,QAAQ,QAAQ,GAAG,MAC7C,MAAM,WACN,QAAQ,IAAI;AACd,KAAI,OAAO,QACT,aAAY,KAAK,GAAG,QAAQ,GAAG,OAAO,UAAU;CAGlD,MAAM,UAAU;AAChB,QAAO,SACL,UAAU,MAAM,CAAC,SAAS,QAAQ,QAAQ,GAAG,MAAM,MAAM;AAC3D,KAAI,OAAO,OACT,aAAY,KAAK,GAAG,QAAQ,GAAG,OAAO,SAAS;CAGjD,MAAM,aAAa;AACnB,QAAO,aACL,UAAU,MAAM,CAAC,SAAS,QAAQ,WAAW,GAAG,MAAM,MAAM;AAC9D,KAAI,OAAO,WACT,aAAY,KAAK,GAAG,WAAW,GAAG,OAAO,aAAa;CAGxD,MAAM,QAAQ;AACd,QAAO,OACL,UAAU,MAAM,CAAC,SAAS,QAAQ,MAAM,GAAG,IAAI,MAAM,IAAI,IAAI,MAAM;AACrE,KAAI,OAAO,MAAM,OACf,aAAY,KAAK,GAAG,MAAM,GAAG,OAAO,KAAK,KAAK,IAAI,GAAG;CAGvD,MAAM,WAAW;AACjB,QAAO,UACL,UAAU,MAAM,CAAC,SAAS,QAAQ,SAAS,GAAG,MAAM,MAAM;AAC5D,KAAI,OAAO,QACT,aAAY,KAAK,GAAG,SAAS,GAAG,OAAO,UAAU;AAGnD,KAAI,CAAC,OAAO,aACV,OAAM,IAAI,MACR,uGACD;AAGH,KAAI,CAAC,OAAO,QACV,OAAM,IAAI,MACR,6FACD;CAGH,MAAM,QAAQ,YAAY,KAAK,IAAI;CACnC,MAAM,cAAc,WAAW;CAC/B,MAAM,cAAc,YAAY,WAAW,YAAY;CACvD,MAAM,0BAA0B,CAC9B,cAAc,SAAS,SACvB,YACD,CAAC,KAAK,MAAM;CACb,MAAM,eAAe,cACjB;EACE;EACA;EACA;EACA,OAAO;EACP,OAAO;EACR,CAAC,KAAK,IAAI,GACX;EAAC;EAAyB,OAAO;EAAc,OAAO;EAAQ,CAAC,KAAK,IAAI;AAC5E,QAAO,OAAO,QAAQ,GAAG,aAAa,GAAG,UAAU;AAEnD,QAAO;;AAGT,MAAM,iBACJ,YACA,aACG;CACH,MAAMC,QAAuB,EAAE;CAE/B,MAAM,YAAY,OAAO,KAAK,QAAQ,WAAW,EAAE,IAAI;CACvD,MAAM,QAAQ,WAAW;CACzB,MAAM,aAAa,OAAO,KACxB,mBAAmB,MAAM,GAAG,UAAU,IAAI,UAAU,SAAS,GAC9D;AACD,OAAM,KAAK,GAAG,UAAU,IAAI,aAAa;AAEzC,YAAW,SAAS,WAAW,UAAU;EACvC,MAAM,gBAAgB,MAAM,QAAQ,EAAE;EACtC,MAAM,aAAa,OAAO,KAAK,cAAc;EAC7C,MAAM,eAAe,IAAI,OAAO,cAAc,OAAO;AAErD,MAAI,OAAO,UAAU,SAAS,UAAU;AACtC,SAAM,KAAK,GAAG,YAAY,WAAW,2BAA2B;AAChE;;AAGF,UAAQ,UAAU,UAAlB;GACE,KAAK,WAAW;IACd,MAAM,YAAY,CAAC,UAAU,cAAc,UAAU,QAAQ,CAC1D,OAAO,QAAQ,CACf,KAAK,IAAI;AACZ,UAAM,KAAK,GAAG,YAAY,aAAa,YAAY;AACnD,QAAI,UAAU,OACZ,OAAM,KACJ,GAAG,YAAY,eAAe,OAAO,KAAK,UAAU,CAAC,GAAG,OAAO,MAC7D,UAAU,OACX,GACF;AAEH,QAAI,UAAU,WACZ,OAAM,KACJ,GAAG,YAAY,eAAe,OAAO,KAAK,UAAU,CAAC,GAAG,OAAO,MAC7D,UAAU,WACX,GACF;AAEH,QAAI,UAAU,MAAM,OAClB,OAAM,KACJ,GAAG,YAAY,eAAe,OAAO,KAAK,QAAQ,CAAC,GAAG,OAAO,MAC3D,UAAU,KAAK,KAAK,KAAK,CAC1B,GACF;AAEH,QAAI,UAAU,QACZ,OAAM,KACJ,GAAG,YAAY,eAAe,OAAO,KAAK,WAAW,CAAC,GAAG,OAAO,MAC9D,UAAU,QACX,GACF;AAEH,UAAM,KACJ,GAAG,YAAY,eAAe,OAAO,KAAK,YAAY,CAAC,GAAG,OAAO,MAAM,UAAU,GAClF;AACD;;GAEF,KAAK,UAAU;IACb,MAAM,YAAY,CAAC,UAAU,cAAc,UAAU,QAAQ,CAC1D,OAAO,QAAQ,CACf,KAAK,IAAI;AACZ,QAAI,CAAC,UACH,OAAM,KAAK,GAAG,YAAY,aAAa,UAAU,OAAO;QAExD,OAAM,KAAK,GAAG,YAAY,aAAa,YAAY;AAGrD,QAAI,UAAU,KACZ,OAAM,KACJ,GAAG,YAAY,eAAe,OAAO,KAAK,QAAQ,CAAC,GAAG,OAAO,MAE3D,UAAU,KACX,GACF;AAEH,UAAM,KACJ,GAAG,YAAY,eAAe,OAAO,KAAK,YAAY,CAAC,GAAG,OAAO,MAAM,SAAS,GACjF;AACD;;GAEF,KAAK,UAAU;IACb,MAAM,YAAY,CAAC,UAAU,cAAc,UAAU,QAAQ,CAC1D,OAAO,QAAQ,CACf,KAAK,IAAI;AACZ,UAAM,KAAK,GAAG,YAAY,aAAa,YAAY;AACnD,UAAM,KACJ,GAAG,YAAY,eAAe,OAAO,KAAK,YAAY,CAAC,GAAG,OAAO,MAAM,SAAS,GACjF;AACD;;GAEF;AACE,UAAM,KAAK,GAAG,YAAY,aAAa,UAAU,OAAO;AACxD;;GAEJ;AAEF,MAAK,MAAM,QAAQ,MACjB,SAAQ,IAAI,KAAK;;AAIrB,MAAaC,iBAAe,OAAO,EACjC,QACA,cACA,UACA,QACA,SAAS,eAUyB;CAClC,MAAMC,UACJ,YACA,MAAM,KAAK,EAAE,QAAQ,OAAO,MAAM,QAAQ,SAAS,EACjD,SAAS,IAAI,SAAS,EACvB,EAAE;CAEL,MAAM,aAAa,OAAO,MAAM,KAAK,UAAU,iBAAiB,MAAM,CAAC;AAGvE,KAAI,OAAO,KAAK,UAAU,YAAY,CAAC,SACrC,eAAc,YAAY,SAAS;CAGrC,MAAM,cAAc,OAAO,OAAc,UAAkB;EACzD,MAAM,YAAY,OAAO,UAAU,OAAO;EAC1C,MAAM,EAAE,aAAa,OAAO,eAAe,aAAa,MAAM,QAAQ;GACpE,cAAc,MAAM;GACpB,WAAW,WAAW,OAAQ;GAC9B,SAAS,MAAM,MAAM;GACrB,OAAO,QAAQ;GAChB,CAAC;AACF,YAAU,SAAS;AAKnB,MAAI,SAAS,CAAC,SACZ,OAAM,IAAI,MACR,8BAA8B,SAAS,OAAO,IAAI,SAAS,aAC5D;AAGH,SAAO;GAAE;GAAa;GAAe;;CAEvC,MAAM,YACJ,MAAM,QAAQ,IACZ,OAAO,MAAM,KAAK,OAAO,UAAU,YAAY,OAAO,MAAM,CAAC,CAC9D,EACD,QAAQ,SAAS,KAAK,eAAe,KAAK,cAAc;CAE1D,IAAIC;AAEJ,KAAI,SAAS,QAAQ;EACnB,MAAM,YAAY,IAAI,YAAY;EAClC,MAAM,OACJ,SAAS,SAAS,IACd,MAAM,UAAU,WAAW;GACzB,aAAa,SAAS,KAAK,WAASC,OAAK,YAAa;GACtD,oBAAoB,EAAE;GACtB,gBAAgB,SAAS,KAAK,WAASA,OAAK,cAAe;GAC5D,CAAC,GACF,MAAM,UAAU,OAAO;GACrB,aAAa,SAAS,GAAI;GAC1B,mBAAmB;GACnB,eAAe,SAAS,GAAI;GAC7B,CAAC;AAIR,MAAI,OAAO,KAAK,UAAU,YAAY,UAAU;AAC9C,WAAQ,OAAO;AACf,iBAAc,YAAY,SAAS;;EAGrC,MAAM,kBAAkB,OAAO,UAAU,cAAc;AACvD,mBAAiB;GAAE,cAAc,OAAO,OAAO;GAAO,MAAM;GAAM,CAAC;AACnE,kBAAgB,SAAS;EAEzB,MAAM,cAAc,OAAO,UAAU,SAAS;AAC9C,YAAU,iBAAiB;GAAE;GAAQ;GAAc;GAAQ,MAAM;GAAM,CAAC;AACxE,UAAQ,QAAQ,WAAW,QAAQ,IAAI,OAAO,CAAC;AAC/C,cAAY,SAAS;EAErB,MAAM,iBAAiB,OAAO,UAAU,YAAY;AACpD,QAAM,eAAe,EAAE,SAAS,CAAC;AACjC,iBAAe,SAAS;EAExB,MAAM,mBAAmB,OAAO,UAAU,cAAc;AACxD,MAAI,CAAC,OAAO,QAAQ;GAClB,MAAM,YAAY,OAAO,KAAK,QAAQ,WAAW,EAAE,IAAI;AACvD,qBAAkB,OAAO,QAAQ,UAAU;AAE3C,OAAI,OAAO,KAAK,UAAU,UAAU;IAClC,MAAM,aAAa,QAAQ,IAAI,WAC3B,KAAK,KAAK,SAAS,QAAQ,IAAI,UAAU,OAAO,OAAO,KAAK,KAC5D,OAAO,OAAO;AAClB,YAAQ,IACN,GAAG,YAAY,OAAO,MAAM,UAAU,CAAC,qBAAqB,OAAO,WAAW,WAAW,GAC1F;;;AAGL,mBAAiB,SAAS;;CAG5B,MAAM,eAAe,OAAO,MAAM,MAC/B,OAAO,UACN,MAAM,MAAM,WAAW,OAAO,WAAW,OAAQ,SAAS,SAC7D;AAED,KAAI,aACF,kBAAiB;AACf,iBAAa;GACX;GACA;GACA;GACA;GACA;GACD,CAAC;IACD,aAAa,MAAM,SAAS;AAGjC,QAAO;;;;;ACrWT,MAAM,YAAY;;;;;;;;;AAUlB,MAAM,gBACJ,OACA,YAGG;CACH,MAAMC,QAAuB,EAAE;CAC/B,MAAM,UAAU,MAAM,KAAa,EAAE,QAAQ,SAAS,WAAW,GAAG,CAAC,CAAC,KACpE,GACD;AACD,OAAM,KAAK,GAAG,QAAQ;CACtB,IAAI,gBAAgB;CACpB,IAAI,OAAO;AACX,MAAK,MAAM,QAAQ,MACjB,KAAI,SAAS,MACX;MAAI,MAAM;AACR,SAAM,KAAK,KAAK;AAChB,mBAAgB,KAAK,IAAI,eAAe,KAAK,OAAO;AACpD,UAAO;;OAGT,SAAQ;AAGZ,OAAM,KAAK,GAAG,QAAQ;AACtB,QAAO;EAAE;EAAO;EAAe;;AAIjC,SAAgB,cAAc,WAAoB,OAAa;CAC7D,MAAM,cAAc,iBAAiB;AACrC,KAAI,UAAU;EACZ,MAAM,OAAO,aAAa,WAAW,EAAE,SAAS,GAAG,CAAC;AACpD,OAAK,MAAM,QAAQ,KAAK,MACtB,SAAQ,IAAI,OAAO,KAAK,KAAK,CAAC;;AAGlC,SAAQ,IAAI,OAAO,KAAK,GAAG,YAAY,KAAK,IAAI,YAAY,UAAU,CAAC;AACvE,SAAQ,IAAI,GAAG;;;;;;;;;;AC3BjB,eAAsB,aACpB,YACA,SAAS,IAAI,QAAQ,EACY;CACjC,MAAM,iBACJ,OAAO,eAAe,aAAa,MAAM,YAAY,GAAG;CAC1D,MAAM,cAAc,iBAChB,0BAA0B,QACxB,iBACA,CAAC,eAAe,GAClB,EAAE;CAEN,IAAI,UAAU,YAAY,MACvB,WAAW,QAAQ,OAAO,CAAC,UAAU,SACvC,EAAE;AACH,KAAI,OAAO,YAAY,SACrB,WAAU,QAAQ,EAAE,MAAM,SAAS,CAAC;CAGtC,IAAIC,OAAwB,EAAE;AAE9B,KAAI;AACF,oBAAkB;EAElB,MAAM,oBAAoB,OAAO,UAAU,eAAe;EAE1D,MAAM,cAAc,OAAO,UAAU,SAAS;EAC9C,MAAM,WAAW,MAAM,YAAY;GAAE;GAAQ;GAAa,CAAC;EAC3D,MAAM,eAAe,SAAS;AAC9B,SAAO,SAAS;AAEhB,MADmB,KAAK,MAAM,QAAQ,IAAI,OAAO,KAAK,UAAU,SAAS,CACzD,gBAAe;AAC/B,cAAY,SAAS;EAErB,MAAM,eAAe,KAAK,SAAS,QACjC,IAAI,OAAO,KAAK,WAAW;GAAE;GAAO,UAAU,IAAI;GAAO,EAAE,CAC5D;AACD,MAAI,aAAa,SAAS,EACxB,OAAM,IAAI,sBAAsB,aAAa;EAoB/C,MAAM,YAjBU,MAAM,QAAQ,IAC5B,KAAK,IAAI,OAAO,QAAQ;AACtB,OAAI;AACF,WAAO,MAAMC,eAAc;KACzB,QAAQ,IAAI;KACZ;KACA,UAAU,IAAI;KACd;KACD,CAAC;YACK,OAAO;AACd,UAAM,IAAI,SAAS,IAAI;KACrB;KACA,UAAU,IAAI;KACf,CAAC;;IAEJ,CACH,EACwB,QAAQ,QAAwB,QAAQ,OAAU;AAE3E,oBAAkB,SAAS;AAE3B,SAAO,OAAO,KAAK,MAAM,QAAQ,IAAI,OAAO,KAAK,UAAU,QAAQ,CAAC;AAEpE,SAAO;UACA,OAAO;EACd,MAAM,OACJ,KAAK,MAAM,QAAQ,IAAI,OAAO,KAAK,UAAU,SAAS,EAAE,OAAO,QAC/D,KAAK,IAAI,OAAO,QAChB;EACF,MAAM,SACJ,KAAK,MAAM,QAAQ,IAAI,OAAO,OAAO,IACrC,YAAY,MAAM,WAAW,OAAO,OAAO,IAC3C;EACF,MAAM,UACJ,MAAM,QAAQ,CAAC,SACX,eAAe,OAAO,KAAK,QAAQ,GAAG,GACtC;AACN,MAAI,CAAC,QAAQ,KAAK,UAAU,UAAU;AACpC,oBAAiB;IAAE;IAAO;IAAS,CAAC;AAKpC,OAAI,MAAM,kBAAkB;IAAE;IAAO,eAHnC,KAAK,MAAM,QAAQ,IAAI,OAAO,YAAY,IAC1C,YAAY,MAAM,WAAW,OAAO,YAAY,IAChD;IACkD,CAAC,CACnD,OAAM,+BAA+B,MAAM;;AAI/C,QAAM;;;;;;;;;AC5GV,MAAa,QAAQ;CAInB,WAAW,EACT,MAAM,QACN,wBACA,SASC;AACD,SAAO,OAAO,OAAO,QAAQ,EAAE,wBAAwB,CAAC;;CAK1D;CACD;;;;AC+CD,OAAO,UAAU,cAAc,CAAC;;;;AAOhC,eAAsB,aACpB,QACY;AACZ,QAAO,OAAO,WAAW,aAAa,MAAM,QAAQ,GAAG"}